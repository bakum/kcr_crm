--
-- Скрипт сгенерирован Devart dbForge Studio for Oracle, Версия 3.7.472.0
-- Домашняя страница продукта: http://www.devart.com/ru/dbforge/oracle/studio
-- Дата скрипта: 20.10.2015 19:04:11
-- Версия сервера: Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production With the Partitioning, OLAP, Data Mining and Real Application Testing options
-- Версия клиента: 
--


CONNECT dba_kcr/divas@localhost:1521/db11g;


-- 
-- Установка схемы по умолчанию
--
ALTER SESSION SET CURRENT_SCHEMA = "DBA_KCR";

SET SQLBLANKLINES ON;
SET DEFINE OFF;
ALTER SESSION SET NLS_DATE_FORMAT = 'MM/DD/SYYYY HH24:MI:SS';
ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF TZH:TZM';
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF';
ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '.,';
ALTER SESSION SET NLS_NCHAR_CONV_EXCP = FALSE;
ALTER SESSION SET TIME_ZONE = '+03:00';

--
-- Описание для последовательности ORDERS_NUM_SEQ
--
CREATE SEQUENCE ORDERS_NUM_SEQ
START WITH 681
INCREMENT BY 1
MAXVALUE 1000000000000000000000000000
MINVALUE 1
CYCLE;

--
-- Описание для последовательности OTHER_ZATR_NUM_SEQ
--
CREATE SEQUENCE OTHER_ZATR_NUM_SEQ
START WITH 181
INCREMENT BY 1
MAXVALUE 1000000000000000000000000000
MINVALUE 1
CYCLE;

--
-- Описание для последовательности PKO_NUM_SEQ
--
CREATE SEQUENCE PKO_NUM_SEQ
START WITH 141
INCREMENT BY 1
MAXVALUE 1000000000000000000000000000
MINVALUE 1
CYCLE;

--
-- Описание для последовательности PROFIT_DISTRIB_NUM_SEQ
--
CREATE SEQUENCE PROFIT_DISTRIB_NUM_SEQ
START WITH 121
INCREMENT BY 1
MAXVALUE 1000000000000000000000000000
MINVALUE 1
CYCLE;

--
-- Описание для последовательности PS_TXN_SEQ
--
CREATE SEQUENCE PS_TXN_SEQ
START WITH 165651
INCREMENT BY 50;

--
-- Описание для последовательности RKO_NUM_SEQ
--
CREATE SEQUENCE RKO_NUM_SEQ
START WITH 161
INCREMENT BY 1
MAXVALUE 1000000000000000000000000000
MINVALUE 1
CYCLE;

--
-- Описание для последовательности START_OST_NUM_SEQ
--
CREATE SEQUENCE START_OST_NUM_SEQ
START WITH 141
INCREMENT BY 1
MAXVALUE 1000000000000000000000000000
MINVALUE 1
CYCLE;

--
-- Описание для ROW_TABLE_DELETED
--
-- ROW_TABLE_DELETED specification
CREATE OR REPLACE TYPE "ROW_TABLE_DELETED"
  AS
  OBJECT (TABLE_ID VARCHAR2(50),
          MAIN_ID VARCHAR2(50),
          TABLE_NAME VARCHAR2(30),
          COLUMN_NAME VARCHAR2(4000),
          CONSTRAINT_TYPE VARCHAR2(1),
          REF_STR VARCHAR2(4000));
/

--
-- Описание для USERTYPE
--
-- USERTYPE specification
CREATE OR REPLACE TYPE "USERTYPE"
  AS
  OBJECT (n VARCHAR2(50),
          u_name VARCHAR2(1000));
/

--
-- Описание для ROW_ZATRATY
--
-- ROW_ZATRATY specification
CREATE OR REPLACE TYPE "ROW_ZATRATY"
  AS
  OBJECT (REGISTRATOR_ID VARCHAR2(50 CHAR),
          TABLE_NAME VARCHAR2(100 CHAR),
          CODE VARCHAR2(6 CHAR),
          SUMMA NUMBER,
          ZATRATY_ID VARCHAR2(50 CHAR),
          ZATRATY_NAME VARCHAR2(150 CHAR),
          DIVISION_ID VARCHAR2(50 CHAR),
          PERIOD TIMESTAMP(6));
/

--
-- Описание для ROW_SALES
--
-- ROW_SALES specification
CREATE OR REPLACE TYPE "ROW_SALES"
  AS
  OBJECT (ORDER_ID VARCHAR2(50 CHAR),
          KONTRAG_ID VARCHAR2(50 CHAR),
          PERIOD DATE,
          DIVISION_ID VARCHAR2(50 CHAR),
          SALES_SUMMA NUMBER,
          FACT_SEBEST_SUMMA NUMBER,
          PLAN_SEBEST_SUMMA NUMBER);
/

--
-- Описание для ROW_REFERENCE
--
-- ROW_REFERENCE specification
CREATE OR REPLACE TYPE "ROW_REFERENCE"
  AS
  OBJECT (TABLE_ID VARCHAR2(50),
          MAIN_ID VARCHAR2(50),
          TABLE_NAME VARCHAR2(30),
          COLUMN_NAME VARCHAR2(4000),
          CONSTRAINT_TYPE VARCHAR2(1));
/

--
-- Описание для ROW_TABLE_REFERENCE
--
-- ROW_TABLE_REFERENCE specification
CREATE OR REPLACE TYPE "ROW_TABLE_REFERENCE"
  AS
  OBJECT (TABLE_NAME VARCHAR2(30),
          CONSTRAINT_NAME VARCHAR2(30),
          COLUMN_NAME VARCHAR2(4000),
          R_TABLE_NAME VARCHAR2(30),
          POSITION NUMBER,
          CONSTRAINT_TYPE VARCHAR2(1));
/

--
-- Описание для ROW_RATING
--
-- ROW_RATING specification
CREATE OR REPLACE TYPE "ROW_RATING"
  AS
  OBJECT (PLACE NUMBER,
          DIVISION_ID VARCHAR2(50 CHAR),
          CNT NUMBER,
          TOTAL NUMBER,
          BALL_SUM NUMBER,
          BALL_CNT NUMBER,
          BALL_TOTAL NUMBER);
/

--
-- Описание для ROW_BALLANS
--
-- ROW_BALLANS specification
CREATE OR REPLACE TYPE "ROW_BALLANS"
  AS
  OBJECT (ID VARCHAR2(50 CHAR),
          CODE VARCHAR2(6 CHAR),
          FULLNAME VARCHAR2(3000 CHAR),
          ACTIVE_START NUMBER,
          ACTIVE_DEB NUMBER,
          ACTIVE_KRED NUMBER,
          ACTIVE_OBOROT NUMBER,
          ACTIVE_END NUMBER,
          PASSIVE_START NUMBER,
          PASSIVE_DEB NUMBER,
          PASSIVE_KRED NUMBER,
          PASSIVE_OBOROT NUMBER,
          PASSIVE_END NUMBER,
          DIVISION_ID VARCHAR2(50 CHAR));
/

--
-- Описание для KONTRAGTYPE
--
-- KONTRAGTYPE specification
CREATE OR REPLACE TYPE "KONTRAGTYPE"
  AS
  OBJECT (n VARCHAR2(50),
          u_name VARCHAR2(1000),
          root NUMBER);
/

--
-- Описание для DIVISIONTYPE
--
-- DIVISIONTYPE specification
CREATE OR REPLACE TYPE "DIVISIONTYPE"
  AS
  OBJECT (n VARCHAR2(50),
          u_name VARCHAR2(1000));
/

--
-- Описание для TBL_DELETED_REF
--
CREATE OR REPLACE TYPE TBL_DELETED_REF AS
TABLE OF ROW_TABLE_DELETED;
/

--
-- Описание для TBL_DELETED
--
CREATE OR REPLACE TYPE TBL_DELETED AS
TABLE OF ROW_TABLE_DELETED;
/

--
-- Описание для USERTABLE
--
CREATE OR REPLACE TYPE USERTABLE AS
TABLE OF USERTYPE;
/

--
-- Описание для TBL_ZATRATY
--
CREATE OR REPLACE TYPE TBL_ZATRATY AS
TABLE OF ROW_ZATRATY;
/

--
-- Описание для TBL_SALES
--
CREATE OR REPLACE TYPE TBL_SALES AS
TABLE OF ROW_SALES;
/

--
-- Описание для TBL_REF_TAB
--
CREATE OR REPLACE TYPE TBL_REF_TAB AS
TABLE OF ROW_REFERENCE;
/

--
-- Описание для TBL_REFERENCE
--
CREATE OR REPLACE TYPE TBL_REFERENCE AS
TABLE OF ROW_TABLE_REFERENCE;
/

--
-- Описание для TBL_RATING
--
CREATE OR REPLACE TYPE TBL_RATING AS
TABLE OF ROW_RATING;
/

--
-- Описание для TBL_BALLANS
--
CREATE OR REPLACE TYPE TBL_BALLANS AS
TABLE OF ROW_BALLANS;
/

--
-- Описание для KONTRAGTABLE
--
CREATE OR REPLACE TYPE KONTRAGTABLE AS
TABLE OF KONTRAGTYPE;
/

--
-- Описание для DIVISIONTABLE
--
CREATE OR REPLACE TYPE DIVISIONTABLE AS
TABLE OF DIVISIONTYPE;
/

--
-- Описание для таблицы USERS
--
CREATE TABLE USERS (
  ID                 VARCHAR2(50 CHAR)  NOT NULL,
  FIRST_NAME         VARCHAR2(50 CHAR)  DEFAULT 'NoFirstName' NOT NULL,
  LAST_NAME          VARCHAR2(50 CHAR)  DEFAULT 'NoLastName' NOT NULL,
  EMAIL              VARCHAR2(100 CHAR) DEFAULT 'no@email.com' NOT NULL,
  IS_ADMIN           NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  PASS_WD            VARCHAR2(100 CHAR) NOT NULL,
  LOGIN              VARCHAR2(30 CHAR)  NOT NULL,
  VERSION            TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  PREDEFINED         NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  U_DESCRIPTION      VARCHAR2(1000 CHAR),
  IS_ZAMER           NUMBER(1, 0)       DEFAULT 0,
  IS_ACTIVE          NUMBER(1, 0)       DEFAULT 1 NOT NULL,
  DATE_BEFIRE_ACCEPT NUMBER(1, 0)       DEFAULT 0,
  DATE_BEFORE        DATE,
  PHOTO              BLOB,
  CONSTRAINT USERS_CHK1 CHECK (is_zamer IN (0, 1)),
  CONSTRAINT USERS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                            NEXT 1 M
                                                            MAXEXTENTS UNLIMITED),
  CONSTRAINT USERS_UK1 UNIQUE (LOGIN) USING INDEX STORAGE (INITIAL 64 K
                                                           NEXT 1 M
                                                           MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE USERS IS 'Пользователи';

--
-- Описание для таблицы ENUM_ACCOUNT_TYPE
--
CREATE TABLE ENUM_ACCOUNT_TYPE (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  FULLNAME VARCHAR2(20 CHAR) NOT NULL,
  VERSION  TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT ENUM_ACCOUNT_TYPE_CHK1 CHECK (FULLNAME IN ('Активный', 'Пассивный', 'Активный/Пассивный')),
  CONSTRAINT ENUM_ACCOUNT_TYPE_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                        NEXT 1 M
                                                                        MAXEXTENTS UNLIMITED),
  CONSTRAINT ENUM_ACCOUNT_TYPE_UK1 UNIQUE (FULLNAME) USING INDEX STORAGE (INITIAL 64 K
                                                                          NEXT 1 M
                                                                          MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE ENUM_ACCOUNT_TYPE IS 'ТипыСчетов';

--
-- Описание для таблицы TYPE_OF_ACTIVITIES
--
CREATE TABLE TYPE_OF_ACTIVITIES (
  ID       VARCHAR2(50 CHAR)  NOT NULL,
  VERSION  TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  FULLNAME VARCHAR2(150 CHAR) NOT NULL,
  CONSTRAINT TYPE_OF_ACTIVITIES_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                         NEXT 1 M
                                                                         MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE TYPE_OF_ACTIVITIES IS 'ВидыДеятельности';

--
-- Описание для таблицы CURRENCY
--
CREATE TABLE CURRENCY (
  ID         VARCHAR2(50 CHAR) NOT NULL,
  IS_GROUP   NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  PARENT_ID  VARCHAR2(50 CHAR),
  DELETED    NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  FULLNAME   VARCHAR2(5 CHAR)  NOT NULL,
  CODE       VARCHAR2(3 CHAR),
  NAMEFULL   VARCHAR2(50 CHAR),
  VERSION    TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  PREDEFINED NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  ID_XML     VARCHAR2(3 CHAR)  DEFAULT '0' NOT NULL,
  CONSTRAINT CURRENCY_CHK1 CHECK (deleted IN (0, 1)),
  CONSTRAINT CURRENCY_CHK2 CHECK (PREDEFINED IN (0, 1)),
  CONSTRAINT CURRENCY_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                               NEXT 1 M
                                                               MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE CURRENCY IS 'Валюты';

--
-- Описание для таблицы TYPE_DEF
--
CREATE TABLE TYPE_DEF (
  ID         VARCHAR2(50 CHAR) NOT NULL,
  TABLE_NAME VARCHAR2(100 CHAR),
  VERSION    TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT TYPE_DEF_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                               NEXT 1 M
                                                               MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE TYPE_DEF IS 'ТипыОбъектов';

--
-- Описание для таблицы COMPAIGNS
--
CREATE TABLE COMPAIGNS (
  ID         VARCHAR2(50 CHAR)  NOT NULL,
  NAME       VARCHAR2(100 CHAR) NOT NULL,
  VERSION    TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  ENABLED    NUMBER(1, 0)       DEFAULT 1 NOT NULL,
  PREDEFINED NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  DELETED    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  CONSTRAINT COMPAIGNS_DELETED_CHK CHECK (deleted IN (0, 1)),
  CONSTRAINT COMPAIGNS_ENABLED_CHK CHECK (enabled IN (0, 1)),
  CONSTRAINT COMPAIGNS_PREDEFINED_CHK CHECK (predefined IN (0, 1)),
  CONSTRAINT COMPAIGNS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                NEXT 1 M
                                                                MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE COMPAIGNS IS 'ЛистыОбзвона';

--
-- Описание для таблицы QRTZ_JOB_DETAILS
--
CREATE TABLE QRTZ_JOB_DETAILS (
  SCHED_NAME        VARCHAR2(120 BYTE) NOT NULL,
  JOB_NAME          VARCHAR2(200 BYTE) NOT NULL,
  JOB_GROUP         VARCHAR2(200 BYTE) NOT NULL,
  DESCRIPTION       VARCHAR2(250 BYTE),
  JOB_CLASS_NAME    VARCHAR2(250 BYTE) NOT NULL,
  IS_DURABLE        VARCHAR2(1 BYTE)   NOT NULL,
  IS_NONCONCURRENT  VARCHAR2(1 BYTE)   NOT NULL,
  IS_UPDATE_DATA    VARCHAR2(1 BYTE)   NOT NULL,
  REQUESTS_RECOVERY VARCHAR2(1 BYTE)   NOT NULL,
  JOB_DATA          BLOB,
  CONSTRAINT QRTZ_JOB_DETAILS_PK PRIMARY KEY (SCHED_NAME, JOB_NAME, JOB_GROUP)
)
LOGGING;

CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS (SCHED_NAME, JOB_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS (SCHED_NAME, REQUESTS_RECOVERY)
LOGGING;

COMMENT ON TABLE QRTZ_JOB_DETAILS IS 'Quartz_2.2.1';

--
-- Описание для таблицы BASE_OF_CALC
--
CREATE TABLE BASE_OF_CALC (
  ID       VARCHAR2(50 CHAR)  NOT NULL,
  NAME     VARCHAR2(100 CHAR) NOT NULL,
  FULLNAME VARCHAR2(100 CHAR) NOT NULL,
  CONSTRAINT BASE_OF_CALC_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE BASE_OF_CALC IS 'Алгоритмы расчетов';

--
-- Описание для таблицы ORDER_STATUS
--
CREATE TABLE ORDER_STATUS (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  VERSION  TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  NAME     VARCHAR2(50 CHAR) NOT NULL,
  FULLNAME VARCHAR2(50 CHAR),
  CONSTRAINT ORDER_STATUS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED)
)
LOGGING;

CREATE INDEX ORDER_STATUS_INDEX1 ON ORDER_STATUS (NAME)
LOGGING;

COMMENT ON TABLE ORDER_STATUS IS 'СтатусыЗаказов';

--
-- Описание для таблицы CALL_RESULTS
--
CREATE TABLE CALL_RESULTS (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  NAME     VARCHAR2(20 CHAR) NOT NULL,
  FULLNAME VARCHAR2(25 CHAR) NOT NULL,
  CONSTRAINT CALL_RESULTS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE CALL_RESULTS IS 'РезультатыЗвонков';

--
-- Описание для таблицы CALL_STATUS
--
CREATE TABLE CALL_STATUS (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  NAME     VARCHAR2(50 CHAR) NOT NULL,
  FULLNAME VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT CALL_STATUS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                  NEXT 1 M
                                                                  MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE CALL_STATUS IS 'СтатусыЗвонков';

--
-- Описание для таблицы FIRMS
--
CREATE TABLE FIRMS (
  ID         VARCHAR2(50 CHAR)  NOT NULL,
  FULLNAME   VARCHAR2(150 CHAR) NOT NULL,
  PRINTNAME  VARCHAR2(200 CHAR) NOT NULL,
  UR_FIZ     NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  INN        VARCHAR2(50 CHAR),
  OKPO       VARCHAR2(50 CHAR),
  VERSION    TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  DELETED    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  PREDEFINED NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  CONSTRAINT FIRMS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                            NEXT 1 M
                                                            MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE FIRMS IS 'Организации';

--
-- Описание для таблицы OPERATION_RKO
--
CREATE TABLE OPERATION_RKO (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  NAME     VARCHAR2(50 CHAR) NOT NULL,
  FULLNAME VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT OPERATION_RKO_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                    NEXT 1 M
                                                                    MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE OPERATION_RKO IS 'ОперацииРКО';

--
-- Описание для таблицы OPERATION_PKO
--
CREATE TABLE OPERATION_PKO (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  NAME     VARCHAR2(50 CHAR) NOT NULL,
  FULLNAME VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT OPERATION_PKO_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                    NEXT 1 M
                                                                    MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE OPERATION_PKO IS 'ОперацииПКО';

--
-- Описание для таблицы MEASURE_UNIT
--
CREATE TABLE MEASURE_UNIT (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  FULLNAME VARCHAR2(20 CHAR) NOT NULL,
  CODE     VARCHAR2(3 CHAR)  DEFAULT '000' NOT NULL,
  DELETED  NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  VERSION  TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT MEASURE_UNIT_CHK1 CHECK (DELETED IN (1, 0)),
  CONSTRAINT MEASURE_UNIT_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE MEASURE_UNIT IS 'ЕдиницыИзмерения';

--
-- Описание для таблицы NOMENKLATURA
--
CREATE TABLE NOMENKLATURA (
  ID         VARCHAR2(50 BYTE)  NOT NULL,
  FULLNAME   VARCHAR2(150 CHAR) NOT NULL,
  DELETED    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  IS_GROUP   NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  PARENT_ID  VARCHAR2(50 CHAR),
  USLUGA     NUMBER(1, 0)       DEFAULT 1 NOT NULL,
  PREDEFINED NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  VERSION    TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  ARTIKUL    VARCHAR2(50 CHAR),
  CONSTRAINT NOMENKLATURA_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED),
  CONSTRAINT NOMENKLATURA_NOMENKLATURA_FK1 FOREIGN KEY (PARENT_ID)
  REFERENCES NOMENKLATURA (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE NOMENKLATURA IS 'Номенклатура';

--
-- Описание для таблицы BASE_OF_NACHISL
--
CREATE TABLE BASE_OF_NACHISL (
  ID       VARCHAR2(50 CHAR)  NOT NULL,
  NAME     VARCHAR2(20 CHAR)  NOT NULL,
  FULLNAME VARCHAR2(100 CHAR) NOT NULL,
  CONSTRAINT BASE_OF_NACHISL_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                      NEXT 1 M
                                                                      MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE BASE_OF_NACHISL IS 'Алгоритмы начислений';

--
-- Описание для таблицы ZATRATY
--
CREATE TABLE ZATRATY (
  ID         VARCHAR2(50 CHAR)  NOT NULL,
  IS_GROUP   NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  PARENT_ID  VARCHAR2(50 BYTE),
  DELETED    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  FULLNAME   VARCHAR2(150 CHAR) NOT NULL,
  VERSION    TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  PREDEFINED NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  CONSTRAINT ZATRATY_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                              NEXT 1 M
                                                              MAXEXTENTS UNLIMITED),
  CONSTRAINT ZATRATY_ZATRATY_FK1 FOREIGN KEY (PARENT_ID)
  REFERENCES ZATRATY (ID)
)
LOGGING;

COMMENT ON TABLE ZATRATY IS 'СтатьиЗатрат';

--
-- Описание для таблицы WLS_SETTINGS
--
CREATE TABLE WLS_SETTINGS (
  ID       VARCHAR2(50 CHAR)  NOT NULL,
  PORT     VARCHAR2(5 CHAR)   DEFAULT 7001 NOT NULL,
  USERNAME VARCHAR2(200 CHAR) NOT NULL,
  PASSWORD VARCHAR2(200 CHAR) NOT NULL,
  HOST     VARCHAR2(500 CHAR) DEFAULT '127.0.0.1' NOT NULL,
  CONSTRAINT WLS_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE WLS_SETTINGS IS 'НастройкиWLS';

--
-- Описание для таблицы VOUCHER
--
CREATE TABLE VOUCHER (
  ID         VARCHAR2(50 CHAR) NOT NULL,
  VERSION    TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  EXPIRED_BY TIMESTAMP(6)      NOT NULL,
  CODE       RAW(64)           NOT NULL,
  CONSTRAINT VOUCHER_PK PRIMARY KEY (ID)
)
LOGGING;

COMMENT ON TABLE VOUCHER IS 'Ваучеры';

--
-- Описание для таблицы USERS_GROUPS
--
CREATE TABLE USERS_GROUPS (
  ID        VARCHAR2(50 CHAR),
  USER_ID   VARCHAR2(50 CHAR),
  GROUPS_ID VARCHAR2(50 CHAR),
  CHECK ("GROUPS_ID" IS NOT NULL) DISABLE,
  CHECK ("ID" IS NOT NULL) DISABLE,
  CHECK ("USER_ID" IS NOT NULL) DISABLE,
  CONSTRAINT USERS_GROUPS_PK PRIMARY KEY (ID) DISABLE
)
LOGGING;

CREATE UNIQUE INDEX USERS_GROUPS_PK ON USERS_GROUPS (ID)
LOGGING;

COMMENT ON TABLE USERS_GROUPS IS 'ГруппыПользователей';

--
-- Описание для таблицы RATING_SETTINGS
--
CREATE TABLE RATING_SETTINGS (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  SUM_DIVIDER NUMBER(10, 0)     DEFAULT 1 NOT NULL,
  SUM_BAL     NUMBER(10, 2)     NOT NULL,
  CNT_DIVIDER NUMBER(10, 0)     DEFAULT 1 NOT NULL,
  CNT_BAL     NUMBER(10, 2)     NOT NULL,
  CONSTRAINT RATING_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                      NEXT 1 M
                                                                      MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE RATING_SETTINGS IS 'НастройкиРейтинга';

--
-- Описание для таблицы QUARTZ_PROPERTY
--
CREATE TABLE QUARTZ_PROPERTY (
  ID               VARCHAR2(50 CHAR) NOT NULL,
  INSTANCE_NAME    VARCHAR2(60 CHAR),
  THREADPOOL_CLASS VARCHAR2(50 CHAR),
  THREAD_COUNT     VARCHAR2(60 CHAR),
  THREADS_CONTEXT  VARCHAR2(60 CHAR),
  JOBSTORE_CLASS   VARCHAR2(60 CHAR),
  DRIVER_DELEGATE  VARCHAR2(60 CHAR),
  TABLE_PREFIX     VARCHAR2(60 CHAR),
  DATA_SOURCE      VARCHAR2(60 CHAR),
  DRIVER           VARCHAR2(60 CHAR),
  URL              VARCHAR2(60 CHAR),
  USR              VARCHAR2(50 CHAR),
  PASSWORD         VARCHAR2(50 CHAR),
  MAX_CONNECTIONS  VARCHAR2(50 CHAR),
  CONSTRAINT QUARTZ_PROPERTY_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                      NEXT 1 M
                                                                      MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE QUARTZ_PROPERTY IS 'НастройкиQuartz_2.2.1';

--
-- Описание для таблицы PROG_SETTINGS
--
CREATE TABLE PROG_SETTINGS (
  ID                VARCHAR2(50 CHAR) NOT NULL,
  DATE_AFTER        DATE,
  DATE_AFTER_PROFIT DATE,
  CONSTRAINT PROG_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                    NEXT 1 M
                                                                    MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE PROG_SETTINGS IS 'НастройкиПрограммы';

--
-- Описание для таблицы IMPORTED_PRICE
--
CREATE TABLE IMPORTED_PRICE (
  ID          VARCHAR2(50 CHAR)   NOT NULL,
  DAT         DATE                DEFAULT sysdate NOT NULL,
  ARTIKUL     VARCHAR2(50 CHAR),
  GROUPS      VARCHAR2(50 CHAR),
  NOM_NAME    VARCHAR2(1000 CHAR) NOT NULL,
  ED_IZM      VARCHAR2(20 CHAR)   NOT NULL,
  PRICE_USL   NUMBER(10, 2)       NOT NULL,
  PRICE_GOODS NUMBER(10, 2)       NOT NULL,
  VERSION     TIMESTAMP(6)        DEFAULT systimestamp NOT NULL,
  CONSTRAINT IMPORTED_PRICE_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                     NEXT 1 M
                                                                     MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE IMPORTED_PRICE IS 'ИмпортированныеПрайсЛисты';

--
-- Описание для таблицы GROUPS
--
CREATE TABLE GROUPS (
  ID            VARCHAR2(50 CHAR) NOT NULL,
  FULLNAME      VARCHAR2(50 CHAR) NOT NULL,
  G_DESCRIPTION VARCHAR2(1000 CHAR),
  CONSTRAINT GROUPS_PK PRIMARY KEY (ID) USING INDEX (CREATE UNIQUE INDEX USERS_GROUP_PK ON GROUPS (ID) LOGGING),
  CONSTRAINT GROUPS_UK1 UNIQUE (FULLNAME) USING INDEX STORAGE (INITIAL 64 K
                                                               NEXT 1 M
                                                               MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE GROUPS IS 'РолиПользователей';

--
-- Описание для таблицы DIR_FILE_UPLOAD
--
CREATE TABLE DIR_FILE_UPLOAD (
  ID        VARCHAR2(50 CHAR)  NOT NULL,
  DIRECTORY VARCHAR2(100 CHAR) NOT NULL,
  CONSTRAINT DIR_FILE_UPLOAD_PK PRIMARY KEY (ID)
)
LOGGING;

COMMENT ON TABLE DIR_FILE_UPLOAD IS 'НастройкиВыгрузки';

--
-- Описание для таблицы ASTER_SETTINGS
--
CREATE TABLE ASTER_SETTINGS (
  ID       VARCHAR2(50 CHAR)  NOT NULL,
  SERVER   VARCHAR2(100 CHAR) NOT NULL,
  LOGIN_AM VARCHAR2(20 CHAR)  NOT NULL,
  PASS_AM  VARCHAR2(20 CHAR)  NOT NULL,
  CHANNEL  VARCHAR2(20 CHAR),
  CONTEXT  VARCHAR2(20 CHAR),
  PRIORITY VARCHAR2(20 CHAR),
  PORT     VARCHAR2(20 CHAR)  NOT NULL,
  CONSTRAINT ASTER_SETTINGS_PK PRIMARY KEY (ID)
)
LOGGING;

COMMENT ON TABLE ASTER_SETTINGS IS 'Настройки Asterisk';

--
-- Описание для таблицы QRTZ_SCHEDULER_STATE
--
CREATE TABLE QRTZ_SCHEDULER_STATE (
  SCHED_NAME        VARCHAR2(120 BYTE) NOT NULL,
  INSTANCE_NAME     VARCHAR2(200 BYTE) NOT NULL,
  LAST_CHECKIN_TIME NUMBER(13, 0)      NOT NULL,
  CHECKIN_INTERVAL  NUMBER(13, 0)      NOT NULL,
  CONSTRAINT QRTZ_SCHEDULER_STATE_PK PRIMARY KEY (SCHED_NAME, INSTANCE_NAME)
)
LOGGING;

COMMENT ON TABLE QRTZ_SCHEDULER_STATE IS 'Quartz_2.2.1';

--
-- Описание для таблицы QRTZ_PAUSED_TRIGGER_GRPS
--
CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (
  SCHED_NAME    VARCHAR2(120 BYTE) NOT NULL,
  TRIGGER_GROUP VARCHAR2(200 BYTE) NOT NULL,
  CONSTRAINT QRTZ_PAUSED_TRIG_GRPS_PK PRIMARY KEY (SCHED_NAME, TRIGGER_GROUP)
)
LOGGING;

COMMENT ON TABLE QRTZ_PAUSED_TRIGGER_GRPS IS 'Quartz_2.2.1';

--
-- Описание для таблицы QRTZ_LOCKS
--
CREATE TABLE QRTZ_LOCKS (
  SCHED_NAME VARCHAR2(120 BYTE) NOT NULL,
  LOCK_NAME  VARCHAR2(40 BYTE)  NOT NULL,
  CONSTRAINT QRTZ_LOCKS_PK PRIMARY KEY (SCHED_NAME, LOCK_NAME)
)
LOGGING;

COMMENT ON TABLE QRTZ_LOCKS IS 'Quartz_2.2.1';

--
-- Описание для таблицы QRTZ_FIRED_TRIGGERS
--
CREATE TABLE QRTZ_FIRED_TRIGGERS (
  SCHED_NAME        VARCHAR2(120 BYTE) NOT NULL,
  ENTRY_ID          VARCHAR2(95 BYTE)  NOT NULL,
  TRIGGER_NAME      VARCHAR2(200 BYTE) NOT NULL,
  TRIGGER_GROUP     VARCHAR2(200 BYTE) NOT NULL,
  INSTANCE_NAME     VARCHAR2(200 BYTE) NOT NULL,
  FIRED_TIME        NUMBER(13, 0)      NOT NULL,
  SCHED_TIME        NUMBER(13, 0)      NOT NULL,
  PRIORITY          NUMBER(13, 0)      NOT NULL,
  STATE             VARCHAR2(16 BYTE)  NOT NULL,
  JOB_NAME          VARCHAR2(200 BYTE),
  JOB_GROUP         VARCHAR2(200 BYTE),
  IS_NONCONCURRENT  VARCHAR2(1 BYTE),
  REQUESTS_RECOVERY VARCHAR2(1 BYTE),
  CONSTRAINT QRTZ_FIRED_TRIGGER_PK PRIMARY KEY (SCHED_NAME, ENTRY_ID)
)
LOGGING;

CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, INSTANCE_NAME, REQUESTS_RECOVERY)
LOGGING;

CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, JOB_NAME, JOB_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, JOB_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, TRIGGER_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, INSTANCE_NAME)
LOGGING;

COMMENT ON TABLE QRTZ_FIRED_TRIGGERS IS 'Quartz_2.2.1';

--
-- Описание для таблицы QRTZ_CALENDARS
--
CREATE TABLE QRTZ_CALENDARS (
  SCHED_NAME    VARCHAR2(120 BYTE) NOT NULL,
  CALENDAR_NAME VARCHAR2(200 BYTE) NOT NULL,
  CALENDAR      BLOB               NOT NULL,
  CONSTRAINT QRTZ_CALENDARS_PK PRIMARY KEY (SCHED_NAME, CALENDAR_NAME)
)
LOGGING;

COMMENT ON TABLE QRTZ_CALENDARS IS 'Quartz_2.2.1';

--
-- Описание для таблицы PS_TXN
--
CREATE TABLE PS_TXN (
  ID            NUMBER(20, 0),
  PARENTID      NUMBER(20, 0),
  COLLID        NUMBER(10, 0),
  CONTENT       BLOB,
  CREATION_DATE DATE DEFAULT sysdate,
  CONSTRAINT PS_TXN_PK PRIMARY KEY (COLLID, ID) USING INDEX (CREATE INDEX PS_TXN_IDX ON PS_TXN (COLLID, ID) REVERSE LOGGING)
)
LOGGING;

COMMENT ON TABLE PS_TXN IS 'Служебный';

--
-- Описание для таблицы CALENDAR
--
CREATE TABLE CALENDAR (
  ID          VARCHAR2(50 CHAR)  NOT NULL,
  PROVIDER    VARCHAR2(100 CHAR) NOT NULL,
  START_DATE  DATE               NOT NULL,
  END_DATE    DATE               NOT NULL,
  DESCRIPTION VARCHAR2(200 CHAR) NOT NULL,
  CONSTRAINT CALENDAR_PK PRIMARY KEY (ID)
)
LOGGING;

COMMENT ON TABLE CALENDAR IS 'Календарь';

--
-- Описание для таблицы BALLANS
--
CREATE TABLE BALLANS (
  ID             VARCHAR2(50 CHAR)   NOT NULL,
  CODE           VARCHAR2(6 CHAR)    NOT NULL,
  FULLNAME       VARCHAR2(3000 CHAR) NOT NULL,
  ACTIVE_START   NUMBER,
  ACTIVE_DEB     NUMBER,
  ACTIVE_KRED    NUMBER,
  ACTIVE_OBOROT  NUMBER,
  ACTIVE_END     NUMBER,
  PASSIVE_START  NUMBER,
  PASSIVE_DEB    NUMBER,
  PASSIVE_KRED   NUMBER,
  PASSIVE_OBOROT NUMBER,
  PASSIVE_END    NUMBER,
  DIVISION_ID    VARCHAR2(50 CHAR)   NOT NULL,
  F_DAT          DATE,
  L_DAT          DATE
)
LOGGING;

--
-- Описание для таблицы XML_T
--
CREATE TABLE XML_T (
  ID      VARCHAR2(50 CHAR) NOT NULL,
  ONE     XMLTYPE           NOT NULL,
  VERSION TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT XML_T_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                            NEXT 1 M
                                                            MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE XML_T IS 'Служебный';

--
-- Описание для таблицы KONTRAGENTS
--
CREATE TABLE KONTRAGENTS (
  ID          VARCHAR2(50 CHAR)  NOT NULL,
  IS_GROUP    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  PARENT_ID   VARCHAR2(50 CHAR),
  FULLNAME    VARCHAR2(150 CHAR) NOT NULL,
  DELETED     NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  INN         VARCHAR2(50 CHAR),
  OKPO        VARCHAR2(50 CHAR),
  KPP         VARCHAR2(50 CHAR),
  NAMEFULL    VARCHAR2(150 CHAR),
  UR_FIZ      NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  VERSION     TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  PREDEFINED  NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  IS_SUPPLIER NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  IS_BUYER    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  IS_MEASURER NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  USER_ID     VARCHAR2(50 CHAR),
  PHOTO       BLOB,
  CONSTRAINT KONTRAGENTS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                  NEXT 1 M
                                                                  MAXEXTENTS UNLIMITED),
  CONSTRAINT KONTRAGENTS_FK1 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID) ON DELETE SET NULL,
  CONSTRAINT KONTRAGENTS_KONTRAGENTS_FK1 FOREIGN KEY (PARENT_ID)
  REFERENCES KONTRAGENTS (ID)
)
LOGGING;

COMMENT ON TABLE KONTRAGENTS IS 'Контрагенты';

--
-- Описание для таблицы DIVISIONS
--
CREATE TABLE DIVISIONS (
  ID         VARCHAR2(50 CHAR)  NOT NULL,
  FULLNAME   VARCHAR2(150 CHAR) NOT NULL,
  DELETED    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  IS_GROUP   NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  PARENT_ID  VARCHAR2(50 CHAR),
  VERSION    TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  PREDEFINED NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  MAIN_USER  VARCHAR2(50 CHAR),
  PREFIX     VARCHAR2(20 CHAR),
  CONSTRAINT DIVISIONS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                NEXT 1 M
                                                                MAXEXTENTS UNLIMITED),
  CONSTRAINT DIVISIONS_DIVISIONS_FK1 FOREIGN KEY (PARENT_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT DIVISIONS_FK1 FOREIGN KEY (MAIN_USER)
  REFERENCES USERS (ID) ON DELETE SET NULL
)
LOGGING;

CREATE INDEX DIVISIONS_INDEX1 ON DIVISIONS (IS_GROUP, DELETED)
LOGGING;

COMMENT ON TABLE DIVISIONS IS 'Подразделения';

--
-- Описание для таблицы PLAN_ACC
--
CREATE TABLE PLAN_ACC (
  ID         VARCHAR2(50 CHAR)   NOT NULL,
  ACC_TYPE   VARCHAR2(50 CHAR)   NOT NULL,
  PARENT_ID  VARCHAR2(50 CHAR),
  FULLNAME   VARCHAR2(3000 CHAR) NOT NULL,
  ZABALANSOV NUMBER(1, 0)        DEFAULT 0 NOT NULL,
  VALUTN     NUMBER(1, 0)        DEFAULT 0 NOT NULL,
  KOLISHESTV NUMBER(1, 0)        DEFAULT 0 NOT NULL,
  DELETED    NUMBER(1, 0)        DEFAULT 0 NOT NULL,
  VERSION    TIMESTAMP(6)        DEFAULT systimestamp NOT NULL,
  CODE       VARCHAR2(6 CHAR)    NOT NULL,
  CONSTRAINT PLAN_ACC_CHK1 CHECK (ZABALANSOV IN (1, 0)),
  CONSTRAINT PLAN_ACC_CHK2 CHECK (VALUTN IN (1, 0)),
  CONSTRAINT PLAN_ACC_CHK3 CHECK (DELETED IN (1, 0)),
  CONSTRAINT PLAN_ACC_CHK4 CHECK (KOLISHESTV IN (1, 0)),
  CONSTRAINT PLAN_ACC_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                               NEXT 1 M
                                                               MAXEXTENTS UNLIMITED),
  CONSTRAINT PLAN_ACC_FK1 FOREIGN KEY (PARENT_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT PLAN_ACC_FK2 FOREIGN KEY (ACC_TYPE)
  REFERENCES ENUM_ACCOUNT_TYPE (ID),
  CONSTRAINT PLAN_ACC_UK1 UNIQUE (FULLNAME, CODE) USING INDEX STORAGE (INITIAL 64 K
                                                                       NEXT 1 M
                                                                       MAXEXTENTS UNLIMITED)
)
LOGGING;

CREATE INDEX PLAN_ACC_INDEX1 ON PLAN_ACC (ACC_TYPE)
LOGGING;

CREATE INDEX PLAN_ACC_INDEX2 ON PLAN_ACC (CODE)
LOGGING;

COMMENT ON TABLE PLAN_ACC IS 'УправленческийПланСчетов';

--
-- Описание для таблицы REG_RATES
--
CREATE TABLE REG_RATES (
  CURR_ID  VARCHAR2(50 CHAR) NOT NULL,
  PERIOD   DATE              DEFAULT TO_DATE('01-01-1980 00:00:00', 'DD-MM-YYYY HH24:MI:SS') NOT NULL,
  ID       VARCHAR2(50 CHAR) NOT NULL,
  KURS     NUMBER(10, 6)     DEFAULT 1 NOT NULL,
  KRATNOST NUMBER(10, 0)     DEFAULT 1 NOT NULL,
  VERSION  TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT REG_RATES_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                NEXT 1 M
                                                                MAXEXTENTS UNLIMITED),
  CONSTRAINT REG_RATES_FK1 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE REG_RATES IS 'КурсыВалют';

--
-- Описание для таблицы EX_RATES_SETTINGS
--
CREATE TABLE EX_RATES_SETTINGS (
  ID      VARCHAR2(50 CHAR) NOT NULL,
  CURR_ID VARCHAR2(50 CHAR) NOT NULL,
  VERSION TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT EX_RATES_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                        NEXT 1 M
                                                                        MAXEXTENTS UNLIMITED),
  CONSTRAINT EX_RATES_SETTINGS_CURRENC_FK1 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT EX_RATES_SETTINGS_UK1 UNIQUE (CURR_ID) USING INDEX STORAGE (INITIAL 64 K
                                                                         NEXT 1 M
                                                                         MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE EX_RATES_SETTINGS IS 'НастройкиЗагрузкиКурсовВалют';

--
-- Описание для таблицы PLAN_TYPE_SUBCONTO
--
CREATE TABLE PLAN_TYPE_SUBCONTO (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  TYPE_OF_OBJ VARCHAR2(50 BYTE) NOT NULL,
  VERSION     TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  FULLNAME    VARCHAR2(100 CHAR),
  CONSTRAINT PLAN_TYPE_SUBCONTO_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                         NEXT 1 M
                                                                         MAXEXTENTS UNLIMITED),
  CONSTRAINT PLAN_TYPE_SUBCONTO_TYPE_D_FK1 FOREIGN KEY (TYPE_OF_OBJ)
  REFERENCES TYPE_DEF (ID),
  CONSTRAINT PLAN_TYPE_SUBCONTO_UK1 UNIQUE (TYPE_OF_OBJ) USING INDEX STORAGE (INITIAL 64 K
                                                                              NEXT 1 M
                                                                              MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE PLAN_TYPE_SUBCONTO IS 'ТипыСубконто';

--
-- Описание для таблицы NUMERATOR
--
CREATE TABLE NUMERATOR (
  ID         VARCHAR2(50 CHAR) NOT NULL,
  TYPEDEF_ID VARCHAR2(50 CHAR) NOT NULL,
  PREFIX     VARCHAR2(20 CHAR) NOT NULL,
  VERSION    TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT NUMERATOR_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                NEXT 1 M
                                                                MAXEXTENTS UNLIMITED),
  CONSTRAINT NUMERATOR_TYPE_DEF_FK1 FOREIGN KEY (TYPEDEF_ID)
  REFERENCES TYPE_DEF (ID)
)
LOGGING;

COMMENT ON TABLE NUMERATOR IS 'Нумераторы';

--
-- Описание для таблицы QRTZ_TRIGGERS
--
CREATE TABLE QRTZ_TRIGGERS (
  SCHED_NAME     VARCHAR2(120 BYTE) NOT NULL,
  TRIGGER_NAME   VARCHAR2(200 BYTE) NOT NULL,
  TRIGGER_GROUP  VARCHAR2(200 BYTE) NOT NULL,
  JOB_NAME       VARCHAR2(200 BYTE) NOT NULL,
  JOB_GROUP      VARCHAR2(200 BYTE) NOT NULL,
  DESCRIPTION    VARCHAR2(250 BYTE),
  NEXT_FIRE_TIME NUMBER(13, 0),
  PREV_FIRE_TIME NUMBER(13, 0),
  PRIORITY       NUMBER(13, 0),
  TRIGGER_STATE  VARCHAR2(16 BYTE)  NOT NULL,
  TRIGGER_TYPE   VARCHAR2(8 BYTE)   NOT NULL,
  START_TIME     NUMBER(13, 0)      NOT NULL,
  END_TIME       NUMBER(13, 0),
  CALENDAR_NAME  VARCHAR2(200 BYTE),
  MISFIRE_INSTR  NUMBER(2, 0),
  JOB_DATA       BLOB,
  CONSTRAINT QRTZ_TRIGGERS_PK PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP) USING INDEX (CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP, TRIGGER_STATE) LOGGING),
  CONSTRAINT QRTZ_TRIGGER_TO_JOBS_FK FOREIGN KEY (SCHED_NAME,
  JOB_NAME,
  JOB_GROUP)
  REFERENCES QRTZ_JOB_DETAILS (SCHED_NAME,
  JOB_NAME,
  JOB_GROUP)
)
LOGGING;

CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS (SCHED_NAME, CALENDAR_NAME)
LOGGING;

CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS (SCHED_NAME, JOB_NAME, JOB_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS (SCHED_NAME, JOB_GROUP)
LOGGING;

CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS (SCHED_NAME, NEXT_FIRE_TIME)
LOGGING;

CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS (SCHED_NAME, MISFIRE_INSTR, NEXT_FIRE_TIME)
LOGGING;

CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_STATE, NEXT_FIRE_TIME)
LOGGING;

CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS (SCHED_NAME, MISFIRE_INSTR, NEXT_FIRE_TIME, TRIGGER_STATE)
LOGGING;

CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS (SCHED_NAME, MISFIRE_INSTR, NEXT_FIRE_TIME, TRIGGER_GROUP, TRIGGER_STATE)
LOGGING;

CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_GROUP, TRIGGER_STATE)
LOGGING;

CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_STATE)
LOGGING;

CREATE UNIQUE INDEX QRTZ_TRIGGERS_PK ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
LOGGING;

COMMENT ON TABLE QRTZ_TRIGGERS IS 'Quartz_2.2.1';

--
-- Описание для таблицы PAY_SETTINGS
--
CREATE TABLE PAY_SETTINGS (
  ID          VARCHAR2(50 CHAR)  NOT NULL,
  NAME        VARCHAR2(50 CHAR)  NOT NULL,
  FULLNAME    VARCHAR2(100 CHAR) NOT NULL,
  STAVKA      NUMBER             NOT NULL,
  DESCRIPTION VARCHAR2(500 BYTE),
  VERSION     TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  BASE_ID     VARCHAR2(50 CHAR)  NOT NULL,
  SUMMA       NUMBER             DEFAULT 0 NOT NULL,
  IN_PROFIT   NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  CONSTRAINT PAY_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED),
  CONSTRAINT PAY_SETTINGS_FK1 FOREIGN KEY (BASE_ID)
  REFERENCES BASE_OF_CALC (ID)
)
LOGGING;

COMMENT ON TABLE PAY_SETTINGS IS 'ВидыНачислений';

--
-- Описание для таблицы REG_PRICES
--
CREATE TABLE REG_PRICES (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  NOM_ID      VARCHAR2(50 CHAR) NOT NULL,
  PERIOD      DATE              NOT NULL,
  ED_IZM      VARCHAR2(50 CHAR),
  PRICE_USL   NUMBER(10, 2)     NOT NULL,
  PRICE_GOODS NUMBER(10, 2),
  CONSTRAINT REG_PRICES_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                 NEXT 1 M
                                                                 MAXEXTENTS UNLIMITED),
  CONSTRAINT REG_PRICES_FK1 FOREIGN KEY (NOM_ID)
  REFERENCES NOMENKLATURA (ID) ON DELETE CASCADE,
  CONSTRAINT REG_PRICES_FK2 FOREIGN KEY (ED_IZM)
  REFERENCES MEASURE_UNIT (ID) ON DELETE SET NULL
)
LOGGING;

COMMENT ON TABLE REG_PRICES IS 'ПрайсЛисты';

--
-- Описание для таблицы GROUPMEMBERS
--
CREATE TABLE GROUPMEMBERS (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  G_NAME   VARCHAR2(50 CHAR) NOT NULL,
  G_MEMBER VARCHAR2(30 CHAR) NOT NULL,
  CONSTRAINT GROUPMEMBERS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED),
  CONSTRAINT GROUPMEMBERS_FK2 FOREIGN KEY (G_NAME)
  REFERENCES GROUPS (FULLNAME) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE GROUPMEMBERS IS 'ЧленыРолей';

--
-- Описание для таблицы CONTACT_DETAILS
--
CREATE TABLE CONTACT_DETAILS (
  ID         VARCHAR2(50 CHAR) NOT NULL,
  VERSION    TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  KONTRAG_ID VARCHAR2(50 CHAR) NOT NULL,
  ADRESS     VARCHAR2(1000 CHAR),
  PHONE      VARCHAR2(15 CHAR),
  EMAIL      VARCHAR2(100 CHAR),
  CONSTRAINT CONTACT_DETAILS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                      NEXT 1 M
                                                                      MAXEXTENTS UNLIMITED),
  CONSTRAINT CONTACT_DETAILS_FK1 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE CONTACT_DETAILS IS 'ТЧ_Контрагенты';

--
-- Описание для таблицы CDR
--
CREATE TABLE CDR (
  ID               VARCHAR2(50 CHAR) NOT NULL,
  KONTRAGENT_ID    VARCHAR2(50 CHAR),
  USER_ID          VARCHAR2(50 CHAR) NOT NULL,
  CALL_START_TIME  DATE,
  CALL_ANSWER_TIME DATE,
  CALL_END_TIME    DATE,
  ALL_CALL_TIME    NUMBER(10, 0),
  CALL_STATUS      VARCHAR2(20 BYTE),
  PHONE            VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT CDR_PK PRIMARY KEY (ID),
  CONSTRAINT CDR_FK1 FOREIGN KEY (KONTRAGENT_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE CDR IS 'AsteriskCDR';

--
-- Описание для таблицы CALL_LISTS
--
CREATE TABLE CALL_LISTS (
  ID             VARCHAR2(50 CHAR) NOT NULL,
  USERS_ID       VARCHAR2(50 CHAR) NOT NULL,
  KONTRAGENTS_ID VARCHAR2(50 CHAR) NOT NULL,
  LIST_NAME      VARCHAR2(50 BYTE) NOT NULL,
  VERSION        TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT CALL_LISTS_PK PRIMARY KEY (ID),
  CONSTRAINT CALL_LISTS_FK1 FOREIGN KEY (KONTRAGENTS_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE CALL_LISTS IS 'Листы обзвона';

--
-- Описание для таблицы DIVISION_SOTR
--
CREATE TABLE DIVISION_SOTR (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  DIV_ID      VARCHAR2(50 CHAR) NOT NULL,
  USER_ID     VARCHAR2(50 CHAR) NOT NULL,
  DESCRIPTION VARCHAR2(1000 CHAR),
  CONSTRAINT DIVISION_SOTR_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                    NEXT 1 M
                                                                    MAXEXTENTS UNLIMITED),
  CONSTRAINT DIVISION_SOTR_FK1 FOREIGN KEY (DIV_ID)
  REFERENCES DIVISIONS (ID) ON DELETE SET NULL,
  CONSTRAINT DIVISION_SOTR_FK2 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID) ON DELETE SET NULL
)
LOGGING;

COMMENT ON TABLE DIVISION_SOTR IS 'ТЧ_Подразделения - Сотрудники';

--
-- Описание для таблицы START_OST
--
CREATE TABLE START_OST (
  ID            VARCHAR2(50 CHAR) NOT NULL,
  DAT           DATE              DEFAULT sysdate NOT NULL,
  NUM           VARCHAR2(50 CHAR) NOT NULL,
  DELETED       NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  POSTED        NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  DIVISION_ID   VARCHAR2(50 CHAR) NOT NULL,
  USER_ID       VARCHAR2(50 CHAR) NOT NULL,
  COMMENTS      VARCHAR2(255 CHAR),
  VERSION       TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CURR_ID       VARCHAR2(50 CHAR) NOT NULL,
  ACTIVITIES_ID VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT START_OST_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                NEXT 1 M
                                                                MAXEXTENTS UNLIMITED),
  CONSTRAINT START_OST_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT START_OST_FK2 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID),
  CONSTRAINT START_OST_FK3 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT START_OST_FK4 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID)
)
LOGGING;

CREATE INDEX START_OST_INDEX1 ON START_OST (DAT)
LOGGING;

COMMENT ON TABLE START_OST IS 'НачальныеОстатки';

--
-- Описание для таблицы PROFIT_DISTRIB
--
CREATE TABLE PROFIT_DISTRIB (
  ID            VARCHAR2(50 CHAR) NOT NULL,
  DAT           DATE              DEFAULT sysdate NOT NULL,
  NUM           VARCHAR2(50 CHAR) NOT NULL,
  DELETED       NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  POSTED        NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  DIVISION_ID   VARCHAR2(50 CHAR) NOT NULL,
  USER_ID       VARCHAR2(50 CHAR) NOT NULL,
  COMMENTS      VARCHAR2(255 CHAR),
  VERSION       TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CURR_ID       VARCHAR2(50 CHAR) NOT NULL,
  ACTIVITIES_ID VARCHAR2(50 CHAR) NOT NULL,
  SUMM          NUMBER(10, 3)     NOT NULL,
  CONSTRAINT PROFIT_DISTRIB_PK PRIMARY KEY (ID),
  CONSTRAINT PROFIT_DISTRIB_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT PROFIT_DISTRIB_FK2 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID),
  CONSTRAINT PROFIT_DISTRIB_FK3 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT PROFIT_DISTRIB_FK4 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID)
)
LOGGING;

CREATE INDEX PROFIT_DISTRIB_INDEX1 ON PROFIT_DISTRIB (DAT)
LOGGING;

COMMENT ON TABLE PROFIT_DISTRIB IS 'РаспределениеПрибыли';

--
-- Описание для таблицы KASSA
--
CREATE TABLE KASSA (
  ID          VARCHAR2(50 CHAR)  NOT NULL,
  FULLNAME    VARCHAR2(100 CHAR) NOT NULL,
  IS_GROUP    NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  PARENT_ID   VARCHAR2(50 CHAR),
  CURR_ID     VARCHAR2(50 CHAR)  NOT NULL,
  DIVISION_ID VARCHAR2(50 CHAR),
  DELETED     NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  VERSION     TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  PREDEFINED  NUMBER(1, 0)       DEFAULT 0 NOT NULL,
  FIRMA_ID    VARCHAR2(50 CHAR),
  CONSTRAINT KASSA_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                            NEXT 1 M
                                                            MAXEXTENTS UNLIMITED),
  CONSTRAINT KASSA_CURRENCY_FK1 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT KASSA_DIVISIONS_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID) ON DELETE CASCADE,
  CONSTRAINT KASSA_KASSA_FK1 FOREIGN KEY (PARENT_ID)
  REFERENCES KASSA (ID)
)
LOGGING;

COMMENT ON TABLE KASSA IS 'Кассы';

--
-- Описание для таблицы PLAN_ACC_SUBCONTO
--
CREATE TABLE PLAN_ACC_SUBCONTO (
  ID             VARCHAR2(50 CHAR) NOT NULL,
  PLAN_ACC_ID    VARCHAR2(50 CHAR) NOT NULL,
  PLAN_TYPE_SUBC VARCHAR2(50 CHAR) NOT NULL,
  OBOROT_ONLY    NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  SUMMOVOY       NUMBER(1, 0)      DEFAULT 1 NOT NULL,
  VERSION        TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT PLAN_ACC_SUBCONTO_CHK1 CHECK (OBOROT_ONLY IN (1, 0)),
  CONSTRAINT PLAN_ACC_SUBCONTO_CHK2 CHECK (SUMMOVOY IN (1, 0)),
  CONSTRAINT PLAN_ACC_SUBCONTO_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                        NEXT 1 M
                                                                        MAXEXTENTS UNLIMITED),
  CONSTRAINT PLAN_ACC_SUBCONTO_FK1 FOREIGN KEY (PLAN_ACC_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT PLAN_ACC_SUBCONTO_FK2 FOREIGN KEY (PLAN_TYPE_SUBC)
  REFERENCES PLAN_TYPE_SUBCONTO (ID)
)
LOGGING;

COMMENT ON TABLE PLAN_ACC_SUBCONTO IS 'СубконтоСчетов';

--
-- Описание для таблицы MOVES
--
CREATE TABLE MOVES (
  ID               VARCHAR2(50 CHAR) NOT NULL,
  PERIOD           TIMESTAMP(6)      NOT NULL,
  REGISTRATOR_TYPE VARCHAR2(50 CHAR) NOT NULL,
  REGISTRATOR_ID   VARCHAR2(50 CHAR) NOT NULL,
  PLAN_ACC_DEB_ID  VARCHAR2(50 CHAR) NOT NULL,
  SUBCONTO1_DEB    VARCHAR2(50 CHAR),
  SUBCONTO2_DEB    VARCHAR2(50 CHAR),
  SUBCONTO3_DEB    VARCHAR2(50 CHAR),
  QUANTITY_DEB     NUMBER(10, 4),
  CURR_DEB         VARCHAR2(50 CHAR),
  SUMM_VAL_DEB     NUMBER(10, 2),
  PLAN_ACC_KRED_ID VARCHAR2(50 CHAR) NOT NULL,
  SUBCONTO1_KRED   VARCHAR2(50 CHAR),
  SUBCONTO2_KRED   VARCHAR2(50 CHAR),
  SUBCONTO3_KRED   VARCHAR2(50 CHAR),
  QUANTITY_KRED    NUMBER(10, 4),
  CURR_KRED        VARCHAR2(50 CHAR),
  SUMM_VAL_KREDIT  NUMBER(10, 2),
  VERSION          TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  SUMM_UPR_DEB     NUMBER(10, 2)     NOT NULL,
  SUMM_UPR_KRED    NUMBER(10, 2)     NOT NULL,
  ACTIVITIES_ID    VARCHAR2(50 CHAR) NOT NULL,
  DESCRIPTION      VARCHAR2(1000 CHAR),
  DIVISION_ID      VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT MOVES_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                            NEXT 1 M
                                                            MAXEXTENTS UNLIMITED),
  CONSTRAINT MOVES_CURRENCY_FK1 FOREIGN KEY (CURR_DEB)
  REFERENCES CURRENCY (ID),
  CONSTRAINT MOVES_CURRENCY_FK2 FOREIGN KEY (CURR_KRED)
  REFERENCES CURRENCY (ID),
  CONSTRAINT MOVES_FK1 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID),
  CONSTRAINT MOVES_FK2 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT MOVES_PLAN_ACC_FK1 FOREIGN KEY (PLAN_ACC_DEB_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT MOVES_PLAN_ACC_FK2 FOREIGN KEY (PLAN_ACC_KRED_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT MOVES_TYPE_DEF_FK1 FOREIGN KEY (REGISTRATOR_TYPE)
  REFERENCES TYPE_DEF (ID)
)
LOGGING;

CREATE INDEX MOVES_INDEX1 ON MOVES (PLAN_ACC_DEB_ID)
LOGGING;

CREATE INDEX MOVES_INDEX10 ON MOVES (CURR_DEB)
LOGGING;

CREATE INDEX MOVES_INDEX11 ON MOVES (CURR_KRED)
LOGGING;

CREATE INDEX MOVES_INDEX12 ON MOVES (PERIOD)
LOGGING;

CREATE INDEX MOVES_INDEX13 ON MOVES (PLAN_ACC_DEB_ID, DIVISION_ID)
LOGGING;

CREATE INDEX MOVES_INDEX14 ON MOVES (PLAN_ACC_KRED_ID, DIVISION_ID)
LOGGING;

CREATE INDEX MOVES_INDEX15 ON MOVES (REGISTRATOR_ID)
LOGGING;

CREATE INDEX MOVES_INDEX16 ON MOVES (REGISTRATOR_TYPE)
LOGGING;

CREATE INDEX MOVES_INDEX2 ON MOVES (PLAN_ACC_KRED_ID)
LOGGING;

CREATE INDEX MOVES_INDEX3 ON MOVES (SUBCONTO1_DEB)
LOGGING;

CREATE INDEX MOVES_INDEX4 ON MOVES (SUBCONTO2_DEB)
LOGGING;

CREATE INDEX MOVES_INDEX5 ON MOVES (SUBCONTO3_DEB)
LOGGING;

CREATE INDEX MOVES_INDEX6 ON MOVES (SUBCONTO1_KRED)
LOGGING;

CREATE INDEX MOVES_INDEX7 ON MOVES (SUBCONTO2_KRED)
LOGGING;

CREATE INDEX MOVES_INDEX8 ON MOVES (SUBCONTO3_KRED)
LOGGING;

CREATE INDEX MOVES_INDEX9 ON MOVES (DIVISION_ID)
LOGGING;

COMMENT ON TABLE MOVES IS 'Проводки';

--
-- Описание для таблицы ENTRY_SETTINGS
--
CREATE TABLE ENTRY_SETTINGS (
  ID               VARCHAR2(50 CHAR) NOT NULL,
  TYPEDEF_ID       VARCHAR2(50 CHAR) NOT NULL,
  PLAN_ACC_DEB_ID  VARCHAR2(50 CHAR) NOT NULL,
  PLAN_ACC_KRED_ID VARCHAR2(50 CHAR) NOT NULL,
  VERSION          TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CHAIN            NUMBER(10, 0)     NOT NULL,
  DESCRIPTION      VARCHAR2(1000 CHAR),
  CONSTRAINT ENTRY_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                     NEXT 1 M
                                                                     MAXEXTENTS UNLIMITED),
  CONSTRAINT ENTRY_SETTINGS_PLAN_ACC_DEB FOREIGN KEY (PLAN_ACC_DEB_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT ENTRY_SETTINGS_PLAN_ACC_KRED FOREIGN KEY (PLAN_ACC_KRED_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT ENTRY_SETTINGS_TYPE_DEF_FK1 FOREIGN KEY (TYPEDEF_ID)
  REFERENCES TYPE_DEF (ID)
)
LOGGING;

COMMENT ON TABLE ENTRY_SETTINGS IS 'НастройкиПроводок';

--
-- Описание для таблицы QRTZ_SIMPROP_TRIGGERS
--
CREATE TABLE QRTZ_SIMPROP_TRIGGERS (
  SCHED_NAME    VARCHAR2(120 BYTE) NOT NULL,
  TRIGGER_NAME  VARCHAR2(200 BYTE) NOT NULL,
  TRIGGER_GROUP VARCHAR2(200 BYTE) NOT NULL,
  STR_PROP_1    VARCHAR2(512 BYTE),
  STR_PROP_2    VARCHAR2(512 BYTE),
  STR_PROP_3    VARCHAR2(512 BYTE),
  INT_PROP_1    NUMBER(10, 0),
  INT_PROP_2    NUMBER(10, 0),
  LONG_PROP_1   NUMBER(13, 0),
  LONG_PROP_2   NUMBER(13, 0),
  DEC_PROP_1    NUMBER(13, 4),
  DEC_PROP_2    NUMBER(13, 4),
  BOOL_PROP_1   VARCHAR2(1 BYTE),
  BOOL_PROP_2   VARCHAR2(1 BYTE),
  CONSTRAINT QRTZ_SIMPROP_TRIG_PK PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  CONSTRAINT QRTZ_SIMPROP_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
)
LOGGING;

COMMENT ON TABLE QRTZ_SIMPROP_TRIGGERS IS 'Quartz_2.2.1';

--
-- Описание для таблицы QRTZ_SIMPLE_TRIGGERS
--
CREATE TABLE QRTZ_SIMPLE_TRIGGERS (
  SCHED_NAME      VARCHAR2(120 BYTE) NOT NULL,
  TRIGGER_NAME    VARCHAR2(200 BYTE) NOT NULL,
  TRIGGER_GROUP   VARCHAR2(200 BYTE) NOT NULL,
  REPEAT_COUNT    NUMBER(7, 0)       NOT NULL,
  REPEAT_INTERVAL NUMBER(12, 0)      NOT NULL,
  TIMES_TRIGGERED NUMBER(10, 0)      NOT NULL,
  CONSTRAINT QRTZ_SIMPLE_TRIG_PK PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  CONSTRAINT QRTZ_SIMPLE_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
)
LOGGING;

COMMENT ON TABLE QRTZ_SIMPLE_TRIGGERS IS 'Quartz_2.2.1';

--
-- Описание для таблицы QRTZ_CRON_TRIGGERS
--
CREATE TABLE QRTZ_CRON_TRIGGERS (
  SCHED_NAME      VARCHAR2(120 BYTE) NOT NULL,
  TRIGGER_NAME    VARCHAR2(200 BYTE) NOT NULL,
  TRIGGER_GROUP   VARCHAR2(200 BYTE) NOT NULL,
  CRON_EXPRESSION VARCHAR2(120 BYTE) NOT NULL,
  TIME_ZONE_ID    VARCHAR2(80 BYTE),
  CONSTRAINT QRTZ_CRON_TRIG_PK PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  CONSTRAINT QRTZ_CRON_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
)
LOGGING;

COMMENT ON TABLE QRTZ_CRON_TRIGGERS IS 'Quartz_2.2.1';

--
-- Описание для таблицы QRTZ_BLOB_TRIGGERS
--
CREATE TABLE QRTZ_BLOB_TRIGGERS (
  SCHED_NAME    VARCHAR2(120 BYTE) NOT NULL,
  TRIGGER_NAME  VARCHAR2(200 BYTE) NOT NULL,
  TRIGGER_GROUP VARCHAR2(200 BYTE) NOT NULL,
  BLOB_DATA     BLOB,
  CONSTRAINT QRTZ_BLOB_TRIG_PK PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  CONSTRAINT QRTZ_BLOB_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME,
  TRIGGER_NAME,
  TRIGGER_GROUP)
)
LOGGING;

COMMENT ON TABLE QRTZ_BLOB_TRIGGERS IS 'Quartz_2.2.1';

--
-- Описание для таблицы INSIDE_SETTINGS
--
CREATE TABLE INSIDE_SETTINGS (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  PAY_ID      VARCHAR2(50 CHAR) NOT NULL,
  DESCRIPTION VARCHAR2(2000 CHAR),
  CONSTRAINT INSIDE_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                      NEXT 1 M
                                                                      MAXEXTENTS UNLIMITED),
  CONSTRAINT INSIDE_SETTINGS_FK1 FOREIGN KEY (PAY_ID)
  REFERENCES PAY_SETTINGS (ID) ON DELETE CASCADE
)
LOGGING;

--
-- Описание для таблицы NACHISL_SETTINGS
--
CREATE TABLE NACHISL_SETTINGS (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  USER_ID     VARCHAR2(50 CHAR) NOT NULL,
  PAY_ID      VARCHAR2(50 CHAR) NOT NULL,
  VERSION     TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  BASE_ID     VARCHAR2(50 CHAR) NOT NULL,
  DIVISION_ID VARCHAR2(50 CHAR),
  SUMMA       NUMBER,
  CONSTRAINT NACHISL_SETTINGS_PK PRIMARY KEY (ID),
  CONSTRAINT NACHISL_SETTINGS_FK1 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID) ON DELETE CASCADE,
  CONSTRAINT NACHISL_SETTINGS_FK2 FOREIGN KEY (PAY_ID)
  REFERENCES PAY_SETTINGS (ID) ON DELETE CASCADE,
  CONSTRAINT NACHISL_SETTINGS_FK3 FOREIGN KEY (BASE_ID)
  REFERENCES BASE_OF_NACHISL (ID) ON DELETE CASCADE,
  CONSTRAINT NACHISL_SETTINGS_FK4 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID)
)
LOGGING;

COMMENT ON TABLE NACHISL_SETTINGS IS 'НастройкиНачисленийПользователей';

--
-- Описание для таблицы KONTRAG_SETTINGS
--
CREATE TABLE KONTRAG_SETTINGS (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  KONTRAG_ID  VARCHAR2(50 CHAR) NOT NULL,
  PAY_ID      VARCHAR2(50 CHAR) NOT NULL,
  VERSION     TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  BASE_ID     VARCHAR2(50 CHAR) NOT NULL,
  DIVISION_ID VARCHAR2(50 CHAR),
  SUMMA       NUMBER,
  CONSTRAINT KONTRAG_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                       NEXT 1 M
                                                                       MAXEXTENTS UNLIMITED),
  CONSTRAINT KONTRAG_SETTINGS_FK1 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE CASCADE,
  CONSTRAINT KONTRAG_SETTINGS_FK2 FOREIGN KEY (PAY_ID)
  REFERENCES PAY_SETTINGS (ID),
  CONSTRAINT KONTRAG_SETTINGS_FK3 FOREIGN KEY (BASE_ID)
  REFERENCES BASE_OF_NACHISL (ID)
)
LOGGING;

COMMENT ON TABLE KONTRAG_SETTINGS IS 'ТЧ_Контрагенты - НастройкиНачислений';

--
-- Описание для таблицы NOTIFICATION
--
CREATE TABLE NOTIFICATION (
  ID          VARCHAR2(50 CHAR)  NOT NULL,
  VERSION     TIMESTAMP(6)       DEFAULT systimestamp NOT NULL,
  DAT         DATE               NOT NULL,
  DESCRIPTION VARCHAR2(200 CHAR) NOT NULL,
  USER_ID     VARCHAR2(50 CHAR)  NOT NULL,
  CONTACT     VARCHAR2(50 BYTE),
  SERVER      NUMBER(1, 0),
  CLIENT      NUMBER(1, 0),
  TRG_NAME    VARCHAR2(50 CHAR),
  USER_LOGIN  VARCHAR2(50 CHAR),
  OBJECT_ID   VARCHAR2(50 CHAR),
  START_DATE  DATE               NOT NULL,
  END_DATE    DATE               NOT NULL,
  CONSTRAINT NOTIFICATION_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED),
  CONSTRAINT NOTIFICATION_FK1 FOREIGN KEY (CONTACT)
  REFERENCES CONTACT_DETAILS (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE NOTIFICATION IS 'Уведомления';

--
-- Описание для таблицы START_OST_TP
--
CREATE TABLE START_OST_TP (
  ID               VARCHAR2(50 CHAR) NOT NULL,
  PLAN_ACC_DEB_ID  VARCHAR2(50 CHAR) NOT NULL,
  SUBCONTO1_DEB    VARCHAR2(50 CHAR),
  SUBCONTO2_DEB    VARCHAR2(50 CHAR),
  PLAN_ACC_KRED_ID VARCHAR2(50 CHAR) NOT NULL,
  SUBCONTO1_KRED   VARCHAR2(50 CHAR),
  SUBCONTO2_KRED   VARCHAR2(50 CHAR),
  SUMM             NUMBER(10, 2)     NOT NULL,
  DESCRIPTION      VARCHAR2(1000 CHAR),
  START_OST_ID     VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT START_OST_TP_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                   NEXT 1 M
                                                                   MAXEXTENTS UNLIMITED),
  CONSTRAINT START_OST_TP_FK1 FOREIGN KEY (PLAN_ACC_DEB_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT START_OST_TP_FK2 FOREIGN KEY (PLAN_ACC_KRED_ID)
  REFERENCES PLAN_ACC (ID),
  CONSTRAINT START_OST_TP_FK3 FOREIGN KEY (START_OST_ID)
  REFERENCES START_OST (ID) ON DELETE CASCADE
)
LOGGING;

CREATE INDEX START_OST_TP_INDEX1 ON START_OST_TP (START_OST_ID)
LOGGING;

COMMENT ON TABLE START_OST_TP IS 'ТЧ_НачальныеОстатки';

--
-- Описание для таблицы OTHER_ZATRATY
--
CREATE TABLE OTHER_ZATRATY (
  ID            VARCHAR2(50 CHAR) NOT NULL,
  DAT           DATE              DEFAULT sysdate NOT NULL,
  NUM           VARCHAR2(50 CHAR) NOT NULL,
  DELETED       NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  POSTED        NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  DIVISION_ID   VARCHAR2(50 CHAR) NOT NULL,
  USER_ID       VARCHAR2(50 CHAR) NOT NULL,
  COMMENTS      VARCHAR2(255 CHAR),
  VERSION       TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CURR_ID       VARCHAR2(50 CHAR) NOT NULL,
  KASSA_ID      VARCHAR2(50 CHAR) NOT NULL,
  ACTIVITIES_ID VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT OTHER_ZATRATY_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                    NEXT 1 M
                                                                    MAXEXTENTS UNLIMITED),
  CONSTRAINT OTHER_ZATRATY_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT OTHER_ZATRATY_FK2 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID),
  CONSTRAINT OTHER_ZATRATY_FK3 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT OTHER_ZATRATY_FK4 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID),
  CONSTRAINT OTHER_ZATRATY_FK5 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID)
)
LOGGING;

CREATE INDEX OTHER_ZATRATY_INDEX1 ON OTHER_ZATRATY (DAT)
LOGGING;

COMMENT ON TABLE OTHER_ZATRATY IS 'ПрочиеЗатраты';

--
-- Описание для таблицы KASSA_SETTINGS
--
CREATE TABLE KASSA_SETTINGS (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  USER_ID  VARCHAR2(50 CHAR) NOT NULL,
  KASSA_ID VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT KASSA_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                     NEXT 1 M
                                                                     MAXEXTENTS UNLIMITED),
  CONSTRAINT KASSA_SETTINGS_FK1 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID) ON DELETE CASCADE,
  CONSTRAINT KASSA_SETTINGS_FK2 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE KASSA_SETTINGS IS 'НастройкиПользователяДляКассы';

--
-- Описание для таблицы COMPAIGNS_DETAILS
--
CREATE TABLE COMPAIGNS_DETAILS (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  COMPAIGN_ID VARCHAR2(50 CHAR) NOT NULL,
  KONTRAG_ID  VARCHAR2(50 CHAR) NOT NULL,
  CONTACT_ID  VARCHAR2(50 CHAR) NOT NULL,
  VERSION     TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CONSTRAINT COMPAIGNS_DETAILS_PK PRIMARY KEY (ID),
  CONSTRAINT COMPAIGNS_DETAILS_FK1 FOREIGN KEY (COMPAIGN_ID)
  REFERENCES COMPAIGNS (ID) ON DELETE SET NULL,
  CONSTRAINT COMPAIGNS_DETAILS_FK2 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE SET NULL,
  CONSTRAINT COMPAIGNS_DETAILS_FK3 FOREIGN KEY (CONTACT_ID)
  REFERENCES CONTACT_DETAILS (ID) ON DELETE SET NULL
)
LOGGING;

COMMENT ON TABLE COMPAIGNS_DETAILS IS 'ТЧ_ЛистыОбзвона';

--
-- Описание для таблицы PROFIT_DISTRIB_TP
--
CREATE TABLE PROFIT_DISTRIB_TP (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  PROFIT_ID   VARCHAR2(50 CHAR) NOT NULL,
  DAT_NACH    DATE              DEFAULT sysdate NOT NULL,
  KONTR_ID    VARCHAR2(50 CHAR) NOT NULL,
  SUMM        NUMBER(10, 2)     NOT NULL,
  DESCRIPTION VARCHAR2(1000 CHAR),
  CALC_ID     VARCHAR2(50 CHAR) NOT NULL,
  PERCENT     NUMBER(10, 2)     NOT NULL,
  PAY_ID      VARCHAR2(50 CHAR),
  MANUAL      NUMBER(1, 0)      NOT NULL,
  CONSTRAINT PROFIT_DISTRIB_TP_PK PRIMARY KEY (ID),
  CONSTRAINT PROFIT_DISTRIB_TP_FK1 FOREIGN KEY (PROFIT_ID)
  REFERENCES PROFIT_DISTRIB (ID) ON DELETE CASCADE,
  CONSTRAINT PROFIT_DISTRIB_TP_FK2 FOREIGN KEY (KONTR_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT PROFIT_DISTRIB_TP_FK3 FOREIGN KEY (CALC_ID)
  REFERENCES BASE_OF_CALC (ID),
  CONSTRAINT PROFIT_DISTRIB_TP_FK4 FOREIGN KEY (PAY_ID)
  REFERENCES PAY_SETTINGS (ID)
)
LOGGING;

CREATE INDEX PROFIT_DISTRIB_TP_INDEX1 ON PROFIT_DISTRIB_TP (PROFIT_ID)
LOGGING;

COMMENT ON TABLE PROFIT_DISTRIB_TP IS 'ТЧ_РаспределениеПрибыли';

--
-- Описание для таблицы ORDERS
--
CREATE TABLE ORDERS (
  ID                VARCHAR2(50 CHAR) NOT NULL,
  DAT               DATE              DEFAULT current_timestamp NOT NULL,
  NUM               VARCHAR2(50 CHAR) NOT NULL,
  KONTRAG_ID        VARCHAR2(50 CHAR) NOT NULL,
  CURR_ID           VARCHAR2(50 CHAR) NOT NULL,
  KASSA_ID          VARCHAR2(50 CHAR) NOT NULL,
  DIVISION_ID       VARCHAR2(50 CHAR) NOT NULL,
  USER_ID           VARCHAR2(50 CHAR) NOT NULL,
  KURS              NUMBER(10, 6)     DEFAULT 1 NOT NULL,
  KRATNOST          NUMBER(10, 0)     DEFAULT 1 NOT NULL,
  DISCRIPTION       VARCHAR2(2000 CHAR),
  DELETED           NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  VERSION           TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  POSTED            NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  FIRM_ID           VARCHAR2(50 CHAR) NOT NULL,
  ACTIVITIES_ID     VARCHAR2(50 CHAR) NOT NULL,
  STATUS_ID         VARCHAR2(50 CHAR) NOT NULL,
  ZAMER_ID          VARCHAR2(50 CHAR),
  DAT_ZAM           DATE              DEFAULT sysdate NOT NULL,
  TIME_ZAM          VARCHAR2(5 CHAR)  DEFAULT '00:00' NOT NULL,
  SUMM_PLAN         NUMBER(10, 2)     DEFAULT 0 NOT NULL,
  DAT_COMPLETE      DATE,
  AGENT_ID          VARCHAR2(50 CHAR),
  DAT_COMPLETE_FACT DATE,
  DIVISION_DEST     VARCHAR2(50 CHAR),
  CONSTRAINT ORDERS_CHK1 CHECK (DELETED IN (1, 0)),
  CONSTRAINT ORDERS_CHK2 CHECK (POSTED IN (1, 0)),
  CONSTRAINT ORDERS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                             NEXT 1 M
                                                             MAXEXTENTS UNLIMITED),
  CONSTRAINT ORDERS_CURRENCY_FK1 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT ORDERS_DIVISIONS_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT ORDERS_FIRMS_FK1 FOREIGN KEY (FIRM_ID)
  REFERENCES FIRMS (ID),
  CONSTRAINT ORDERS_FK1 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID),
  CONSTRAINT ORDERS_FK2 FOREIGN KEY (ZAMER_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE SET NULL,
  CONSTRAINT ORDERS_FK3 FOREIGN KEY (AGENT_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT ORDERS_FK4 FOREIGN KEY (DIVISION_DEST)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT ORDERS_KASSA_FK1 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID),
  CONSTRAINT ORDERS_KONTRAGENTS_FK1 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT ORDERS_STATUS_FK FOREIGN KEY (STATUS_ID)
  REFERENCES ORDER_STATUS (ID) ON DELETE SET NULL,
  CONSTRAINT ORDERS_USERS_FK1 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID)
)
LOGGING;

CREATE INDEX ORDERS_INDEX1 ON ORDERS (DAT)
LOGGING;

COMMENT ON TABLE ORDERS IS 'Заказы';

--
-- Описание для таблицы USER_SETTINGS
--
CREATE TABLE USER_SETTINGS (
  ID              VARCHAR2(50 CHAR) NOT NULL,
  USER_ID         VARCHAR2(50 CHAR) NOT NULL,
  DIVISION_ID     VARCHAR2(50 CHAR) NOT NULL,
  FIRMA_ID        VARCHAR2(50 CHAR) NOT NULL,
  CURRENCY_ID     VARCHAR2(50 CHAR) NOT NULL,
  KASSA_ID        VARCHAR2(50 CHAR) NOT NULL,
  MAIN_USLUGA     VARCHAR2(50 CHAR),
  ACTIVITIES_ID   VARCHAR2(50 CHAR) NOT NULL,
  ZAMERKONTRAG_ID VARCHAR2(50 CHAR),
  KONTRAG_ID      VARCHAR2(50 CHAR),
  NET_ID          VARCHAR2(50 CHAR),
  CONSTRAINT USER_SETTINGS_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                    NEXT 1 M
                                                                    MAXEXTENTS UNLIMITED),
  CONSTRAINT USER_SETTINGS_CURRENCY_FK1 FOREIGN KEY (CURRENCY_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT USER_SETTINGS_DIVISIONS_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT USER_SETTINGS_FIRMS_FK1 FOREIGN KEY (FIRMA_ID)
  REFERENCES FIRMS (ID),
  CONSTRAINT USER_SETTINGS_FK1 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID),
  CONSTRAINT USER_SETTINGS_FK2 FOREIGN KEY (ZAMERKONTRAG_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT USER_SETTINGS_FK3 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT USER_SETTINGS_FK4 FOREIGN KEY (NET_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT USER_SETTINGS_KASSA_FK1 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID),
  CONSTRAINT USER_SETTINGS_NOMENKLATUR_FK1 FOREIGN KEY (MAIN_USLUGA)
  REFERENCES NOMENKLATURA (ID) DISABLE,
  CONSTRAINT USER_SETTINGS_USERS_FK1 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID) ON DELETE CASCADE,
  CONSTRAINT USER_SETTINGS_UK1 UNIQUE (USER_ID) USING INDEX STORAGE (INITIAL 64 K
                                                                     NEXT 1 M
                                                                     MAXEXTENTS UNLIMITED)
)
LOGGING;

COMMENT ON TABLE USER_SETTINGS IS 'НастройкиПользователей';

--
-- Описание для таблицы CALL_LOG
--
CREATE TABLE CALL_LOG (
  ID           VARCHAR2(50 CHAR) NOT NULL,
  CALL_STATUS  VARCHAR2(50 CHAR) NOT NULL,
  CONTACT_ID   VARCHAR2(50 CHAR) NOT NULL,
  COMP_DET_ID  VARCHAR2(50 CHAR),
  MEMO         VARCHAR2(2000 CHAR),
  VERSION      TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  DAT          DATE              DEFAULT current_timestamp NOT NULL,
  CALL_RESULTS VARCHAR2(50 CHAR) NOT NULL,
  KONTRAG_ID   VARCHAR2(50 CHAR),
  CONSTRAINT CALL_LOG_PK PRIMARY KEY (ID),
  CONSTRAINT CALL_LOG_FK1 FOREIGN KEY (CALL_STATUS)
  REFERENCES CALL_STATUS (ID) ON DELETE SET NULL,
  CONSTRAINT CALL_LOG_FK2 FOREIGN KEY (CONTACT_ID)
  REFERENCES CONTACT_DETAILS (ID) ON DELETE CASCADE,
  CONSTRAINT CALL_LOG_FK3 FOREIGN KEY (COMP_DET_ID)
  REFERENCES COMPAIGNS_DETAILS (ID),
  CONSTRAINT CALL_LOG_FK4 FOREIGN KEY (CALL_RESULTS)
  REFERENCES CALL_RESULTS (ID),
  CONSTRAINT CALL_LOG_FK5 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE CASCADE
)
LOGGING;

COMMENT ON TABLE CALL_LOG IS 'ПротоколЗвонков';

--
-- Описание для таблицы ORDERS_TP_OPLATY
--
CREATE TABLE ORDERS_TP_OPLATY (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  ORDER_ID VARCHAR2(50 CHAR) NOT NULL,
  DAT      DATE              DEFAULT sysdate NOT NULL,
  SUM      NUMBER(10, 2)     NOT NULL,
  USER_ID  VARCHAR2(50 CHAR) NOT NULL,
  COMMENTS VARCHAR2(1000 CHAR),
  ZAMER_ID VARCHAR2(50 CHAR),
  KASSA_ID VARCHAR2(50 CHAR),
  CONSTRAINT ORDERS_TP_OPLATY_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                       NEXT 1 M
                                                                       MAXEXTENTS UNLIMITED),
  CONSTRAINT ORDERS_TP_OPLATY_FK1 FOREIGN KEY (ORDER_ID)
  REFERENCES ORDERS (ID) ON DELETE CASCADE,
  CONSTRAINT ORDERS_TP_OPLATY_FK2 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID),
  CONSTRAINT ORDERS_TP_OPLATY_FK3 FOREIGN KEY (ZAMER_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE SET NULL,
  CONSTRAINT ORDERS_TP_OPLATY_FK4 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID)
)
LOGGING;

CREATE INDEX ORDERS_TP_OPLATY_INDEX1 ON ORDERS_TP_OPLATY (ORDER_ID)
LOGGING;

COMMENT ON TABLE ORDERS_TP_OPLATY IS 'ТЧ_Заказы - Оплаты';

--
-- Описание для таблицы ORDERS_TP_NACHISL
--
CREATE TABLE ORDERS_TP_NACHISL (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  ORDER_ID    VARCHAR2(50 CHAR) NOT NULL,
  DAT_NACH    DATE              DEFAULT sysdate NOT NULL,
  KONTR_ID    VARCHAR2(50 CHAR) NOT NULL,
  SUMM        NUMBER(10, 2)     NOT NULL,
  DESCRIPTION VARCHAR2(1000 CHAR),
  CALC_ID     VARCHAR2(50 CHAR) NOT NULL,
  PERCENT     NUMBER(10, 2)     NOT NULL,
  MANUAL      NUMBER(1, 0),
  PAY_ID      VARCHAR2(50 CHAR),
  CONSTRAINT ORDERS_TP_NACHISL_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                        NEXT 1 M
                                                                        MAXEXTENTS UNLIMITED),
  CONSTRAINT ORDERS_TP_NACHISL_FK1 FOREIGN KEY (ORDER_ID)
  REFERENCES ORDERS (ID) ON DELETE CASCADE,
  CONSTRAINT ORDERS_TP_NACHISL_FK2 FOREIGN KEY (KONTR_ID)
  REFERENCES KONTRAGENTS (ID) ON DELETE CASCADE,
  CONSTRAINT ORDERS_TP_NACHISL_FK3 FOREIGN KEY (CALC_ID)
  REFERENCES BASE_OF_CALC (ID) ON DELETE SET NULL,
  CONSTRAINT ORDERS_TP_NACHISL_FK4 FOREIGN KEY (PAY_ID)
  REFERENCES PAY_SETTINGS (ID)
)
LOGGING;

CREATE INDEX ORDERS_TP_NACHISL_INDEX1 ON ORDERS_TP_NACHISL (ORDER_ID)
LOGGING;

COMMENT ON TABLE ORDERS_TP_NACHISL IS 'ТЧ_Заказы - Начисления';

--
-- Описание для таблицы RKO
--
CREATE TABLE RKO (
  ID            VARCHAR2(50 CHAR) NOT NULL,
  DAT           DATE              DEFAULT sysdate NOT NULL,
  NUM           VARCHAR2(50 CHAR) NOT NULL,
  DELETED       NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  POSTED        NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  DIVISION_ID   VARCHAR2(50 CHAR) NOT NULL,
  USER_ID       VARCHAR2(50 CHAR) NOT NULL,
  COMMENTS      VARCHAR2(255 CHAR),
  VERSION       TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CURR_ID       VARCHAR2(50 CHAR) NOT NULL,
  KASSA_ID      VARCHAR2(50 CHAR) NOT NULL,
  ACTIVITIES_ID VARCHAR2(50 CHAR) NOT NULL,
  OPERATION_ID  VARCHAR2(50 CHAR) NOT NULL,
  KONTRAG_ID    VARCHAR2(50 CHAR),
  SUMMA         NUMBER            NOT NULL,
  DEST_KASSA_ID VARCHAR2(50 CHAR),
  ORDER_ID      VARCHAR2(50 CHAR),
  CONSTRAINT RKO_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                          NEXT 1 M
                                                          MAXEXTENTS UNLIMITED),
  CONSTRAINT RKO_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT RKO_FK2 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID),
  CONSTRAINT RKO_FK3 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT RKO_FK4 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID),
  CONSTRAINT RKO_FK5 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID),
  CONSTRAINT RKO_FK6 FOREIGN KEY (OPERATION_ID)
  REFERENCES OPERATION_RKO (ID),
  CONSTRAINT RKO_FK7 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT RKO_FK8 FOREIGN KEY (DEST_KASSA_ID)
  REFERENCES KASSA (ID),
  CONSTRAINT RKO_FK9 FOREIGN KEY (ORDER_ID)
  REFERENCES ORDERS (ID)
)
LOGGING;

CREATE INDEX RKO_INDEX1 ON RKO (DAT)
LOGGING;

CREATE INDEX RKO_INDEX2 ON RKO (ORDER_ID)
LOGGING;

CREATE INDEX RKO_INDEX3 ON RKO (ORDER_ID, POSTED)
LOGGING;

COMMENT ON TABLE RKO IS 'РасходныеКассовыеОрдера';

--
-- Описание для таблицы PKO
--
CREATE TABLE PKO (
  ID            VARCHAR2(50 CHAR) NOT NULL,
  DAT           DATE              DEFAULT sysdate NOT NULL,
  NUM           VARCHAR2(50 CHAR) NOT NULL,
  DELETED       NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  POSTED        NUMBER(1, 0)      DEFAULT 0 NOT NULL,
  DIVISION_ID   VARCHAR2(50 CHAR) NOT NULL,
  USER_ID       VARCHAR2(50 CHAR) NOT NULL,
  COMMENTS      VARCHAR2(255 CHAR),
  VERSION       TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  CURR_ID       VARCHAR2(50 CHAR) NOT NULL,
  KASSA_ID      VARCHAR2(50 CHAR) NOT NULL,
  ACTIVITIES_ID VARCHAR2(50 CHAR) NOT NULL,
  OPERATION_ID  VARCHAR2(50 CHAR) NOT NULL,
  KONTRAG_ID    VARCHAR2(50 CHAR),
  SUMMA         NUMBER            NOT NULL,
  ORDER_ID      VARCHAR2(50 CHAR),
  CONSTRAINT PKO_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                          NEXT 1 M
                                                          MAXEXTENTS UNLIMITED),
  CONSTRAINT PKO_FK1 FOREIGN KEY (DIVISION_ID)
  REFERENCES DIVISIONS (ID),
  CONSTRAINT PKO_FK2 FOREIGN KEY (USER_ID)
  REFERENCES USERS (ID),
  CONSTRAINT PKO_FK3 FOREIGN KEY (CURR_ID)
  REFERENCES CURRENCY (ID),
  CONSTRAINT PKO_FK4 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID),
  CONSTRAINT PKO_FK5 FOREIGN KEY (ACTIVITIES_ID)
  REFERENCES TYPE_OF_ACTIVITIES (ID),
  CONSTRAINT PKO_FK6 FOREIGN KEY (OPERATION_ID)
  REFERENCES OPERATION_PKO (ID),
  CONSTRAINT PKO_FK7 FOREIGN KEY (KONTRAG_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT PKO_FK8 FOREIGN KEY (ORDER_ID)
  REFERENCES ORDERS (ID)
)
LOGGING;

CREATE INDEX PKO_INDEX1 ON PKO (DAT)
LOGGING;

CREATE INDEX PKO_INDEX2 ON PKO (ORDER_ID, POSTED)
LOGGING;

COMMENT ON TABLE PKO IS 'ПриходныеКассовыеОрдера';

--
-- Описание для таблицы ORDERS_TP_USLUGI
--
CREATE TABLE ORDERS_TP_USLUGI (
  ID           VARCHAR2(50 CHAR) NOT NULL,
  ORDER_ID     VARCHAR2(50 CHAR) NOT NULL,
  NOM_ID       VARCHAR2(50 CHAR) NOT NULL,
  PRICE        NUMBER(10, 3)     NOT NULL,
  SUMM         NUMBER(10, 2)     NOT NULL,
  DAT_COMPLETE DATE              DEFAULT sysdate NOT NULL,
  SOTR_ID      VARCHAR2(50 CHAR) NOT NULL,
  DAT_TO_PAY   DATE              DEFAULT sysdate,
  GROUP_ID     VARCHAR2(50 CHAR),
  MEASURE_ID   VARCHAR2(50 CHAR) NOT NULL,
  QUANTITY     NUMBER(10, 3)     NOT NULL,
  ADD_WORK     VARCHAR2(1000 CHAR),
  PRICE_ADD    NUMBER(10, 2),
  CONSTRAINT ORDERS_TP_USLUGI_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                       NEXT 1 M
                                                                       MAXEXTENTS UNLIMITED),
  CONSTRAINT ORDERS_TP_USLUGI_FK1 FOREIGN KEY (ORDER_ID)
  REFERENCES ORDERS (ID) ON DELETE CASCADE,
  CONSTRAINT ORDERS_TP_USLUGI_FK2 FOREIGN KEY (NOM_ID)
  REFERENCES NOMENKLATURA (ID) ON DELETE SET NULL,
  CONSTRAINT ORDERS_TP_USLUGI_FK3 FOREIGN KEY (SOTR_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT ORDERS_TP_USLUGI_FK4 FOREIGN KEY (GROUP_ID)
  REFERENCES NOMENKLATURA (ID) ON DELETE SET NULL,
  CONSTRAINT ORDERS_TP_USLUGI_FK5 FOREIGN KEY (MEASURE_ID)
  REFERENCES MEASURE_UNIT (ID)
)
LOGGING;

CREATE INDEX ORDERS_TP_USLUGI_INDEX1 ON ORDERS_TP_USLUGI (ORDER_ID)
LOGGING;

COMMENT ON TABLE ORDERS_TP_USLUGI IS 'ТЧ_Заказы - Услуги';

--
-- Описание для таблицы OTHER_ZATRATY_TAB_PART_ZATRATY
--
CREATE TABLE OTHER_ZATRATY_TAB_PART_ZATRATY (
  ID      VARCHAR2(50 CHAR) NOT NULL,
  OTH_ID  VARCHAR2(50 CHAR) NOT NULL,
  ZATR_ID VARCHAR2(50 CHAR) NOT NULL,
  SUMMA   NUMBER(38, 2)     NOT NULL,
  CONSTRAINT OTHER_ZATRATY_TAB_PART_ZAT_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                                 NEXT 1 M
                                                                                 MAXEXTENTS UNLIMITED),
  CONSTRAINT OTHER_ZATRATY_TAB_PART_ZA_FK1 FOREIGN KEY (OTH_ID)
  REFERENCES OTHER_ZATRATY (ID) ON DELETE CASCADE,
  CONSTRAINT OTHER_ZATRATY_TAB_PART_ZA_FK2 FOREIGN KEY (ZATR_ID)
  REFERENCES ZATRATY (ID) ON DELETE SET NULL
)
LOGGING;

COMMENT ON TABLE OTHER_ZATRATY_TAB_PART_ZATRATY IS 'ТЧ_ПрочиеЗатраты - Затраты';

--
-- Описание для таблицы ORDERS_TP_RASHODY
--
CREATE TABLE ORDERS_TP_RASHODY (
  ID          VARCHAR2(50 CHAR) NOT NULL,
  ORDER_ID    VARCHAR2(50 CHAR) NOT NULL,
  DAT_RASH    DATE              DEFAULT sysdate NOT NULL,
  KONTR_ID    VARCHAR2(50 CHAR),
  SUMM        NUMBER(10, 2)     NOT NULL,
  DESCRIPTION VARCHAR2(1000 CHAR),
  ZATRATY_ID  VARCHAR2(50 CHAR) NOT NULL,
  KASSA_ID    VARCHAR2(50 CHAR),
  CONSTRAINT ORDERS_TP_RASHODY_PK PRIMARY KEY (ID) USING INDEX STORAGE (INITIAL 64 K
                                                                        NEXT 1 M
                                                                        MAXEXTENTS UNLIMITED),
  CONSTRAINT ORDERS_TP_RASHODY_FK1 FOREIGN KEY (ORDER_ID)
  REFERENCES ORDERS (ID) ON DELETE CASCADE,
  CONSTRAINT ORDERS_TP_RASHODY_FK2 FOREIGN KEY (KONTR_ID)
  REFERENCES KONTRAGENTS (ID),
  CONSTRAINT ORDERS_TP_RASHODY_FK3 FOREIGN KEY (ZATRATY_ID)
  REFERENCES ZATRATY (ID),
  CONSTRAINT ORDERS_TP_RASHODY_FK4 FOREIGN KEY (KASSA_ID)
  REFERENCES KASSA (ID)
)
LOGGING;

CREATE INDEX ORDERS_TP_RASHODY_INDEX1 ON ORDERS_TP_RASHODY (ORDER_ID)
LOGGING;

COMMENT ON TABLE ORDERS_TP_RASHODY IS 'ТЧ_Заказы - Расходы';

--
-- Описание для таблицы CALL_MEMO
--
CREATE TABLE CALL_MEMO (
  ID       VARCHAR2(50 CHAR) NOT NULL,
  VERSION  TIMESTAMP(6)      DEFAULT systimestamp NOT NULL,
  DAT      DATE              NOT NULL,
  CALL_LOG VARCHAR2(50 CHAR) NOT NULL,
  CONSTRAINT CALL_MEMO_PK PRIMARY KEY (ID),
  CONSTRAINT CALL_MEMO_FK1 FOREIGN KEY (CALL_LOG)
  REFERENCES CALL_LOG (ID)
)
LOGGING;

COMMENT ON TABLE CALL_MEMO IS 'ТЧ_ПротоколЗвонков';

--
-- Описание для пакета ORDERS_ENTRY
--
CREATE OR REPLACE PACKAGE "ORDERS_ENTRY"
  AS
  gn$startdatmoves DATE := TO_DATE('01-01-1970 00:00:00', 'DD-MM-YYYY HH24:MI:SS');
  gn$enddatmoves DATE := systimestamp;

  PROCEDURE set_startdatmoves(in_dat DATE);
  FUNCTION get_startdatmoves
    RETURN DATE;

  PROCEDURE set_enddatmoves(in_dat DATE);
  FUNCTION get_enddatmoves
    RETURN DATE;


  PROCEDURE orders_move_plan_acc(p_id IN VARCHAR2);
  PROCEDURE orders_remove_plan_acc(p_id  IN VARCHAR2,
                                   p_del IN NUMBER DEFAULT 0);
  PROCEDURE orders_move_all;
  PROCEDURE orders_remove_all;

END orders_entry;
/

CREATE OR REPLACE PACKAGE BODY "ORDERS_ENTRY"
  AS

  PROCEDURE set_startdatmoves(in_dat DATE)
    AS
    BEGIN
      gn$startdatmoves := in_dat;
    END set_startdatmoves;

  PROCEDURE set_enddatmoves(in_dat DATE)
    AS
    BEGIN
      gn$enddatmoves := in_dat;
    END set_enddatmoves;

  FUNCTION get_startdatmoves
    RETURN DATE
    AS
    BEGIN
      RETURN gn$startdatmoves;
    END get_startdatmoves;

  FUNCTION get_enddatmoves
    RETURN DATE
    AS
    BEGIN
      RETURN gn$enddatmoves;
    END get_enddatmoves;

  PROCEDURE orders_remove_plan_acc(p_id  IN VARCHAR2,
                                   p_del IN NUMBER DEFAULT 0)
    AS
      p_orders_rec   orders % ROWTYPE;
      p_move_count   NUMBER;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_orders_rec
        FROM orders
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_orders_rec.id, 'orders') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM orders
        WHERE id = p_id;
      SELECT COUNT(*)
        INTO p_move_count
        FROM moves
        WHERE registrator_id = p_id;
      IF p_move_count > 0
      THEN
        EXECUTE IMMEDIATE ('select * from moves where registrator_id=''' || p_id || ''' for update nowait');
        DELETE FROM moves
          WHERE registrator_id = p_id;
      END IF;

      IF p_del <> 0
      THEN
        p_orders_rec.deleted := 1;
      END IF;
      p_orders_rec.posted := 0;
      UPDATE orders
        SET ROW = p_orders_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');
    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || sqlerrm, TRUE);
    END orders_remove_plan_acc;

  PROCEDURE orders_move_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM orders)
      LOOP
        orders_move_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move  all for plan accounting! ' || SQLERRM, TRUE);
    END orders_move_all;

  PROCEDURE orders_remove_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM orders)
      LOOP
        orders_remove_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order remove all for plan accounting! ' || SQLERRM, TRUE);
    END orders_remove_all;

  PROCEDURE set_subconto_tp_uslugi(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_order     orders % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
      p_code_plan plan_acc.code % TYPE;
      p_usluga    nomenklatura.usluga % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM ORDERS_TP_USLUGI
          WHERE order_id = p_order.id)
      LOOP
        p_ret_rec := p_move_rec;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;
        SELECT usluga
          INTO p_usluga
          FROM nomenklatura
          WHERE id = i.nom_id;
        IF p_usluga = 1
          AND p_code_plan = '20351'
        THEN
          CONTINUE;
        END IF;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_kred_id;
        IF p_usluga = 1
          AND p_code_plan = '20351'
        THEN
          CONTINUE;
        END IF;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kontrag_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kontrag_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kontrag_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'НОМЕНКЛАТУРА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := i.nom_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := i.nom_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := i.nom_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'НОМЕНКЛАТУРА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := i.nom_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := i.nom_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := i.nom_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.kontrag_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        SELECT *
          INTO p_plan_acc
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;
        IF p_plan_acc.kolishestv = 1
        THEN
          p_ret_rec.quantity_deb := i.quantity;
        END IF;
        SELECT *
          INTO p_plan_acc
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_kred_id;
        IF p_plan_acc.kolishestv = 1
        THEN
          p_ret_rec.quantity_kred := i.quantity;
        END IF;

        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.summ + NVL(i.price_add, 0), 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.summ + NVL(i.price_add, 0), 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_tp_uslugi;

  PROCEDURE set_subconto_tp_oplaty(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_order     orders % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
      p_code_plan plan_acc.code % TYPE;
      p_usluga    nomenklatura.usluga % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM ORDERS_TP_OPLATY
          WHERE order_id = p_order.id)
      LOOP
        p_ret_rec := p_move_rec;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto1_deb := i.kassa_id;
                ELSE
                  p_ret_rec.subconto1_deb := p_order.kassa_id;
                END IF;
              END IF;
              IF p_counter = 2
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto2_deb := i.kassa_id;
                ELSE
                  p_ret_rec.subconto2_deb := p_order.kassa_id;
                END IF;
              END IF;
              IF p_counter = 3
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto3_deb := i.kassa_id;
                ELSE
                  p_ret_rec.subconto3_deb := p_order.kassa_id;
                END IF;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kontrag_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kontrag_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kontrag_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.kontrag_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kassa_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.sum, 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.sum, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;
        p_ret_rec.period := i.dat;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_tp_oplaty;

  PROCEDURE set_subconto_zamer(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_order     orders % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
      p_code_plan plan_acc.code % TYPE;
      p_usluga    nomenklatura.usluga % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM ORDERS_TP_OPLATY
          WHERE order_id = p_order.id)
      LOOP
        IF i.zamer_id IS NULL
        THEN
          CONTINUE;
        END IF;
        p_ret_rec := p_move_rec;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := i.zamer_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := i.zamer_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := i.zamer_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kassa_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto1_kred := i.kassa_id;
                ELSE
                  p_ret_rec.subconto1_kred := p_order.kassa_id;
                END IF;
              END IF;
              IF p_counter = 2
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto2_kred := i.kassa_id;
                ELSE
                  p_ret_rec.subconto2_kred := p_order.kassa_id;
                END IF;
              END IF;
              IF p_counter = 3
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto3_kred := i.kassa_id;
                ELSE
                  p_ret_rec.subconto3_kred := p_order.kassa_id;
                END IF;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.kontrag_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.sum, 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.sum, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_zamer;

  PROCEDURE set_subconto_rashody_rko(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_order     orders % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
      p_code_plan plan_acc.code % TYPE;
      p_usluga    nomenklatura.usluga % TYPE;
      p_status    order_status.id % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      SELECT id
        INTO p_status
        FROM order_status
        WHERE UPPER(name) = UPPER('Выполнен');

      FOR i IN (SELECT *
          FROM ORDERS_TP_RASHODY
          WHERE order_id = p_order.id)
      LOOP
        p_ret_rec := p_move_rec;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'СТАТЬЯ ЗАТРАТ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := i.zatraty_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := i.zatraty_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := i.zatraty_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kassa_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        IF i.kontr_id IS NOT NULL
        THEN
          --if p_order.status_id = p_status then
          SELECT id
            INTO p_ret_rec.plan_acc_kred_id
            FROM plan_acc
            WHERE code = '5091';
        --end if;
        END IF;
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto1_kred := i.kassa_id;
                ELSE
                  p_ret_rec.subconto1_kred := p_order.kassa_id;
                END IF;
              END IF;
              IF p_counter = 2
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto2_kred := i.kassa_id;
                ELSE
                  p_ret_rec.subconto2_kred := p_order.kassa_id;
                END IF;
              END IF;
              IF p_counter = 3
              THEN
                IF i.kassa_id IS NOT NULL
                THEN
                  p_ret_rec.subconto3_kred := i.kassa_id;
                ELSE
                  p_ret_rec.subconto3_kred := p_order.kassa_id;
                END IF;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := i.kontr_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := i.kontr_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := i.kontr_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.summ, 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.summ, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_rashody_rko;

  PROCEDURE set_subconto_rashody_sebest(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_order     orders % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
      p_code_plan plan_acc.code % TYPE;
      p_usluga    nomenklatura.usluga % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM ORDERS_TP_RASHODY
          WHERE order_id = p_order.id)
      LOOP
        p_ret_rec := p_move_rec;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kassa_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'СТАТЬЯ ЗАТРАТ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := i.zatraty_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := i.zatraty_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := i.zatraty_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.kontrag_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.kontrag_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.summ, 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.summ, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_rashody_sebest;

  PROCEDURE set_subconto_nachisl(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_order     orders % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
      p_code_plan plan_acc.code % TYPE;
      p_usluga    nomenklatura.usluga % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM ORDERS_TP_NACHISL
          WHERE order_id = p_order.id)
      LOOP
        p_ret_rec := p_move_rec;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kassa_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := i.kontr_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := i.kontr_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := i.kontr_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.kassa_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.summ, 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.summ, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_nachisl;

  PROCEDURE set_subconto_close_order(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_order     orders % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
      p_code_plan plan_acc.code % TYPE;
      p_usluga    nomenklatura.usluga % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM vw_moves
          WHERE registrator_id = p_order.id
            AND deb = '701')
      LOOP
        p_ret_rec := p_move_rec;
        p_ret_rec.period := p_order.dat_complete_fact;

        SELECT code
          INTO p_code_plan
          FROM plan_acc
          WHERE id = p_ret_rec.plan_acc_deb_id;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.kassa_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;

            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.kassa_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_order.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_order.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_order.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.SUM_DEB, 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.SUM_DEB, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_close_order;

  FUNCTION getCalcSumm(p_sum IN NUMBER,
                       p_or  IN VARCHAR)
    RETURN NUMBER
    AS
      p_middle NUMBER := 0;
    BEGIN
      SELECT NVL(SUM(summ), 0)
        INTO p_middle
        FROM orders_tp_nachisl
        WHERE order_id = p_or
          AND pay_id IN (SELECT pay_id
              FROM INSIDE_SETTINGS);
      RETURN p_sum + p_middle;
    END getCalcSumm;

  PROCEDURE set_subconto_finrez_order(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec      moves % ROWTYPE;
      p_sub_count    NUMBER(10);
      p_counter      NUMBER(10);
      p_sub_name     plan_type_subconto.fullname % TYPE;
      p_order        orders % ROWTYPE;
      p_plan_acc     plan_acc % ROWTYPE;
      p_upr_val      currency.id % TYPE;
      --p_code_plan plan_acc.code%type;
      p_usluga       nomenklatura.usluga % TYPE;
      p_summ_sales   NUMBER;
      p_summ_sebest  NUMBER;
      p_summ_calc    NUMBER;
      p_div_dest     orders.division_dest % TYPE;
      p_div          orders.division_id % TYPE;
      p_code_service plan_acc.id % TYPE;
    BEGIN
      SELECT *
        INTO p_order
        FROM orders
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;
      p_div_dest := p_order.division_dest;
      p_div := p_order.division_id;

      SELECT id
        INTO p_code_service
        FROM PLAN_ACC
        WHERE code LIKE '511';

      --for i in (select * from vw_moves where registrator_id = p_order.id and deb = '701') loop
      p_ret_rec := p_move_rec;
      p_ret_rec.period := p_order.dat_complete_fact;
      SELECT SUM(NVL(summa, 0))
        INTO p_summ_sales
        FROM VW_SALES_ORDERS
        WHERE registrator_id = p_move_rec.registrator_id;
      SELECT SUM(NVL(summa, 0))
        INTO p_summ_sebest
        FROM VW_SEBEST_ORDERS
        WHERE registrator_id = p_move_rec.registrator_id;

      IF (p_summ_sales = 0)
        OR (p_summ_sales IS NULL)
      THEN
        RETURN;
      END IF;

      IF (p_summ_sebest IS NULL)
      THEN
        p_summ_sebest := 0;
      END IF;
      --select code into p_code_plan from plan_acc where id = p_ret_rec.plan_acc_deb_id;

      --Субконто дебета
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'ЦФО'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_deb := p_order.division_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_deb := p_order.division_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_deb := p_order.division_id;
            END IF;
          END IF;

          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_deb := p_order.kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_deb := p_order.kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_deb := p_order.kassa_id;
            END IF;
          END IF;

          IF UPPER(p_sub_name) = 'ЦФО'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_deb := p_order.division_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_deb := p_order.division_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_deb := p_order.division_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      --Субконто кредита
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'ЦФО'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_kred := p_order.division_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_kred := p_order.division_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_kred := p_order.division_id;
            END IF;
          END IF;

          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_kred := p_order.kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_kred := p_order.kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_kred := p_order.kassa_id;
            END IF;
          END IF;
          IF UPPER(p_sub_name) = 'ЦФО'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_kred := p_order.division_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_kred := p_order.division_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_kred := p_order.division_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      p_ret_rec.curr_deb := p_order.curr_id;
      p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, (p_summ_sales - p_summ_sebest), 1);

      p_ret_rec.curr_kred := p_order.curr_id;
      p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, (p_summ_sales - p_summ_sebest), 0);

      p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
      p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

      p_ret_rec.version := systimestamp;

      INSERT INTO moves
      VALUES p_ret_rec;

      IF p_div_dest != p_div
      THEN
        p_summ_calc := getCalcSumm(p_summ_sales - p_summ_sebest, p_order.id);
        p_ret_rec := p_move_rec;
        p_ret_rec.plan_acc_kred_id := p_code_service;
        p_ret_rec.plan_acc_deb_id := p_code_service;
        p_ret_rec.subconto1_deb := p_div;
        p_ret_rec.subconto1_kred := p_div_dest;
        p_ret_rec.curr_deb := p_order.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, p_summ_calc, 1);

        p_ret_rec.curr_kred := p_order.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, p_summ_calc, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;
        INSERT INTO moves
        VALUES p_ret_rec;
      END IF;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_finrez_order;

  PROCEDURE set_dat_complete(p_id IN VARCHAR2)
    AS
      p_orders_rec orders % ROWTYPE;
      p_status     order_status.id % TYPE;
      p_version    VARCHAR2(1000);
    BEGIN
      SELECT *
        INTO p_orders_rec
        FROM orders
        WHERE id = p_id;
      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM orders
        WHERE id = p_id;
      SELECT id
        INTO p_status
        FROM order_status
        WHERE UPPER(name) = UPPER('Выполнен');
      IF p_orders_rec.status_id = p_status
      THEN
        IF p_orders_rec.dat_complete_fact IS NULL
        THEN
          p_orders_rec.dat_complete_fact := sysdate;
          UPDATE orders
            SET ROW = p_orders_rec
            WHERE id = p_id
            AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');
        END IF;
      END IF;
    END set_dat_complete;

  PROCEDURE orders_move_plan_acc(p_id IN VARCHAR2)
    AS
      p_orders_rec   orders % ROWTYPE;
      p_move_rec     moves % ROWTYPE;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      p_counter      NUMBER(10);
      p_status       order_status.id % TYPE;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      set_dat_complete(p_id);

      SELECT *
        INTO p_orders_rec
        FROM orders
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_orders_rec.id, 'orders') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;

      orders_remove_plan_acc(p_id, p_orders_rec.deleted);
      IF p_orders_rec.deleted = 1
      THEN
        RETURN;
      END IF;

      SELECT id
        INTO p_status
        FROM order_status
        WHERE UPPER(name) = UPPER('Аннулирован');

      IF p_status <> p_orders_rec.status_id
      THEN
        DELETE FROM ORDERS_TP_NACHISL
          WHERE order_id = p_id
            AND manual = 0;
        --paycalc.calc_money(p_id);
        PAYCALC.CALC_MONEY_BY_KONTR(p_id);
      END IF;


      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM orders
        WHERE id = p_id;

      SELECT id
        INTO p_status
        FROM order_status
        WHERE UPPER(name) = UPPER('Выполнен');

      p_move_rec.period := p_orders_rec.dat;
      p_counter := 0;
      FOR i IN (SELECT *
          FROM entry_settings
          WHERE typedef_id = (SELECT id
                FROM type_def
                WHERE UPPER(type_def.table_name) = UPPER('orders'))
          ORDER BY chain)
      LOOP
        p_counter := p_counter + 1;
        p_move_rec.registrator_type := i.typedef_id;
        p_move_rec.registrator_id := p_id;
        p_move_rec.plan_acc_deb_id := i.plan_acc_deb_id;
        p_move_rec.activities_id := p_orders_rec.activities_id;
        p_move_rec.division_id := p_orders_rec.division_id;

        p_move_rec.plan_acc_kred_id := i.plan_acc_kred_id;

        --Проводка ТЧ Услуги - Выполнили работы
        IF p_counter = 1
        THEN
          IF p_orders_rec.status_id = p_status
          THEN
            p_move_rec.description := 'Проводка ТЧ Услуги - Выполнили работы';
            set_subconto_tp_uslugi(p_move_rec);
          END IF;
        END IF;
        --Проводка ТЧ Оплаты - Получили предоплату
        IF p_counter = 2
        THEN
          p_move_rec.description := 'Проводка ТЧ Оплаты - Получили предоплату';
          set_subconto_tp_oplaty(p_move_rec);
        END IF;
        --Проводка ТЧ Оплаты - Замерщик взял деньги
        IF p_counter = 3
        THEN
          p_move_rec.description := 'Проводка ТЧ Оплаты - Замерщик взял деньги';
          set_subconto_zamer(p_move_rec);
        END IF;

        --	Проводка ТЧ Расходы - РКО на себестоимость
        IF p_counter = 4
        THEN
          p_move_rec.description := 'Проводка ТЧ Расходы - РКО на себестоимость';
          set_subconto_rashody_rko(p_move_rec);
        END IF;

        --	Проводка ТЧ Расходы - Закрытие себестоимости заказа после выполнения
        IF p_counter = 5
        THEN
          --if p_orders_rec.status_id = p_status then
          p_move_rec.description := 'Проводка ТЧ Расходы - Закрытие себестоимости заказа после выполнения';
          set_subconto_rashody_sebest(p_move_rec);
        --end if;  
        END IF;

        --Проводка ТЧ Начисления - Начисления на себестоимость (комиссия и т.д.)
        IF p_counter = 6
        THEN
          --if p_orders_rec.status_id = p_status then
          p_move_rec.description := 'Проводка ТЧ Начисления - Начисления на себестоимость (комиссия и т.д.)';
          set_subconto_nachisl(p_move_rec);
        --end if;  
        END IF;

        --Закрытие заказа - выполнен!
        IF p_counter = 7
        THEN
          IF p_orders_rec.status_id = p_status
          THEN
            p_move_rec.description := 'Закрытие заказа - выполнен!';
            set_subconto_close_order(p_move_rec);
          END IF;
        END IF;

        --Заказ выполнен - Отнесение маржи на финансовый результат
        IF p_counter = 8
        THEN
          IF p_orders_rec.status_id = p_status
          THEN
            p_move_rec.description := 'Заказ выполнен - Отнесение маржи на финансовый результат';
            set_subconto_finrez_order(p_move_rec);
          END IF;
        END IF;
      END LOOP;

      p_orders_rec.posted := 1;
      UPDATE orders
        SET ROW = p_orders_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');

    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || SQLERRM, TRUE);
    END orders_move_plan_acc;

END orders_entry;

/

--
-- Описание для пакета ENTRY
--
CREATE OR REPLACE PACKAGE "ENTRY"
  AS

  FUNCTION sign_of_summ(p_acc  IN plan_acc.id % TYPE,
                        p_summ IN NUMBER,
                        p_type IN NUMBER)
    RETURN NUMBER;
  FUNCTION get_ostatok_by_date(p_acc IN      plan_acc.code % TYPE,
                               p_dat IN      DATE,
                               p_division_id divisions.id % TYPE)
    RETURN NUMBER;

END entry;
/

CREATE OR REPLACE PACKAGE BODY "ENTRY"
  AS

  --p_type 1 или 0; 1-сумма дебетуется, 0-сумма кредитуется
  FUNCTION sign_of_summ(p_acc  IN plan_acc.id % TYPE,
                        p_summ IN NUMBER,
                        p_type IN NUMBER)
    RETURN NUMBER
    AS
      p_out_summ NUMBER(10, 2);
      p_acc_type enum_account_type.fullname % TYPE;
    BEGIN
      p_out_summ := p_summ;
      SELECT TRIM(fullname)
        INTO p_acc_type
        FROM enum_account_type
        WHERE id = (SELECT acc_type
              FROM plan_acc
              WHERE id = p_acc);
      IF (UPPER(p_acc_type) = UPPER('Активный'))
      THEN
        IF (p_type = 1)
        THEN
          p_out_summ := p_summ;
        ELSE
          p_out_summ := -p_summ;
        END IF;
        RETURN p_out_summ;
      END IF;
      IF (UPPER(p_acc_type) = UPPER('Пассивный'))
      THEN
        IF (p_type = 1)
        THEN
          p_out_summ := -p_summ;
        ELSE
          p_out_summ := p_summ;
        END IF;
        RETURN p_out_summ;
      END IF;

      IF (p_type = 1)
      THEN
        p_out_summ := p_summ;
      ELSE
        p_out_summ := -p_summ;
      END IF;
      RETURN p_out_summ;
    END sign_of_summ;

  FUNCTION get_ostatok_by_date(p_acc IN      plan_acc.code % TYPE,
                               p_dat IN      DATE,
                               p_division_id divisions.id % TYPE)
    RETURN NUMBER
    AS
      p_sum_deb  NUMBER;
      p_sum_kred NUMBER;
    BEGIN
      SELECT NVL(SUM(vw_moves.SUM_DEB), 0)
        INTO p_sum_deb
        FROM vw_moves
        WHERE deb = p_acc
          AND DIVISION_ID = p_division_id
          AND TRUNC(period) <= TRUNC(p_dat);

      SELECT NVL(SUM(vw_moves.SUM_KRED), 0)
        INTO p_sum_kred
        FROM vw_moves
        WHERE kred = p_acc
          AND DIVISION_ID = p_division_id
          AND TRUNC(period) <= TRUNC(p_dat);

      RETURN p_sum_deb + p_sum_kred;

    END get_ostatok_by_date;

END entry;

/

--
-- Описание для пакета REPORT_PKG
--
CREATE OR REPLACE PACKAGE "REPORT_PKG"
  AS

  FUNCTION getzatraty(f_data DATE DEFAULT NULL,
                      l_data DATE DEFAULT NULL)
    RETURN tbl_zatraty;

  FUNCTION getsales(f_data DATE DEFAULT NULL,
                    l_data DATE DEFAULT NULL)
    RETURN tbl_sales;

  FUNCTION getballans(f_data DATE DEFAULT NULL,
                      l_data DATE DEFAULT NULL)
    RETURN tbl_ballans;

  FUNCTION getrating(f_data DATE DEFAULT NULL,
                     l_data DATE DEFAULT NULL)
    RETURN tbl_rating;

  FUNCTION getreference(p_tablename IN VARCHAR2)
    RETURN tbl_reference;

  FUNCTION getreftable(p_id        IN VARCHAR2,
                       p_tablename IN VARCHAR2)
    RETURN tbl_ref_tab;

  FUNCTION get_deleted_tables
    RETURN tbl_deleted;

  FUNCTION get_deletedref_tables
    RETURN tbl_deleted_ref;

  PROCEDURE refresh_ballans(f_data DATE DEFAULT NULL,
                            l_data DATE DEFAULT NULL);
  PROCEDURE delete_table(p_id        IN VARCHAR2,
                         p_tablename IN VARCHAR2);

END report_pkg;
/

CREATE OR REPLACE PACKAGE BODY "REPORT_PKG"
  AS

  FUNCTION getzatraty(f_data DATE DEFAULT NULL,
                      l_data DATE DEFAULT NULL)
    RETURN tbl_zatraty
    AS
      l_datatbl tbl_zatraty := tbl_zatraty();
      p_counter NUMBER      := 0;
    BEGIN
      IF f_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_startdatmoves(f_data);
      END IF;
      IF l_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_enddatmoves(l_data);
      END IF;

      FOR i IN (SELECT *
          FROM vw_zatraty)
      LOOP
        p_counter := p_counter + 1;
        l_datatbl.EXTEND;
        l_datatbl(p_counter) := row_zatraty(i.REGISTRATOR_ID,
        i.TABLE_NAME, i.CODE, i.SUMMA, i.ZATRATY_ID, i.ZATRATY_NAME, i.DIVISION_ID, i.PERIOD);
      END LOOP;
      RETURN l_datatbl;
    END getzatraty;

  FUNCTION getsales(f_data DATE DEFAULT NULL,
                    l_data DATE DEFAULT NULL)
    RETURN tbl_sales
    AS
      l_datatbl tbl_sales := tbl_sales();
      p_counter NUMBER    := 0;
    BEGIN
      IF f_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_startdatmoves(f_data);
      END IF;
      IF l_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_enddatmoves(l_data);
      END IF;

      FOR i IN (SELECT *
          FROM vw_sales)
      LOOP
        p_counter := p_counter + 1;
        l_datatbl.EXTEND;
        l_datatbl(p_counter) := row_sales(i.ORDER_ID,
        i.KONTRAG_ID, i.PERIOD, i.DIVISION_ID, i.SALES_SUMMA, i.FACT_SEBEST_SUMMA, i.PLAN_SEBEST_SUMMA);
      END LOOP;
      RETURN l_datatbl;
    END getsales;

  FUNCTION getballans(f_data DATE DEFAULT NULL,
                      l_data DATE DEFAULT NULL)
    RETURN tbl_ballans
    AS
      l_datatbl tbl_ballans := tbl_ballans();
      p_counter NUMBER      := 0;
    BEGIN
      IF f_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_startdatmoves(f_data);
      END IF;
      IF l_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_enddatmoves(l_data);
      END IF;

      FOR i IN (SELECT *
          FROM vw_ballans_ap)
      LOOP
        p_counter := p_counter + 1;
        l_datatbl.EXTEND;
        l_datatbl(p_counter) := row_ballans(i.ID,
        i.CODE, i.FULLNAME, i.ACTIVE_START, i.ACTIVE_DEB, i.ACTIVE_KRED, i.ACTIVE_OBOROT,
        i.ACTIVE_END, i.PASSIVE_START, i.PASSIVE_DEB, i.PASSIVE_KRED, i.PASSIVE_OBOROT, i.PASSIVE_END, i.DIVISION_ID);
      END LOOP;
      RETURN l_datatbl;
    END getballans;

  FUNCTION getrating(f_data DATE DEFAULT NULL,
                     l_data DATE DEFAULT NULL)
    RETURN tbl_rating
    AS
      l_datatbl tbl_rating := tbl_rating();
      p_counter NUMBER     := 0;
    BEGIN
      IF f_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_startdatmoves(f_data);
      END IF;
      IF l_data IS NOT NULL
      THEN
        ORDERS_ENTRY.set_enddatmoves(l_data);
      END IF;

      FOR i IN (SELECT *
          FROM vw_rating)
      LOOP
        p_counter := p_counter + 1;
        l_datatbl.EXTEND;
        l_datatbl(p_counter) := row_rating(i.PLACE,
        i.DIVISION_ID, i.CNT, i.TOTAL, i.BALL_SUM, i.BALL_CNT, i.BALL_TOTAL);
      END LOOP;
      RETURN l_datatbl;
    END getrating;

  FUNCTION getreference(p_tablename IN VARCHAR2)
    RETURN tbl_reference
    AS
      l_datatbl tbl_reference := tbl_reference();
      p_counter NUMBER        := 0;
    BEGIN
      FOR i IN (SELECT DISTINCT table_name,
                                constraint_name,
                                column_name,
                                r_table_name,
                                position,
                                constraint_type
          FROM (SELECT uc.table_name,
                       uc.constraint_name,
                       cols.column_name,
                       (SELECT table_name
                           FROM user_constraints
                           WHERE constraint_name = uc.r_constraint_name) r_table_name,
                       (SELECT column_name
                           FROM user_cons_columns
                           WHERE constraint_name = uc.r_constraint_name
                             AND position = cols.position) r_column_name,
                       cols.position,
                       uc.constraint_type
              FROM user_constraints uc
                INNER JOIN user_cons_columns cols
                  ON uc.constraint_name = cols.constraint_name
              WHERE constraint_type != 'C') START WITH table_name = UPPER(p_tablename)
        AND column_name = 'ID'
        CONNECT BY NOCYCLE PRIOR table_name = r_table_name
        AND PRIOR column_name = r_column_name

          UNION
        SELECT 'KONTRAG_SETTINGS',
               NULL,
               'DIVISION_ID',
               NULL,
               NULL,
               'R'
          FROM dual

          UNION
        SELECT 'START_OST_TP',
               NULL,
               'SUBCONTO1_DEB',
               NULL,
               NULL,
               'R'
          FROM dual

          UNION
        SELECT 'START_OST_TP',
               NULL,
               'SUBCONTO2_DEB',
               NULL,
               NULL,
               'R'
          FROM dual

          UNION
        SELECT 'START_OST_TP',
               NULL,
               'SUBCONTO1_KRED',
               NULL,
               NULL,
               'R'
          FROM dual

          UNION
        SELECT 'START_OST_TP',
               NULL,
               'SUBCONTO2_KRED',
               NULL,
               NULL,
               'R'
          FROM dual)
      LOOP
        p_counter := p_counter + 1;
        l_datatbl.EXTEND;
        l_datatbl(p_counter) := row_table_reference(i.TABLE_NAME,
        i.CONSTRAINT_NAME, i.COLUMN_NAME, i.R_TABLE_NAME, i.POSITION, i.CONSTRAINT_TYPE);
      END LOOP;
      RETURN l_datatbl;
    END getreference;

  FUNCTION getreftable(p_id        IN VARCHAR2,
                       p_tablename IN VARCHAR2)
    RETURN tbl_ref_tab
    AS
      l_datatbl tbl_ref_tab := tbl_ref_tab();
      p_counter NUMBER      := 0;
      query_str VARCHAR2(2000);
      TYPE cur_typ IS REF CURSOR;
      cur       cur_typ;
      id_rel    VARCHAR2(50);
    BEGIN
      FOR i IN (SELECT *
          FROM TABLE (CAST(REPORT_PKG.GETREFERENCE(p_tablename) AS tbl_reference))
          WHERE constraint_type != 'P')
      LOOP

        query_str := 'SELECT id FROM ' || i.table_name || ' WHERE ' || i.column_name || ' = :id';
        OPEN cur FOR query_str USING p_id;
        LOOP
          FETCH cur INTO id_rel;
          EXIT WHEN cur % NOTFOUND;
          p_counter := p_counter + 1;
          l_datatbl.EXTEND;
          l_datatbl(p_counter) := ROW_REFERENCE(id_rel, p_id,
          i.TABLE_NAME, i.COLUMN_NAME, i.CONSTRAINT_TYPE);
        END LOOP;
        CLOSE cur;
      END LOOP;
      RETURN l_datatbl;
    END getreftable;

  FUNCTION get_deleted_tables
    RETURN tbl_deleted
    AS
      l_datatbl tbl_deleted   := tbl_deleted();
      p_counter NUMBER        := 0;
      query_str VARCHAR2(2000);
      p_num     VARCHAR(50);
      p_dat     DATE;
      p_ref_str VARCHAR(4000) := '';
      TYPE cur_typ IS REF CURSOR;
      cur       cur_typ;
      id_rel    VARCHAR2(50);
    BEGIN
      FOR i IN (SELECT ut.table_name,
                       UTC.COMMENTS
          FROM USER_TAB_COLUMNS ut,
               user_tab_comments utc
          WHERE ut.table_name = utc.table_name
            AND COLUMN_NAME = 'DELETED')
      LOOP
        query_str := 'SELECT id FROM ' || i.table_name || ' WHERE deleted = 1';
        OPEN cur FOR query_str;
        LOOP
          FETCH cur INTO id_rel;
          EXIT WHEN cur % NOTFOUND;
          p_ref_str := '';
          IF i.table_name = 'ORDERS'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM orders
              WHERE id = id_rel;
            p_ref_str := 'Заказ №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF i.table_name = 'OTHER_ZATRATY'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM OTHER_ZATRATY
              WHERE id = id_rel;
            p_ref_str := 'Админ.затраты №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF i.table_name = 'PKO'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM PKO
              WHERE id = id_rel;
            p_ref_str := 'ПКО №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF i.table_name = 'RKO'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM RKO
              WHERE id = id_rel;
            p_ref_str := 'РКО №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF i.table_name = 'PROFIT_DISTRIB'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM PROFIT_DISTRIB
              WHERE id = id_rel;
            p_ref_str := 'Распределение прибыли №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF i.table_name = 'START_OST'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM START_OST
              WHERE id = id_rel;
            p_ref_str := 'Нач. остатки №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF i.table_name = 'KONTRAGENTS'
          THEN
            SELECT fullname
              INTO query_str
              FROM KONTRAGENTS
              WHERE id = id_rel;
            p_ref_str := 'Контрагенты - ' || query_str;
          ELSIF i.table_name = 'ZATRATY'
          THEN
            SELECT fullname
              INTO query_str
              FROM ZATRATY
              WHERE id = id_rel;
            p_ref_str := 'Статья затрат - ' || query_str;
          ELSIF i.table_name = 'DIVISIONS'
          THEN
            SELECT fullname
              INTO query_str
              FROM DIVISIONS
              WHERE id = id_rel;
            p_ref_str := 'Филиал - ' || query_str;
          END IF;
          p_counter := p_counter + 1;
          l_datatbl.EXTEND;
          l_datatbl(p_counter) := ROW_TABLE_DELETED(id_rel, NULL,
          i.TABLE_NAME, i.comments, NULL, p_ref_str);
        END LOOP;
        CLOSE cur;
      END LOOP;
      RETURN l_datatbl;
    END get_deleted_tables;

  FUNCTION get_deletedref_tables
    RETURN tbl_deleted_ref
    AS
      l_datatbl tbl_deleted_ref := tbl_deleted_ref();
      p_counter NUMBER          := 0;
      p_num     VARCHAR(50);
      p_dat     DATE;
      p_ref_str VARCHAR(4000)   := '';
      query_str VARCHAR2(200)   := '';
    BEGIN
      FOR i IN (SELECT *
          FROM vw_tbl_deleted)
      LOOP
        FOR y IN (SELECT *
            FROM TABLE (CAST(REPORT_PKG.getreftable(i.table_id, i.table_name) AS tbl_ref_tab))
            WHERE table_name NOT IN (SELECT ut.table_name
                  FROM user_tables ut,
                       user_tab_comments utc
                  WHERE ut.table_name = UTC.TABLE_NAME
                    AND UTC.COMMENTS LIKE '%' || i.objname || '%'))
        LOOP
          p_ref_str := '';
          IF y.table_name = 'ORDERS'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM orders
              WHERE id = y.TABLE_ID;
            p_ref_str := 'Заказ №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'ORDERS_TP_NACHISL'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM orders
              WHERE id = (SELECT Order_id
                    FROM ORDERS_TP_NACHISL
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Заказ №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'ORDERS_TP_OPLATY'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM orders
              WHERE id = (SELECT Order_id
                    FROM ORDERS_TP_OPLATY
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Заказ №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'ORDERS_TP_RASHODY'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM orders
              WHERE id = (SELECT Order_id
                    FROM ORDERS_TP_RASHODY
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Заказ №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'ORDERS_TP_USLUGI'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM orders
              WHERE id = (SELECT Order_id
                    FROM ORDERS_TP_USLUGI
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Заказ №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'OTHER_ZATRATY'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM OTHER_ZATRATY
              WHERE id = y.TABLE_ID;
            p_ref_str := 'Админ.затраты №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'OTHER_ZATRATY_TAB_PART_ZATRATY'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM OTHER_ZATRATY
              WHERE id = (SELECT oth_id
                    FROM OTHER_ZATRATY_TAB_PART_ZATRATY
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Админ.затраты №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'PKO'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM PKO
              WHERE id = y.TABLE_ID;
            p_ref_str := 'ПКО №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'RKO'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM RKO
              WHERE id = y.TABLE_ID;
            p_ref_str := 'РКО №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'PROFIT_DISTRIB'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM PROFIT_DISTRIB
              WHERE id = y.TABLE_ID;
            p_ref_str := 'Распределение прибыли №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'PROFIT_DISTRIB_TP'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM PROFIT_DISTRIB
              WHERE id = (SELECT profit_ID
                    FROM PROFIT_DISTRIB_TP
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Распределение прибыли №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'START_OST'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM START_OST
              WHERE id = y.TABLE_ID;
            p_ref_str := 'Нач. остатки №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'START_OST_TP'
          THEN
            SELECT dat,
                   num
              INTO p_dat,
                   p_num
              FROM START_OST
              WHERE id = (SELECT start_ost_ID
                    FROM START_OST_TP
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Нач. остатки №' || p_num || ' от ' || TO_CHAR(p_dat, 'DD-MM-YYYY');
          ELSIF y.table_name = 'KONTRAGENTS'
          THEN
            SELECT fullname
              INTO query_str
              FROM KONTRAGENTS
              WHERE id = y.TABLE_ID;
            p_ref_str := 'Контрагенты - ' || query_str;
          ELSIF y.table_name = 'ZATRATY'
          THEN
            SELECT fullname
              INTO query_str
              FROM ZATRATY
              WHERE id = y.TABLE_ID;
            p_ref_str := 'Статья затрат - ' || query_str;
          ELSIF y.table_name = 'USER_SETTINGS'
          THEN
            SELECT LOGIN
              INTO query_str
              FROM users
              WHERE id = (SELECT user_ID
                    FROM USER_SETTINGS
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Настройки пользователя - ' || query_str;
          ELSIF y.table_name = 'KONTRAG_SETTINGS'
          THEN
            SELECT fullname
              INTO query_str
              FROM KONTRAGENTS
              WHERE id = (SELECT KONTRAG_ID
                    FROM KONTRAG_SETTINGS
                    WHERE id = y.TABLE_ID
                      AND ROWNUM = 1);
            p_ref_str := 'Настройки контрагента - ' || query_str;
          ELSIF y.table_name = 'KASSA'
          THEN
            SELECT fullname
              INTO query_str
              FROM KASSA
              WHERE id = y.TABLE_ID
                AND ROWNUM = 1;
            p_ref_str := 'Касса - ' || query_str;
          ELSIF y.table_name = 'MOVES'
          THEN
            CONTINUE;
          END IF;
          p_counter := p_counter + 1;
          l_datatbl.EXTEND;
          l_datatbl(p_counter) := ROW_TABLE_DELETED(y.TABLE_ID, i.table_id,
          y.TABLE_NAME, y.COLUMN_NAME, y.CONSTRAINT_TYPE, p_ref_str);
        END LOOP;
      END LOOP;
      RETURN l_datatbl;
    END get_deletedref_tables;

  PROCEDURE refresh_ballans(f_data DATE DEFAULT NULL,
                            l_data DATE DEFAULT NULL)
    AS
      p_f_dat DATE;
      p_l_dat DATE;
    BEGIN
      IF f_data IS NOT NULL
      THEN
        p_f_dat := f_data;
      ELSE
        p_f_dat := ORDERS_ENTRY.get_startdatmoves;
      END IF;

      IF l_data IS NOT NULL
      THEN
        p_l_dat := l_data;
      ELSE
        p_l_dat := ORDERS_ENTRY.get_enddatmoves;
      END IF;
      DELETE FROM BALLANS;
      INSERT INTO BALLANS (
        ID, CODE, FULLNAME, ACTIVE_START, ACTIVE_DEB, ACTIVE_KRED, ACTIVE_OBOROT, ACTIVE_END, PASSIVE_START, PASSIVE_DEB, PASSIVE_KRED, PASSIVE_OBOROT, PASSIVE_END, DIVISION_ID, F_DAT, l_DAT
      )
        SELECT ID,
               CODE,
               FULLNAME,
               ACTIVE_START,
               ACTIVE_DEB,
               ACTIVE_KRED,
               ACTIVE_OBOROT,
               ACTIVE_END,
               PASSIVE_START,
               PASSIVE_DEB,
               PASSIVE_KRED,
               PASSIVE_OBOROT,
               PASSIVE_END,
               DIVISION_ID,
               (SELECT p_f_dat
                   FROM dual),
               (SELECT p_l_dat
                   FROM dual)
          FROM TABLE (CAST(REPORT_PKG.GETBALLANS(f_data, l_data) AS tbl_ballans));
    END refresh_ballans;

  PROCEDURE delete_table(p_id        IN VARCHAR2,
                         p_tablename IN VARCHAR2)
    AS
      in_use    EXCEPTION;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      query_str VARCHAR2(2000) := '';
    BEGIN
      query_str := 'select * from ' || p_tablename || ' where id = :1 for update nowait';
      EXECUTE IMMEDIATE query_str
      USING '' || p_id || '';
      query_str := 'delete from ' || p_tablename || ' where id = :1';
      EXECUTE IMMEDIATE query_str
      USING '' || p_id || '';

    EXCEPTION
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Запись с Ид=' || p_id || ' таблицы ' || p_tablename || ' заблокирована!', TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Ошибка удаления записи Ид=' || p_id || ' таблицы ' || p_tablename, TRUE);
    END delete_table;

END report_pkg;

/

--
-- Описание для пакета UTILITY
--
CREATE OR REPLACE PACKAGE "UTILITY"
  AS

  FUNCTION uuid
    RETURN VARCHAR2;
  FUNCTION md5(str IN VARCHAR2)
    RETURN VARCHAR2;
  PROCEDURE clear_base;
  PROCEDURE get_acc_plan_xml;
  PROCEDURE set_acc_plan;
  PROCEDURE first_start;
  PROCEDURE enable_constraint;
  PROCEDURE disable_constraint;
  FUNCTION retrieve_customer_parentid
    RETURN VARCHAR2;
  FUNCTION retrieve_customer_parentname
    RETURN VARCHAR2;
  PROCEDURE add_kontragent_to_call_list(p_kontrag_id  IN VARCHAR2,
                                        p_compaign_id IN VARCHAR2);
  PROCEDURE rem_kontragent_from_call_list(p_kontrag_id IN VARCHAR2);
  FUNCTION retrieve_division_parentid
    RETURN VARCHAR2;
  PROCEDURE change_parent_in_division(p_id        IN VARCHAR2,
                                      p_parent_id IN VARCHAR2);
  PROCEDURE add_user_to_group(p_user  IN VARCHAR2,
                              p_group IN VARCHAR2);
  FUNCTION retrieve_zamer_parentid
    RETURN VARCHAR2;
  FUNCTION retrieve_supplier_parentid
    RETURN VARCHAR2;
  FUNCTION retrieve_other_parentid
    RETURN VARCHAR2;
  FUNCTION retrieve_name_baseofcalc(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION retrieve_idfix_baseofcalc
    RETURN VARCHAR2;
  FUNCTION retrieve_idfromalgorythm(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION retrieve_name_basenachisl(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  PROCEDURE createKontrag(p_name    IN VARCHAR2,
                          p_user_id IN VARCHAR2,
                          p_isSupp  IN NUMBER,
                          p_isMeasr IN NUMBER,
                          p_isByer  IN NUMBER);
  FUNCTION createByer(p_name    IN VARCHAR2,
                      p_user_id IN VARCHAR2,
                      p_contact IN VARCHAR2,
                      p_phone   IN VARCHAR2,
                      p_mail    IN VARCHAR2)
    RETURN VARCHAR2;
  PROCEDURE createZatraty(p_name IN VARCHAR2);
  FUNCTION enable_edit(p_id   IN VARCHAR2,
                       p_type IN VARCHAR2)
    RETURN NUMBER;
  PROCEDURE set_disable_edit_profit(p_date IN DATE);
  FUNCTION user_exists(p_login IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION access_enabled(p_login IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION generate_code(p_login IN VARCHAR2,
                         p_date  IN DATE)
    RETURN VARCHAR2;
  PROCEDURE accept_code(p_login IN VARCHAR2,
                        p_code  IN VARCHAR2);
  FUNCTION order_payed_percent(p_order IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION ballans_by_kontr(p_id   IN VARCHAR2,
                            p_code IN VARCHAR2,
                            p_dat  IN DATE DEFAULT sysdate)
    RETURN NUMBER;

END utility;
/

CREATE OR REPLACE PACKAGE BODY "UTILITY"
  AS

  FUNCTION uuid
    RETURN VARCHAR2
    AS
    LANGUAGE JAVA
    NAME 'RandomUUID.create() return java.lang.String';
  --end uuid;

  FUNCTION md5(str IN VARCHAR2)
    RETURN VARCHAR2
    AS
      v_checksum VARCHAR2(36);

    BEGIN
      v_checksum := LOWER(RAWTOHEX(UTL_RAW.CAST_TO_RAW(sys.dbms_obfuscation_toolkit.md5(input_string => str))));
      RETURN v_checksum;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN NULL;
      WHEN OTHERS THEN
          -- Consider logging the error and then re-raise
          RAISE;
    END md5;

  PROCEDURE clear_base
    AS --Очистка базы
    BEGIN

      FOR c1 IN (SELECT y.table_name,
                        y.constraint_name
          FROM user_constraints y,
               user_tables x
          WHERE x.table_name = y.TABLE_NAME
            AND y.CONSTRAINT_TYPE = 'R')
      LOOP
        BEGIN
          EXECUTE IMMEDIATE ('alter table ' || c1.table_name || ' disable constraint ' || c1.constraint_name || ' cascade');
        END;
      END LOOP;

      FOR t1 IN (SELECT table_name
          FROM user_tables)
      LOOP
        BEGIN
          EXECUTE IMMEDIATE ('truncate table ' || t1.table_name);
        END;
      END LOOP;

      FOR c2 IN (SELECT y.table_name,
                        y.constraint_name
          FROM user_constraints y,
               user_tables x
          WHERE x.table_name = y.TABLE_NAME
            AND y.CONSTRAINT_TYPE = 'R')
      LOOP
        BEGIN
          EXECUTE IMMEDIATE ('alter table ' || c2.table_name || ' enable constraint ' || c2.constraint_name);
        END;
      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN
          -- Consider logging the error and then re-raise
          RAISE;
    END;

  PROCEDURE get_acc_plan_xml
    AS
      host      VARCHAR2(100 CHAR) := 'bmexp.com';
      port      VARCHAR2(2 CHAR)   := 21;
      user_f    VARCHAR2(100 CHAR) := 'toftpconnect';
      pass      VARCHAR2(100 CHAR) := 'vjqangghjcnjzlkjdsqcwerj';
      l_conn    UTL_TCP.connection;
      clobdata  CLOB;
      count_xml NUMBER;
    BEGIN
      SELECT COUNT(*)
        INTO count_xml
        FROM XML_T;
      l_conn := ftp.login(host, port, user_f, pass, 60);
      ftp.ascii(p_conn => l_conn);
      clobdata := ftp.get_remote_ascii_data(p_conn => l_conn,
      p_file => '/acc_plan/acc_plan_bud.xml');
      IF CLOBDATA IS NOT NULL
      THEN
        IF count_xml = 0
        THEN
          INSERT INTO XML_T (
            ONE
          )
          VALUES (xmltype(CLOBDATA));
        ELSE
          UPDATE XML_T
            SET ONE = xmltype(CLOBDATA)
            WHERE id = (SELECT MAX(id)
                FROM xml_t);
        END IF;
      END IF;
      ftp.logout(l_conn);

    EXCEPTION
      WHEN OTHERS THEN
          -- Consider logging the error and then re-raise
          RAISE;
    END;

  PROCEDURE set_acc_plan
    AS
    BEGIN
      get_acc_plan_xml();
      --План счетов
      INSERT INTO plan_acc (
        id, acc_type, parent_id, fullname, zabalansov, valutn, kolishestv, code
      )
        SELECT;
--Субконто плана счетов   

INSERT INTO plan_acc_subconto (
  plan_acc_id, plan_type_subc, oborot_only, summovoy
)
  SELECT * from (
SELECT
  
  EXCEPTION
    WHEN OTHERS THEN
			-- Consider logging the error and then re-raise
			RAISE;      
  end;
  
  procedure first_start as --Первый запуск базы
  p_uid varchar2(50);
  fs number(5);
BEGIN
  SELECT NVL(COUNT(*), 0)
    INTO fs
    FROM users;
  IF fs <> 0
  THEN
    RETURN;
  END IF;
  --Заполнение типов данных
  INSERT INTO type_def (
    table_name
  )
    SELECT table_name
      FROM user_tables;
  --Заполнение справочника субконто
  INSERT INTO plan_type_subconto (
    type_of_obj, fullname
  )
    SELECT id,
           CASE WHEN UPPER(table_name) = UPPER('kontragents') THEN 'Контрагенты' WHEN UPPER(table_name) = UPPER('kassa') THEN 'Касса' WHEN UPPER(table_name) = UPPER('zatraty') THEN 'Статья затрат' WHEN UPPER(table_name) = UPPER('nomenklatura') THEN 'Номенклатура' WHEN UPPER(table_name) = UPPER('divisions') THEN 'ЦФО' END fullname
      FROM type_def
      WHERE UPPER(table_name) = UPPER('kontragents')
        OR UPPER(table_name) = UPPER('nomenklatura')
        OR UPPER(table_name) = UPPER('kassa')
        OR UPPER(table_name) = UPPER('zatraty')
        OR UPPER(table_name) = UPPER('divisions');

  --Заполнение типов счетов    
  INSERT INTO enum_account_type (
    fullname
  )
  VALUES ('Активный');
  INSERT INTO enum_account_type (
    fullname
  )
  VALUES ('Пассивный');
  INSERT INTO enum_account_type (
    fullname
  )
  VALUES ('Активный/Пассивный');
  --Заполнение плана счетов    
  set_acc_plan();

  --Инициализация нумератора документов
  INSERT INTO numerator (
    typedef_id, prefix
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(table_name) = UPPER('orders')), 'OR-');
  INSERT INTO numerator (
    typedef_id, prefix
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(table_name) = UPPER('other_zatraty')), 'OR-');
  INSERT INTO numerator (
    typedef_id, prefix
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(table_name) = UPPER('pko')), 'OR-');
  INSERT INTO numerator (
    typedef_id, prefix
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(table_name) = UPPER('rko')), 'OR-');
  INSERT INTO numerator (
    typedef_id, prefix
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(table_name) = UPPER('start_ost')), 'OR-');
  INSERT INTO numerator (
    typedef_id, prefix
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(table_name) = UPPER('profit_distrib')), 'OR-');

  --Справочник единиц измерений
  INSERT INTO measure_unit (
    fullname, code
  )
  VALUES ('шт', '796');
  INSERT INTO measure_unit (
    fullname, code
  )
  VALUES ('кг', '166');
  INSERT INTO measure_unit (
    fullname, code
  )
  VALUES ('услуга', '808');
  INSERT INTO measure_unit (
    fullname, code
  )
  VALUES ('м', '006');

  --Справочник пользователей, пользователь-администратор
  INSERT INTO users (
    first_name, last_name, email, is_admin, login, pass_wd, predefined
  )
  VALUES ('Viacheslav', 'Bakum', 'bakum@bmexp.com', 1, 'sysdba', '1', 1);

  --Справочник валют  
  INSERT INTO currency (
    code, fullname, namefull, predefined, id_xml
  )
  VALUES ('980', 'грн', 'Гривна', 1, '0');

  SELECT uuid()
    INTO p_uid
    FROM dual;
  INSERT INTO currency (
    id, code, fullname, namefull, predefined, id_xml
  )
  VALUES (p_uid, '840', 'usd', 'USD', 0, '6');
  INSERT INTO ex_rates_settings (
    curr_id
  )
  VALUES (p_uid);

  SELECT uuid()
    INTO p_uid
    FROM dual;
  INSERT INTO currency (
    id, code, fullname, namefull, predefined, id_xml
  )
  VALUES (p_uid, '978', 'EUR', 'Евро', 0, '8');
  INSERT INTO ex_rates_settings (
    curr_id
  )
  VALUES (p_uid);

  SELECT uuid()
    INTO p_uid
    FROM dual;
  INSERT INTO currency (
    id, code, fullname, namefull, predefined, id_xml
  )
  VALUES (p_uid, '643', 'RUB', 'Рубль', 0, '17');
  INSERT INTO ex_rates_settings (
    curr_id
  )
  VALUES (p_uid);

  --Справочник подразделений
  INSERT INTO divisions (
    fullname, is_group, predefined
  )
  VALUES ('Филиалы', 1, 1);
  INSERT INTO divisions (
    fullname, parent_id, is_group
  )
  VALUES ('Украина', (SELECT id FROM divisions WHERE fullname = 'Филиалы'), 1);

  --Справочник номенклатуры  
  INSERT INTO nomenklatura (
    fullname, is_group, usluga, predefined
  )
  VALUES ('Номенклатура', 1, 0, 1);
  INSERT INTO nomenklatura (
    fullname, is_group, parent_id, usluga, predefined
  )
  VALUES ('Услуги', 1, (SELECT id FROM nomenklatura WHERE fullname = 'Номенклатура'), 0, 0);

  --Справочник организаций  
  INSERT INTO firms (
    fullname, printname, ur_fiz
  )
  VALUES ('Организация', 'Моя организация', 1);

  --Справочник контрагентов
  INSERT INTO kontragents (
    fullname, is_group, predefined
  )
  VALUES ('Контрагенты', 1, 1);
  INSERT INTO kontragents (
    fullname, is_group, parent_id, predefined
  )
  VALUES ('Поставщики', 1, (SELECT id FROM kontragents WHERE fullname = 'Контрагенты'), 1);
  INSERT INTO kontragents (
    fullname, is_group, parent_id, predefined
  )
  VALUES ('Покупатели', 1, (SELECT id FROM kontragents WHERE fullname = 'Контрагенты'), 1);
  INSERT INTO kontragents (
    fullname, is_group, parent_id, predefined
  )
  VALUES ('Замерщики', 1, (SELECT id FROM kontragents WHERE fullname = 'Контрагенты'), 1);
  INSERT INTO kontragents (
    fullname, is_group, parent_id, predefined
  )
  VALUES ('Прорабы', 1, (SELECT id FROM kontragents WHERE fullname = 'Контрагенты'), 1);
  INSERT INTO kontragents (
    fullname, is_group, parent_id, predefined
  )
  VALUES ('Прочие', 1, (SELECT id FROM kontragents WHERE fullname = 'Контрагенты'), 1);

  --Перечисление базы расчетов  
  INSERT INTO BASE_OF_CALC (
    name, fullname
  )
  VALUES ('Процент', 'Процент');
  INSERT INTO BASE_OF_CALC (
    name, fullname
  )
  VALUES ('ФиксированнойСуммой', 'Фиксированной суммой');

  --Виды деятельности
  INSERT INTO type_of_activities (
    fullname
  )
  VALUES ('Юриспруденция');
  INSERT INTO type_of_activities (
    fullname
  )
  VALUES ('Окна');
  INSERT INTO type_of_activities (
    fullname
  )
  VALUES ('Мебель');

  --Статусы заказа
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('ВРаботе', 'В работе');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('ВРасчете', 'В расчёте');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('Выполнен', 'Выполнен');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('Замер', 'Замер');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('Новый', 'Новый');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('Закрыт', 'Закрыт');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('Аннулирован', 'Аннулирован');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('НеОплачен', 'Не оплачен');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('Отказ', 'Отказ');
  INSERT INTO ORDER_STATUS (
    name, fullname
  )
  VALUES ('Контроль', 'Контроль');

  --Статусы звонков 
  INSERT INTO CALL_STATUS (
    name, fullname
  )
  VALUES ('New', 'Новый');
  INSERT INTO CALL_STATUS (
    name, fullname
  )
  VALUES ('Pending', 'В ожидании');
  INSERT INTO CALL_STATUS (
    name, fullname
  )
  VALUES ('FailedSubmit', 'Неудачный');

  --Статусы результата звонков
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('Sales', 'Продажа');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('WrongNumber', 'Неверный номер');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('InvalidNumber', 'Недействительный номер');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('Voicemail', 'Голосовая почта');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('PowerOff', 'Номер отключен');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('NoAnswer', 'Нет ответа');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('SendFax', 'Отправить факс');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('SendMail', 'Отправить почту');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('Success', 'Успешно');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('Fail', 'Неудача');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('AnswerMachine', 'Автоответчик');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('DontCallAgain', 'Больше не звонить');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('NotInterested', 'Не интересует');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('CallLater', 'Перезвонить позже');
  INSERT INTO CALL_RESULTS (
    name, fullname
  )
  VALUES ('Measuring', 'Вызов на замер');

  --Виды операций ПКО    
  INSERT INTO OPERATION_PKO (
    NAME, FULLNAME
  )
  VALUES ('OTHER_PAYMENT', 'Прочие приходы денежных средств');
  INSERT INTO OPERATION_PKO (
    NAME, FULLNAME
  )
  VALUES ('FROM_BUYER', 'Оплата от покупателя');
  INSERT INTO OPERATION_PKO (
    NAME, FULLNAME
  )
  VALUES ('RETURN_SUPPLIER', 'Возврат от поставщика');

  --Виды операций РКО    
  INSERT INTO OPERATION_RKO (
    NAME, FULLNAME
  )
  VALUES ('OTHER_PAYMENT', 'Прочий расход денежных средств');
  INSERT INTO OPERATION_RKO (
    NAME, FULLNAME
  )
  VALUES ('PAYMENT_SUPPLIER', 'Оплата поставщику');
  INSERT INTO OPERATION_RKO (
    NAME, FULLNAME
  )
  VALUES ('RETURN_BUYER', 'Возврат покупателю');
  INSERT INTO OPERATION_RKO (
    NAME, FULLNAME
  )
  VALUES ('MOVE_KASSA', 'Перемещение между кассами');


  --Кампании (колл-листы) по-умолчанию
  INSERT INTO COMPAIGNS (
    name, PREDEFINED
  )
  VALUES ('hot', 1);
  INSERT INTO COMPAIGNS (
    name, PREDEFINED
  )
  VALUES ('cold', 1);

  --Настройки начислений по-умолчанию   
  INSERT INTO PAY_SETTINGS (
    name, fullname, stavka, base_id
  )
  VALUES ('NET', 'Сетевые', 2.68, (SELECT id FROM BASE_OF_CALC WHERE UPPER(name) LIKE UPPER('Процент')));
  INSERT INTO PAY_SETTINGS (
    name, fullname, stavka, base_id
  )
  VALUES ('ZAMER', 'Комиссия земерщику', 3, (SELECT id FROM BASE_OF_CALC WHERE UPPER(name) LIKE UPPER('Процент')));
  INSERT INTO PAY_SETTINGS (
    name, fullname, stavka, base_id
  )
  VALUES ('OFFICE', 'Офисные', 14, (SELECT id FROM BASE_OF_CALC WHERE UPPER(name) LIKE UPPER('Процент')));

  --База расчетов для начислений 
  INSERT INTO DBA_DIVAS.BASE_OF_NACHISL (
    NAME, FULLNAME
  )
  VALUES ('IERARHIA', 'В иерархии');
  INSERT INTO DBA_DIVAS.BASE_OF_NACHISL (
    NAME, FULLNAME
  )
  VALUES ('ORDER', 'По заказу');
  INSERT INTO DBA_DIVAS.BASE_OF_NACHISL (
    NAME, FULLNAME
  )
  VALUES ('DIV', 'По подразделению');

  --Проводки для заказа
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '20711'), (SELECT id FROM plan_acc WHERE code = '600'), 1, 'Проводка ТЧ Услуги - Выполнили работы');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '2081'), (SELECT id FROM plan_acc WHERE code = '20711'), 2, 'Проводка ТЧ Оплаты - Получили предоплату');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '5091'), (SELECT id FROM plan_acc WHERE code = '2081'), 3, 'Проводка ТЧ Оплаты - Замерщик взял деньги');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '80213'), (SELECT id FROM plan_acc WHERE code = '2081'), 4, 'Проводка ТЧ Расходы - РКО на себестоимость');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '701'), (SELECT id FROM plan_acc WHERE code = '80213'), 5, 'Проводка ТЧ Расходы - Закрытие себестоимости заказа после выполнения');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '701'), (SELECT id FROM plan_acc WHERE code = '5091'), 6, 'Проводка ТЧ Начисления - Начисления на себестоимость (комиссия и т.д.)');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '600'), (SELECT id FROM plan_acc WHERE code = '701'), 7, 'Закрытие заказа - выполнен!');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('orders')), (SELECT id FROM plan_acc WHERE code = '600'), (SELECT id FROM plan_acc WHERE code = '900'), 8, 'Заказ выполнен - Отнесение маржи на финансовый результат');

  --Проводки для Прочих затрат           
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('OTHER_ZATRATY')), (SELECT id FROM plan_acc WHERE code = '80212'), (SELECT id FROM plan_acc WHERE code = '2081'), 1, 'Проводка ТЧ Затраты - Списание на административные затраты');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('OTHER_ZATRATY')), (SELECT id FROM plan_acc WHERE code = '900'), (SELECT id FROM plan_acc WHERE code = '80212'), 2, 'Проводка ТЧ Затраты - Списание на затрат на финансовый результат');

  --Проводки для ПКО             
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('PKO')), (SELECT id FROM plan_acc WHERE code = '2081'), (SELECT id FROM plan_acc WHERE code = '000'), 1, 'ПКО - Прочие приходы денежных средств');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('PKO')), (SELECT id FROM plan_acc WHERE code = '2081'), (SELECT id FROM plan_acc WHERE code = '20711'), 2, 'ПКО - Оплата от покупателя');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('PKO')), (SELECT id FROM plan_acc WHERE code = '2081'), (SELECT id FROM plan_acc WHERE code = '5091'), 3, 'ПКО - Возврат от поставщика');

  --Проводки для РКО             
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('RKO')), (SELECT id FROM plan_acc WHERE code = '000'), (SELECT id FROM plan_acc WHERE code = '2081'), 1, 'РКО - Прочий расход денежных средств');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('RKO')), (SELECT id FROM plan_acc WHERE code = '5091'), (SELECT id FROM plan_acc WHERE code = '2081'), 2, 'РКО - Оплата поставщику');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('RKO')), (SELECT id FROM plan_acc WHERE code = '20711'), (SELECT id FROM plan_acc WHERE code = '2081'), 3, 'РКО - Возврат покупателю');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('RKO')), (SELECT id FROM plan_acc WHERE code = '2081'), (SELECT id FROM plan_acc WHERE code = '2081'), 4, 'РКО - Перемещение между кассами');

  --Проводки для PROFIT_DISTRIB (распределение прибыли)
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('PROFIT_DISTRIB')), (SELECT id FROM plan_acc WHERE code = '900'), (SELECT id FROM plan_acc WHERE code = '5091'), 1, 'PROFIT - Распределение прибыли');
  INSERT INTO entry_settings (
    typedef_id, plan_acc_deb_id, plan_acc_kred_id, chain, description
  )
  VALUES ((SELECT id FROM type_def WHERE UPPER(type_def.table_name) = UPPER('PROFIT_DISTRIB')), (SELECT id FROM plan_acc WHERE code = '900'), (SELECT id FROM plan_acc WHERE code = '900'), 2, 'PROFIT - Переброс прибыли на головное подразделение');


EXCEPTION
  WHEN OTHERS THEN
      -- Consider logging the error and then re-raise
      RAISE;
END;
  
  procedure enable_constraint as
BEGIN
  FOR c2 IN (SELECT y.table_name,
                    y.constraint_name
      FROM user_constraints y,
           user_tables x
      WHERE x.table_name = y.table_name)
  LOOP
    BEGIN
      EXECUTE IMMEDIATE ('alter table ' || c2.table_name || ' enable constraint ' || c2.constraint_name);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
      -- Consider logging the error and then re-raise
      RAISE;
END;
  
  procedure disable_constraint as
BEGIN
  FOR c2 IN (SELECT y.table_name,
                    y.constraint_name
      FROM user_constraints y,
           user_tables x
      WHERE x.table_name = y.table_name)
  LOOP
    BEGIN
      EXECUTE IMMEDIATE ('alter table ' || c2.table_name || ' disable constraint ' || c2.constraint_name);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
      -- Consider logging the error and then re-raise
      RAISE;
END;
  
  function retrieve_customer_parentid return varchar2
  as v_return VARCHAR2(36);
BEGIN
  SELECT id
    INTO v_return
    FROM kontragents
    WHERE UPPER(fullname) = UPPER('Покупатели');
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  function retrieve_customer_parentname return varchar2
  as v_return VARCHAR2(150);
BEGIN
  SELECT fullname
    INTO v_return
    FROM kontragents
    WHERE UPPER(fullname) = UPPER('Покупатели');
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  procedure add_kontragent_to_call_list(p_kontrag_id in varchar2, p_compaign_id in varchar2)
  as
BEGIN
  FOR i IN (SELECT *
      FROM contact_details
      WHERE kontrag_id = p_kontrag_id)
  LOOP
    INSERT INTO COMPAIGNS_DETAILS (
      compaign_id, kontrag_id, contact_id
    )
    VALUES (p_compaign_id, p_kontrag_id, i.id);
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN RAISE;
END;
  
  procedure rem_kontragent_from_call_list(p_kontrag_id in varchar2)
  as
  cl_rec compaigns_details%rowtype;
BEGIN
  SELECT *
    INTO cl_rec
    FROM compaigns_details
    WHERE id = p_kontrag_id FOR UPDATE;
  DELETE FROM compaigns_details
    WHERE id = p_kontrag_id;
EXCEPTION
  WHEN OTHERS THEN RAISE;
END;
  
  function retrieve_division_parentid return varchar2
  as v_return VARCHAR2(36);
BEGIN
  SELECT id
    INTO v_return
    FROM DIVISIONS
    WHERE parent_id IS NULL
      AND is_group = 1;
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  procedure change_parent_in_division(p_id in varchar2, p_parent_id in varchar2)
  as
  div_rec divisions%rowtype;
BEGIN
  SELECT *
    INTO div_rec
    FROM divisions
    WHERE id = p_id FOR UPDATE;
  div_rec.parent_id := p_parent_id;
  UPDATE divisions
    SET ROW = div_rec
    WHERE id = p_id;
EXCEPTION
  WHEN OTHERS THEN RAISE;
END;
  
  procedure add_user_to_group(p_user in varchar2, p_group in varchar2)
  as
BEGIN
  INSERT INTO groupmembers (
    g_name, g_member
  )
  VALUES (p_group, p_user);
EXCEPTION
  WHEN OTHERS THEN RAISE;
END;
  
  function retrieve_zamer_parentid return varchar2
  as v_return VARCHAR2(36);
BEGIN
  SELECT id
    INTO v_return
    FROM kontragents
    WHERE UPPER(fullname) = UPPER('Замерщики');
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  function retrieve_supplier_parentid return varchar2
  as v_return VARCHAR2(36);
BEGIN
  SELECT id
    INTO v_return
    FROM kontragents
    WHERE UPPER(fullname) = UPPER('Прорабы');
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  function retrieve_other_parentid return varchar2
  as v_return VARCHAR2(36);
BEGIN
  SELECT id
    INTO v_return
    FROM kontragents
    WHERE UPPER(fullname) = UPPER('Прочие');
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  function retrieve_name_baseofcalc(p_id in varchar2) return varchar2
  as v_return VARCHAR2(100);
BEGIN
  SELECT b.name
    INTO v_return
    FROM BASE_OF_CALC b
    WHERE UPPER(b.id) = UPPER(p_id);
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  function retrieve_idfix_baseofcalc return varchar2
  as v_return VARCHAR2(50);
BEGIN
  SELECT b.id
    INTO v_return
    FROM BASE_OF_CALC b
    WHERE UPPER(b.name) LIKE UPPER('ФиксированнойСуммой');
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  function retrieve_idfromalgorythm(p_id in varchar2) return varchar2
  as v_return VARCHAR2(100);
BEGIN
  SELECT b.base_id
    INTO v_return
    FROM PAY_SETTINGS b
    WHERE UPPER(b.id) = UPPER(p_id);
  RETURN v_return;
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  function retrieve_name_basenachisl(p_id in varchar2) return varchar2
  as v_return VARCHAR2(100);
BEGIN
  SELECT b.name
    INTO v_return
    FROM BASE_OF_NACHISL b
    WHERE UPPER(b.id) = UPPER(p_id);
  RETURN UPPER(v_return);
EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END;
  
  procedure createKontrag(p_name in varchar2, p_user_id in varchar2,
            p_isSupp in number, p_isMeasr in number , p_isByer in number) as
  p_parent varchar2(100);
BEGIN
  IF p_isSupp = 1
  THEN
    p_parent := retrieve_supplier_parentid();
  END IF;
  IF p_isMeasr = 1
  THEN
    p_parent := retrieve_zamer_parentid();
  END IF;
  IF p_isByer = 1
  THEN
    p_parent := retrieve_customer_parentid();
  ELSE
    p_parent := retrieve_other_parentid();
  END IF;
  INSERT INTO kontragents (
    is_group, parent_id, fullname, deleted, is_supplier, is_buyer, is_measurer, user_id
  )
  VALUES (0, p_parent, p_name, 0, p_isSupp, p_isByer, p_isMeasr, p_user_id);
END;
  
  function createByer(p_name in varchar2, p_user_id in varchar2,
            p_contact in varchar2, p_phone in varchar2 , p_mail in varchar2) return varchar2 as
  p_parent varchar2(100);
  p_uuid varchar2(100);
  p_count number:=0;
  pp_name varchar2(1000);
BEGIN
  SELECT COUNT(*)
    INTO p_count
    FROM kontragents
    WHERE UPPER(fullname) LIKE UPPER(p_name || '%');
  IF p_count IS NOT NULL
  THEN
    IF p_count > 0
    THEN
      pp_name := p_name || '_' || p_count;
    ELSE
      pp_name := p_name;
    END IF;
  END IF;
  p_parent := retrieve_customer_parentid();
  p_uuid := uuid();
  INSERT INTO kontragents (
    id, is_group, parent_id, fullname, deleted, is_supplier, is_buyer, is_measurer, user_id
  )
  VALUES (p_uuid, 0, p_parent, pp_name, 0, 0, 1, 0, p_user_id);

  INSERT INTO contact_details (
    kontrag_id, adress, phone, email
  )
  VALUES (p_uuid, p_Contact, p_phone, p_mail);
  RETURN p_uuid;
END;

  procedure createZatraty(p_name in varchar2) as
  p_zrecord zatraty%rowtype;
BEGIN
  p_zrecord.is_Group := 0;
  p_zrecord.deleted := 0;
  p_zrecord.fullname := p_name;
  p_zrecord.version := systimestamp;
  p_zrecord.predefined := 0;
  INSERT INTO zatraty
  VALUES p_zrecord;
END;
  
  --'1' - разрешено редактирование; '0' - не разрешено
  function enable_edit_all(p_date in date) return number as
  p_dat_sett date;
BEGIN
  SELECT DATE_AFTER
    INTO p_dat_sett
    FROM PROG_SETTINGS
    WHERE ROWNUM = 1;
  IF TRUNC(p_dat_sett) >= TRUNC(p_date)
  THEN
    RETURN 0;
  ELSE
    RETURN 1;
  END IF;

EXCEPTION
  WHEN OTHERS THEN RETURN 1;
END enable_edit_all;
  
  --'1' - разрешено редактирование; '0' - не разрешено
  function enable_edit_profit(p_date in date) return number as
  p_dat_sett date;
BEGIN
  SELECT DATE_AFTER_PROFIT
    INTO p_dat_sett
    FROM PROG_SETTINGS
    WHERE ROWNUM = 1;
  IF TRUNC(p_dat_sett) >= TRUNC(p_date)
  THEN
    RETURN 0;
  ELSE
    RETURN 1;
  END IF;

EXCEPTION
  WHEN OTHERS THEN RETURN 1;
END enable_edit_profit;
  
  function get_date_profit return date as
  p_dat_sett date;
BEGIN
  SELECT DATE_AFTER_PROFIT
    INTO p_dat_sett
    FROM PROG_SETTINGS
    WHERE ROWNUM = 1;
  RETURN p_dat_sett;

EXCEPTION
  WHEN OTHERS THEN RETURN TO_DATE('01-01-1970 00:00:00', 'DD-MM-YYYY HH24:MI:SS');
END;

  --'1' - разрешено редактирование; '0' - не разрешено
  function enable_edit(p_id in varchar2, p_type in varchar2) return number as
  p_dat_sett date;
  p_dat_after date;
  p_flag number:=1;
BEGIN
  EXECUTE IMMEDIATE ('select dat from ' || p_type || ' where id=''' || p_id || '''')
    INTO p_dat_sett;
  IF enable_edit_all(p_dat_sett) = 0
  THEN
    RETURN 0;
  END IF;

  IF UPPER(p_type) = 'ORDERS'
    OR UPPER(p_type) = 'OTHER_ZATRATY'
    OR UPPER(p_type) = 'START_OST'
  THEN
    IF enable_edit_profit(p_dat_sett) = 0
    THEN
      IF UPPER(p_type) = 'ORDERS'
      THEN
        p_dat_after := get_date_profit();
        FOR i IN (SELECT *
            FROM orders
            WHERE id = p_id
              AND status_id IN (SELECT id
                  FROM order_status
                  WHERE name IN (
                    'Аннулирован', 'Закрыт', 'Выполнен', 'Отказ'))
              AND TRUNC(dat_complete_fact) < TRUNC(p_dat_after))
        LOOP
          p_flag := 0;
        END LOOP;
        RETURN p_flag;
      ELSE
        RETURN 0;
      END IF;
    END IF;
  END IF;

  RETURN 1;

EXCEPTION
  WHEN OTHERS THEN RETURN 1;
END enable_edit;
  
  procedure set_disable_edit_profit(p_date in date) as
  p_prog_sett prog_settings%rowtype;
BEGIN
  FOR i IN (SELECT *
      FROM prog_settings
      WHERE ROWNUM = 1)
  LOOP
    i.date_after_profit := p_date;
    UPDATE prog_settings
      SET ROW = i
      WHERE id = i.id;
    RETURN;
  END LOOP;

  p_prog_sett.date_after_profit := p_date;
  INSERT INTO prog_settings
  VALUES p_prog_sett;
END set_disable_edit_profit;
  
  function user_exists(p_login in varchar2) return varchar2 as
BEGIN
  FOR i IN (SELECT *
      FROM users
      WHERE UPPER(login) = UPPER(p_login)
        AND is_active = 1
        AND ROWNUM = 1)
  LOOP
    RETURN '1';
  END LOOP;
  RETURN '0';
END user_exists;
  
  function access_enabled(p_login in varchar2) return varchar2 as
  user_rec users%rowtype;
BEGIN
  SELECT *
    INTO user_rec
    FROM users
    WHERE UPPER(login) = UPPER(p_login)
      AND ROWNUM = 1;
  IF user_rec.is_admin = 1
  THEN
    RETURN '1';
  END IF;

  IF user_rec.DATE_BEFORE IS NULL
  THEN
    RETURN '0';
  ELSIF user_rec.DATE_BEFIRE_ACCEPT = 0
  THEN
    RETURN '0';
  END IF;

  IF TRUNC(user_rec.DATE_BEFORE) >= TRUNC(sysdate)
  THEN
    RETURN '1';
  ELSE
    RETURN '0';
  END IF;

END access_enabled;
  
  function generate_code(p_login in varchar2, p_date in date) return varchar2 as
  p_code varchar2(100);
BEGIN
  SELECT ORA_HASH(TO_NUMBER(TO_CHAR(p_date, 'ddMMYYYY')) || p_login)
    INTO p_code
    FROM dual;
  RETURN p_code;
END generate_code;
  
  procedure accept_code(p_login in varchar2, p_code in varchar2) as
  code_corrupted EXCEPTION;
  date_is_empty EXCEPTION;
  code_allreadyuse EXCEPTION;
  user_rec users%rowtype;
  pp_code varchar2(100);
BEGIN
  SELECT *
    INTO user_rec
    FROM users
    WHERE UPPER(login) = UPPER(p_login)
      AND ROWNUM = 1
  FOR UPDATE NOWAIT;
  IF user_rec.date_before IS NULL
  THEN
    RAISE date_is_empty;
  END IF;
  pp_code := generate_code(p_login, user_rec.date_before);
  IF p_code != pp_code
  THEN
    RAISE code_corrupted;
  END IF;

  IF user_rec.DATE_BEFIRE_ACCEPT = 1
  THEN
    RAISE code_allreadyuse;
  END IF;

  user_rec.DATE_BEFIRE_ACCEPT := 1;
  UPDATE users
    SET ROW = user_rec
    WHERE id = user_rec.id;

EXCEPTION
  WHEN code_corrupted THEN RAISE_APPLICATION_ERROR(-20002, 'Ошибка валидации кода!', TRUE);
  WHEN code_allreadyuse THEN RAISE_APPLICATION_ERROR(-20004, 'Код уже используется Валидация не возможна!', TRUE);
  WHEN date_is_empty THEN RAISE_APPLICATION_ERROR(-20003, 'Код не может быть подтвержден! Проверьте дату валидации', TRUE);
  WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Неожиданная ошибка! ' || SQLERRM, TRUE);
END accept_code;
  
  function getSummOrder(p_order in varchar2) return number as
  res number;
  addwork number;
BEGIN
  SELECT SUM(summ)
    INTO res
    FROM orders_tp_uslugi
    WHERE order_id = p_order;
  SELECT SUM(price_add)
    INTO addwork
    FROM orders_tp_uslugi
    WHERE order_id = p_order;
  RETURN NVL(res, 0) + NVL(addwork, 0);
END getSummOrder;
  
  function getSummOplata(p_order in varchar2) return number as
  res number;
BEGIN
  SELECT SUM(otp.sum)
    INTO res
    FROM orders_tp_oplaty otp
    WHERE order_id = p_order;
  RETURN NVL(res, 0);
END getSummOplata;
  
  function order_payed_percent(p_order in varchar2) return varchar2
  as
  summ number:=0;
  summ_opl number:=0;
BEGIN
  summ := getSummOrder(p_order);
  summ_opl := getSummOplata(p_order);
  IF (summ = 0
    OR summ_opl = 0)
  THEN
    RETURN 'Не оплачен';
  END IF;
  RETURN TO_CHAR(100 * summ_opl / summ, '9990.99') || '%';

EXCEPTION
  WHEN OTHERS THEN RETURN 'Не оплачен';
END order_payed_percent;
  
  function ballans_by_kontr(p_id in varchar2, p_code in varchar2, p_dat in date default sysdate) return number as
  res number;
BEGIN
  ORDERS_ENTRY.SET_ENDDATMOVES(p_dat);
  SELECT ballans
    INTO res
    FROM ballans_by_kontrag
    WHERE code LIKE p_code
      AND UPPER(id) = UPPER(p_id);
  RETURN res;

EXCEPTION
  WHEN OTHERS THEN RETURN NULL;
END ballans_by_kontr;
  
end utility;
/

--
-- Описание для пакета USR_SETT
--
CREATE OR REPLACE PACKAGE "USR_SETT"
  AS

  FUNCTION get_userid(p_u_name IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION get_userfirma(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION get_currency(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION get_division(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION get_kassa(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION get_mainusluga(p_id IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION get_activities(p_id IN VARCHAR2)
    RETURN VARCHAR2;

END usr_sett;
/

CREATE OR REPLACE PACKAGE BODY "USR_SETT"
  AS

  FUNCTION get_userid(p_u_name IN VARCHAR2)
    RETURN VARCHAR2
    AS
      p_id VARCHAR2(60);
    BEGIN
      SELECT id
        INTO p_id
        FROM users
        WHERE UPPER(TRIM(login)) = UPPER(TRIM(p_u_name));
      RETURN p_id;

    EXCEPTION
      WHEN no_data_found THEN RETURN '00000000-0000-0000-0000-000000000000';
    END get_userid;

  FUNCTION get_userfirma(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      p_ret VARCHAR2(60);
    BEGIN
      SELECT firma_id
        INTO p_ret
        FROM user_settings
        WHERE user_id = p_id;
      RETURN p_ret;

    EXCEPTION
      WHEN no_data_found THEN RETURN '00000000-0000-0000-0000-000000000000';
    END get_userfirma;

  FUNCTION get_currency(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      p_ret VARCHAR2(60);
    BEGIN
      SELECT currency_id
        INTO p_ret
        FROM user_settings
        WHERE user_id = p_id;
      RETURN p_ret;

    EXCEPTION
      WHEN no_data_found THEN RETURN '00000000-0000-0000-0000-000000000000';
    END get_currency;

  FUNCTION get_division(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      p_ret VARCHAR2(60);
    BEGIN
      SELECT division_id
        INTO p_ret
        FROM user_settings
        WHERE user_id = p_id;
      RETURN p_ret;

    EXCEPTION
      WHEN no_data_found THEN RETURN '00000000-0000-0000-0000-000000000000';
    END get_division;

  FUNCTION get_kassa(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      p_ret VARCHAR2(60);
    BEGIN
      SELECT kassa_id
        INTO p_ret
        FROM user_settings
        WHERE user_id = p_id;
      RETURN p_ret;

    EXCEPTION
      WHEN no_data_found THEN RETURN '00000000-0000-0000-0000-000000000000';
    END get_kassa;

  FUNCTION get_mainusluga(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      p_ret VARCHAR2(60);
    BEGIN
      SELECT main_usluga
        INTO p_ret
        FROM user_settings
        WHERE user_id = p_id;
      RETURN p_ret;

    EXCEPTION
      WHEN no_data_found THEN RETURN '00000000-0000-0000-0000-000000000000';
    END get_mainusluga;

  FUNCTION get_activities(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      p_ret VARCHAR2(60);
    BEGIN
      SELECT activities_id
        INTO p_ret
        FROM user_settings
        WHERE user_id = p_id;
      RETURN p_ret;

    EXCEPTION
      WHEN no_data_found THEN RETURN '00000000-0000-0000-0000-000000000000';
    END get_activities;

END usr_sett;

/

--
-- Описание для пакета START_PKG
--
CREATE OR REPLACE PACKAGE "START_PKG"
  AS

  PROCEDURE start_move_plan_acc(p_id IN VARCHAR2);
  PROCEDURE start_remove_plan_acc(p_id  IN VARCHAR2,
                                  p_del IN NUMBER DEFAULT 0);
  PROCEDURE start_move_all;
  PROCEDURE start_remove_all;

END START_PKG;
/

CREATE OR REPLACE PACKAGE BODY "START_PKG"
  AS

  PROCEDURE start_move_plan_acc(p_id IN VARCHAR2)
    AS
      p_start_rec    start_ost % ROWTYPE;
      p_move_rec     moves % ROWTYPE;
      p_version      VARCHAR2(1000);
      p_typedef_id   VARCHAR2(100);
      in_use         EXCEPTION;
      p_upr_val      currency.id % TYPE;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_start_rec
        FROM START_OST
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_start_rec.id, 'START_OST') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;
      start_remove_plan_acc(p_id, p_start_rec.deleted);
      IF p_start_rec.deleted = 1
      THEN
        RETURN;
      END IF;

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM START_OST
        WHERE id = p_id;

      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;
      SELECT id
        INTO p_typedef_id
        FROM type_def
        WHERE UPPER(type_def.table_name) = UPPER('start_ost');
      FOR i IN (SELECT *
          FROM start_ost_tp
          WHERE start_ost_id = p_id)
      LOOP
        p_move_rec.period := p_start_rec.dat;
        p_move_rec.registrator_type := p_typedef_id;
        p_move_rec.registrator_id := p_id;
        p_move_rec.plan_acc_deb_id := i.plan_acc_deb_id;
        p_move_rec.activities_id := p_start_rec.activities_id;
        p_move_rec.division_id := p_start_rec.division_id;

        p_move_rec.subconto1_deb := i.subconto1_deb;
        p_move_rec.subconto2_deb := i.subconto2_deb;

        p_move_rec.plan_acc_kred_id := i.plan_acc_kred_id;

        p_move_rec.subconto1_kred := i.subconto1_kred;
        p_move_rec.subconto2_kred := i.subconto2_kred;

        p_move_rec.description := i.description;

        p_move_rec.curr_deb := p_start_rec.curr_id;
        p_move_rec.summ_val_deb := entry.sign_of_summ(p_move_rec.plan_acc_deb_id, i.summ, 1);

        p_move_rec.curr_kred := p_start_rec.curr_id;
        p_move_rec.summ_val_kredit := entry.sign_of_summ(p_move_rec.plan_acc_kred_id, i.summ, 0);

        p_move_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_move_rec.curr_deb, p_upr_val, p_move_rec.period, p_move_rec.summ_val_deb);
        p_move_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_move_rec.curr_kred, p_upr_val, p_move_rec.period, p_move_rec.summ_val_kredit);

        p_move_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_move_rec;
      END LOOP;

      p_start_rec.posted := 1;
      UPDATE START_OST
        SET ROW = p_start_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');

    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error start_ost move for plan accounting! ' || SQLERRM, TRUE);
    END start_move_plan_acc;

  PROCEDURE start_remove_plan_acc(p_id  IN VARCHAR2,
                                  p_del IN NUMBER DEFAULT 0)
    AS
      p_start_rec    start_ost % ROWTYPE;
      p_move_count   NUMBER;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_start_rec
        FROM START_OST
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_start_rec.id, 'START_OST') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM START_OST
        WHERE id = p_id;
      SELECT COUNT(*)
        INTO p_move_count
        FROM moves
        WHERE registrator_id = p_id;
      IF p_move_count > 0
      THEN
        EXECUTE IMMEDIATE ('select * from moves where registrator_id=''' || p_id || ''' for update nowait');
        DELETE FROM moves
          WHERE registrator_id = p_id;
      END IF;

      IF p_del <> 0
      THEN
        p_start_rec.deleted := 1;
      END IF;
      p_start_rec.posted := 0;
      UPDATE START_OST
        SET ROW = p_start_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');
    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error start_ost move for plan accounting! ' || sqlerrm, TRUE);
    END start_remove_plan_acc;

  PROCEDURE start_move_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM START_OST)
      LOOP
        start_move_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error start_ost move  all for plan accounting! ' || SQLERRM, TRUE);
    END start_move_all;

  PROCEDURE start_remove_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM START_OST)
      LOOP
        start_remove_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error start_ost remove all for plan accounting! ' || SQLERRM, TRUE);
    END start_remove_all;

END START_PKG;

/

--
-- Описание для пакета RKO_ENTRY
--
CREATE OR REPLACE PACKAGE "RKO_ENTRY"
  AS

  PROCEDURE rko_move_plan_acc(p_id IN VARCHAR2);
  PROCEDURE rko_remove_plan_acc(p_id  IN VARCHAR2,
                                p_del IN NUMBER DEFAULT 0);
  PROCEDURE rko_move_all;
  PROCEDURE rko_remove_all;
  FUNCTION get_operationname(p_id IN VARCHAR2)
    RETURN VARCHAR2;

END RKO_ENTRY;
/

CREATE OR REPLACE PACKAGE BODY "RKO_ENTRY"
  AS

  PROCEDURE set_subconto_other(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_rko       rko % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
    BEGIN
      SELECT *
        INTO p_rko
        FROM RKO
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      p_ret_rec := p_move_rec;

      --Субконто кредита
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_kred := p_rko.kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto1_kred := p_rko.kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto1_kred := p_rko.kassa_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      p_ret_rec.curr_deb := p_rko.curr_id;
      p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, p_rko.summa, 1);

      p_ret_rec.curr_kred := p_rko.curr_id;
      p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, p_rko.summa, 0);

      p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
      p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

      p_ret_rec.version := systimestamp;

      INSERT INTO moves
      VALUES p_ret_rec;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error rko move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_other;

  PROCEDURE set_subconto_buyer(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_rko       rko % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
    BEGIN
      SELECT *
        INTO p_rko
        FROM RKO
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      p_ret_rec := p_move_rec;

      --Субконто дебета
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_deb := p_rko.kontrag_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_deb := p_rko.kontrag_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_deb := p_rko.kontrag_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      --Субконто кредита
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_kred := p_rko.kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_kred := p_rko.kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_kred := p_rko.kassa_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      p_ret_rec.curr_deb := p_rko.curr_id;
      p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, p_rko.summa, 1);

      p_ret_rec.curr_kred := p_rko.curr_id;
      p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, p_rko.summa, 0);

      p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
      p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

      p_ret_rec.version := systimestamp;

      INSERT INTO moves
      VALUES p_ret_rec;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error rko move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_buyer;

  PROCEDURE set_subconto_kassa(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec      moves % ROWTYPE;
      p_sub_count    NUMBER(10);
      p_counter      NUMBER(10);
      p_sub_name     plan_type_subconto.fullname % TYPE;
      p_rko          rko % ROWTYPE;
      p_plan_acc     plan_acc % ROWTYPE;
      p_upr_val      currency.id % TYPE;
      p_div_dest     kassa.division_id % TYPE;
      p_div          kassa.division_id % TYPE;
      p_code_service plan_acc.id % TYPE;
    BEGIN
      SELECT *
        INTO p_rko
        FROM RKO
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;
      SELECT division_id
        INTO p_div_dest
        FROM kassa
        WHERE id = p_rko.dest_kassa_id;
      SELECT division_id
        INTO p_div
        FROM kassa
        WHERE id = p_rko.kassa_id;

      SELECT id
        INTO p_code_service
        FROM PLAN_ACC
        WHERE code LIKE '511';

      p_ret_rec := p_move_rec;

      --Субконто дебета
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_deb := p_rko.dest_kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_deb := p_rko.dest_kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_deb := p_rko.dest_kassa_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      --Субконто кредита
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_kred := p_rko.kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_kred := p_rko.kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_kred := p_rko.kassa_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      p_ret_rec.curr_deb := p_rko.curr_id;
      p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, p_rko.summa, 1);

      p_ret_rec.curr_kred := p_rko.curr_id;
      p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, p_rko.summa, 0);

      p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
      p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

      p_ret_rec.version := systimestamp;

      INSERT INTO moves
      VALUES p_ret_rec;

      IF p_div_dest != p_div
      THEN
        p_ret_rec := p_move_rec;
        p_ret_rec.plan_acc_kred_id := p_code_service;
        p_ret_rec.plan_acc_deb_id := p_code_service;
        p_ret_rec.subconto1_deb := p_div;
        p_ret_rec.subconto1_kred := p_div_dest;
        p_ret_rec.curr_deb := p_rko.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, p_rko.summa, 1);

        p_ret_rec.curr_kred := p_rko.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, p_rko.summa, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;
        INSERT INTO moves
        VALUES p_ret_rec;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error rko move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_kassa;

  PROCEDURE rko_move_plan_acc(p_id IN VARCHAR2)
    AS
      p_rko_rec               rko % ROWTYPE;
      p_move_rec              moves % ROWTYPE;
      p_version               VARCHAR2(1000);
      in_use                  EXCEPTION;
      p_id_other_operation    operation_rko.id % TYPE;
      p_id_buyer_operation    operation_rko.id % TYPE;
      p_id_supplier_operation operation_rko.id % TYPE;
      p_id_kassa_operation    operation_rko.id % TYPE;
      p_counter               NUMBER(10);
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked          EXCEPTION;
    BEGIN
      SELECT *
        INTO p_rko_rec
        FROM RKO
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_rko_rec.id, 'RKO') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;

      rko_remove_plan_acc(p_id, p_rko_rec.deleted);
      IF p_rko_rec.deleted = 1
      THEN
        RETURN;
      END IF;

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM RKO
        WHERE id = p_id;

      SELECT id
        INTO p_id_other_operation
        FROM operation_rko
        WHERE UPPER(name) = UPPER('OTHER_PAYMENT')
          AND ROWNUM = 1;
      SELECT id
        INTO p_id_supplier_operation
        FROM operation_rko
        WHERE UPPER(name) = UPPER('PAYMENT_SUPPLIER')
          AND ROWNUM = 1;
      SELECT id
        INTO p_id_buyer_operation
        FROM operation_rko
        WHERE UPPER(name) = UPPER('RETURN_BUYER')
          AND ROWNUM = 1;
      SELECT id
        INTO p_id_kassa_operation
        FROM operation_rko
        WHERE UPPER(name) = UPPER('MOVE_KASSA')
          AND ROWNUM = 1;
      p_move_rec.period := p_rko_rec.dat;
      p_counter := 0;
      FOR i IN (SELECT *
          FROM entry_settings
          WHERE typedef_id = (SELECT id
                FROM type_def
                WHERE UPPER(type_def.table_name) = UPPER('rko'))
          ORDER BY chain)
      LOOP
        p_counter := p_counter + 1;
        p_move_rec.registrator_type := i.typedef_id;
        p_move_rec.registrator_id := p_id;
        p_move_rec.plan_acc_deb_id := i.plan_acc_deb_id;
        p_move_rec.activities_id := p_rko_rec.activities_id;
        p_move_rec.division_id := p_rko_rec.division_id;

        p_move_rec.plan_acc_kred_id := i.plan_acc_kred_id;
        p_move_rec.description := i.description;

        --РКО - Прочий расход денежных средств
        IF p_counter = 1
        THEN
          IF p_rko_rec.operation_id = p_id_other_operation
          THEN
            set_subconto_other(p_move_rec);
          END IF;
        END IF;

        --РКО - Оплата поставщику
        IF p_counter = 2
        THEN
          IF p_rko_rec.operation_id = p_id_supplier_operation
          THEN
            set_subconto_buyer(p_move_rec);
          END IF;
        END IF;

        --РКО - Возврат покупателю
        IF p_counter = 3
        THEN
          IF p_rko_rec.operation_id = p_id_buyer_operation
          THEN
            set_subconto_buyer(p_move_rec);
          END IF;
        END IF;

        --РКО - Перемещение между кассами
        IF p_counter = 4
        THEN
          IF p_rko_rec.operation_id = p_id_kassa_operation
          THEN
            set_subconto_kassa(p_move_rec);
          END IF;
        END IF;
      END LOOP;

      p_rko_rec.posted := 1;
      UPDATE RKO
        SET ROW = p_rko_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');

    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error RKO move for plan accounting! ' || SQLERRM, TRUE);
    END rko_move_plan_acc;

  PROCEDURE rko_remove_plan_acc(p_id  IN VARCHAR2,
                                p_del IN NUMBER DEFAULT 0)
    AS
      p_rko_rec      rko % ROWTYPE;
      p_move_count   NUMBER;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_rko_rec
        FROM RKO
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_rko_rec.id, 'RKO') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;
      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM RKO
        WHERE id = p_id;
      SELECT COUNT(*)
        INTO p_move_count
        FROM moves
        WHERE registrator_id = p_id;
      IF p_move_count > 0
      THEN
        EXECUTE IMMEDIATE ('select * from moves where registrator_id=''' || p_id || ''' for update nowait');
        DELETE FROM moves
          WHERE registrator_id = p_id;
      END IF;

      IF p_del <> 0
      THEN
        p_rko_rec.deleted := 1;
      END IF;
      p_rko_rec.posted := 0;
      UPDATE RKO
        SET ROW = p_rko_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');
    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error RKO move for plan accounting! ' || sqlerrm, TRUE);
    END rko_remove_plan_acc;

  PROCEDURE rko_move_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM RKO)
      LOOP
        rko_move_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error rko move  all for plan accounting! ' || SQLERRM, TRUE);
    END rko_move_all;

  PROCEDURE rko_remove_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM RKO)
      LOOP
        rko_remove_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error rko remove all for plan accounting! ' || SQLERRM, TRUE);
    END rko_remove_all;

  FUNCTION get_operationname(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      pp_id VARCHAR2(60);
    BEGIN
      SELECT r.name
        INTO pp_id
        FROM operation_rko r
        WHERE UPPER(r.id) = UPPER(p_id);
      RETURN pp_id;

    EXCEPTION
      WHEN no_data_found THEN RETURN 'none';
    END get_operationname;

END RKO_ENTRY;

/

--
-- Описание для пакета P_ENCRYPT
--
CREATE OR REPLACE PACKAGE "P_ENCRYPT"
  AS
  FUNCTION encrypt_ssn(p_ssn IN VARCHAR2,
                       p_key IN VARCHAR2)
    RETURN RAW;
  FUNCTION encrypt_pass(p_ssn IN VARCHAR2,
                        p_key IN VARCHAR2)
    RETURN RAW;
  FUNCTION decrypt_ssn(p_ssn IN RAW,
                       p_key IN VARCHAR2)
    RETURN VARCHAR2;
  FUNCTION decrypt_pass(p_ssn IN RAW,
                        p_key IN VARCHAR2)
    RETURN VARCHAR2;
END p_encrypt;
/

CREATE OR REPLACE PACKAGE BODY "P_ENCRYPT"
  AS
  --DO NOT FORGET TO WRAP THIS BEFORE LOADING INTO DATABASE
  --IF IT IS NOT WRAPPED, THE KEY WILL BE EXPOSED
  --THE WRAP UTILITY IS LOCATED IN THE \BIN DIRECTORY (WRAP.EXE)
  G_DATE TIMESTAMP;
  G_CHARACTER_SET VARCHAR2(10) := 'AL32UTF8';
  G_STRING VARCHAR2(16);
  G_KEY RAW(250);
  G_ENCRYPTION_TYPE PLS_INTEGER := dbms_crypto.encrypt_aes128
  + dbms_crypto.chain_cbc
  + dbms_crypto.pad_pkcs5;

  PROCEDURE setg_date(p_dat TIMESTAMP)
    IS
    BEGIN
      G_DATE := p_dat;
      G_STRING := RTRIM(TO_CHAR(G_DATE, 'DDMMYYYYHH24miSS') || '70');
      G_KEY := utl_i18n.string_to_raw
      (data => G_STRING,
      dst_charset => G_CHARACTER_SET);
    END setg_date;

  FUNCTION encrypt_ssn(p_ssn IN VARCHAR2,
                       p_key IN VARCHAR2)
    RETURN RAW
    IS
      l_ssn       RAW(64) := UTL_I18N.STRING_TO_RAW(p_ssn, G_CHARACTER_SET);
      l_encrypted RAW(64);
    BEGIN
      setg_date(TO_TIMESTAMP(p_key, 'DD/MM/YYYY HH24:MI:SS'));
      l_ssn := utl_i18n.string_to_raw
      (data => p_ssn,
      dst_charset => G_CHARACTER_SET);

      l_encrypted := dbms_crypto.encrypt
      (src => l_ssn,
      typ => G_ENCRYPTION_TYPE,
      key => G_KEY);

      RETURN l_encrypted;
    END encrypt_ssn;

  FUNCTION encrypt_pass(p_ssn IN VARCHAR2,
                        p_key IN VARCHAR2)
    RETURN RAW
    IS
      l_ssn       RAW(64) := UTL_I18N.STRING_TO_RAW(p_ssn, G_CHARACTER_SET);
      l_encrypted RAW(64);
    BEGIN
      --setg_date(to_timestamp(p_key,'DD/MM/YYYY HH24:MI:SS'));
      G_STRING := RTRIM(p_key);
      G_KEY := utl_i18n.string_to_raw
      (data => G_STRING,
      dst_charset => G_CHARACTER_SET);
      l_ssn := utl_i18n.string_to_raw
      (data => p_ssn,
      dst_charset => G_CHARACTER_SET);

      l_encrypted := dbms_crypto.encrypt
      (src => l_ssn,
      typ => G_ENCRYPTION_TYPE,
      key => G_KEY);

      RETURN l_encrypted;
    END encrypt_pass;

  FUNCTION decrypt_ssn(p_ssn IN RAW,
                       p_key IN VARCHAR2)
    RETURN VARCHAR2
    IS
      l_decrypted        RAW(64);
      l_decrypted_string VARCHAR2(64);
    BEGIN
      setg_date(TO_DATE(p_key, 'DD/MM/YYYY'));
      l_decrypted := dbms_crypto.decrypt
      (src => p_ssn,
      typ => G_ENCRYPTION_TYPE,
      key => G_KEY);

      l_decrypted_string := utl_i18n.raw_to_char
      (data => l_decrypted,
      src_charset => G_CHARACTER_SET);
      RETURN l_decrypted_string;
    END decrypt_ssn;

  FUNCTION decrypt_pass(p_ssn IN RAW,
                        p_key IN VARCHAR2)
    RETURN VARCHAR2
    IS
      l_decrypted        RAW(64);
      l_decrypted_string VARCHAR2(64);
    BEGIN
      --setg_date(to_date(p_key,'DD/MM/YYYY'));
      G_STRING := RTRIM(p_key);
      G_KEY := utl_i18n.string_to_raw
      (data => G_STRING,
      dst_charset => G_CHARACTER_SET);
      l_decrypted := dbms_crypto.decrypt
      (src => p_ssn,
      typ => G_ENCRYPTION_TYPE,
      key => G_KEY);

      l_decrypted_string := utl_i18n.raw_to_char
      (data => l_decrypted,
      src_charset => G_CHARACTER_SET);
      RETURN l_decrypted_string;
    END decrypt_pass;

END p_encrypt;

/

--
-- Описание для пакета PROFIT_ENTRY
--
CREATE OR REPLACE PACKAGE "PROFIT_ENTRY"
  AS

  PROCEDURE profit_move_plan_acc(p_id IN VARCHAR2);
  PROCEDURE profit_remove_plan_acc(p_id  IN VARCHAR2,
                                   p_del IN NUMBER DEFAULT 0);
  PROCEDURE profit_move_all;
  PROCEDURE profit_remove_all;
  FUNCTION getProfitByDivision(p_div IN VARCHAR2)
    RETURN NUMBER;

END PROFIT_ENTRY;
/

CREATE OR REPLACE PACKAGE BODY "PROFIT_ENTRY"
  AS

  PROCEDURE set_subconto_profit(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_profit    profit_distrib % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
    BEGIN
      SELECT *
        INTO p_profit
        FROM profit_distrib
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM profit_distrib_tp
          WHERE profit_id = p_profit.id)
      LOOP
        p_ret_rec := p_move_rec;

        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_profit.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_profit.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_profit.division_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := i.kontr_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := i.kontr_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := i.kontr_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_profit.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.summ, 1);

        p_ret_rec.curr_kred := p_profit.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.summ, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;
        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error profit_distrib move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_profit;

  PROCEDURE set_subconto_division(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec      moves % ROWTYPE;
      p_counter      NUMBER(10);
      p_profit       profit_distrib % ROWTYPE;
      p_plan_acc     plan_acc % ROWTYPE;
      p_upr_val      currency.id % TYPE;
      p_summ         NUMBER := 0;
      p_code_service plan_acc.id % TYPE;
    BEGIN
      SELECT *
        INTO p_profit
        FROM profit_distrib
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;
      SELECT id
        INTO p_code_service
        FROM PLAN_ACC
        WHERE code LIKE '000';

      --ORDERS_ENTRY.set_enddatmoves(p_profit.dat); 
      p_summ := p_profit.summ;
      FOR i IN (SELECT *
          FROM ballans
          WHERE code LIKE '900'
            AND division_id IN (SELECT s.id
                FROM (SELECT LEVEL root,
                             id,
                             fullname
                    FROM divisions d
                    WHERE d.deleted = 0
                      AND is_group = 0
                  CONNECT BY PRIOR d.id = d.parent_id
                  START WITH d.id = p_profit.division_id) s
                WHERE s.root > 1
                  AND passive_end != 0)
          ORDER BY passive_end ASC)
      LOOP
        -- p_summ:=p_summ - i.end_ost;
        --if i.DIVISION_ID = p_profit.division_id then
        --   continue;
        -- end if;
        p_ret_rec := p_move_rec;
        --p_ret_rec.id := utility.uuid();


        p_ret_rec.subconto1_deb := i.division_id;
        p_ret_rec.plan_acc_kred_id := p_code_service;
        p_ret_rec.subconto1_kred := NULL;
        p_summ := i.passive_end;

        p_ret_rec.division_id := i.division_id;

        p_ret_rec.curr_deb := p_profit.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.passive_end, 1);

        p_ret_rec.curr_kred := p_profit.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.passive_end, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;
        INSERT INTO moves
        VALUES p_ret_rec;

        --for y in (select * from moves where id = p_ret_rec.id) loop
        p_ret_rec := p_move_rec;
        p_ret_rec.plan_acc_deb_id := p_code_service;
        p_ret_rec.subconto1_deb := NULL;
        p_ret_rec.subconto1_kred := p_profit.division_id;
        p_summ := i.passive_end;

        p_ret_rec.division_id := p_profit.division_id;

        p_ret_rec.curr_deb := p_profit.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.passive_end, 1);

        p_ret_rec.curr_kred := p_profit.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.passive_end, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;
        INSERT INTO moves
        VALUES p_ret_rec;
      --end loop;

      END LOOP;
    END set_subconto_division;

  PROCEDURE profit_move_plan_acc(p_id IN VARCHAR2)
    AS
      p_profit_rec   profit_distrib % ROWTYPE;
      p_move_rec     moves % ROWTYPE;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      p_counter      NUMBER(10);
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_profit_rec
        FROM profit_distrib
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_profit_rec.id, 'profit_distrib') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;

      profit_remove_plan_acc(p_id, p_profit_rec.deleted);
      IF p_profit_rec.deleted = 1
      THEN
        RETURN;
      END IF;

      DELETE FROM profit_distrib_tp
        WHERE profit_id = p_id
          AND manual = 0;
      paycalc.profit_money_by_kontr(p_id, p_profit_rec.summ);

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM profit_distrib
        WHERE id = p_id;

      p_move_rec.period := p_profit_rec.dat;
      p_counter := 0;

      FOR i IN (SELECT *
          FROM entry_settings
          WHERE typedef_id = (SELECT id
                FROM type_def
                WHERE UPPER(type_def.table_name) = UPPER('profit_distrib'))
          ORDER BY chain)
      LOOP
        p_counter := p_counter + 1;
        p_move_rec.registrator_type := i.typedef_id;
        p_move_rec.registrator_id := p_id;
        p_move_rec.plan_acc_deb_id := i.plan_acc_deb_id;
        p_move_rec.activities_id := p_profit_rec.activities_id;
        p_move_rec.division_id := p_profit_rec.division_id;

        p_move_rec.plan_acc_kred_id := i.plan_acc_kred_id;
        p_move_rec.description := i.description;

        --Распределение прибыли
        IF p_counter = 1
        THEN
          --null;
          set_subconto_profit(p_move_rec);
        END IF;

        --Переброс прибыли на головное подразделение
        IF p_counter = 2
        THEN
          --null;
          set_subconto_division(p_move_rec);
        END IF;

      --Переброс прибыли на головное подразделение
      --if p_counter = 3 then
      -- null;
      --set_subconto_division_back(p_move_rec); 
      --  end if;
      END LOOP;

      p_profit_rec.posted := 1;
      UPDATE profit_distrib
        SET ROW = p_profit_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');

    --utility.set_disable_edit_profit(p_profit_rec.dat);

    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error profit_distrib move for plan accounting! ' || SQLERRM, TRUE);
    END profit_move_plan_acc;

  PROCEDURE profit_remove_plan_acc(p_id  IN VARCHAR2,
                                   p_del IN NUMBER DEFAULT 0)
    AS
      p_profit_rec   profit_distrib % ROWTYPE;
      p_move_count   NUMBER;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_profit_rec
        FROM profit_distrib
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_profit_rec.id, 'profit_distrib') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;
      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM profit_distrib
        WHERE id = p_id;
      SELECT COUNT(*)
        INTO p_move_count
        FROM moves
        WHERE registrator_id = p_id;
      IF p_move_count > 0
      THEN
        EXECUTE IMMEDIATE ('select * from moves where registrator_id=''' || p_id || ''' for update nowait');
        DELETE FROM moves
          WHERE registrator_id = p_id;
      END IF;

      IF p_del <> 0
      THEN
        p_profit_rec.deleted := 1;
      END IF;
      p_profit_rec.posted := 0;
      UPDATE profit_distrib
        SET ROW = p_profit_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');

    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error profit_distrib move for plan accounting! ' || sqlerrm, TRUE);
    END profit_remove_plan_acc;

  PROCEDURE profit_move_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM profit_distrib)
      LOOP
        profit_move_plan_acc(i.id);
      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error profit_distrib move  all for plan accounting! ' || SQLERRM, TRUE);
    END profit_move_all;

  PROCEDURE profit_remove_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM profit_distrib)
      LOOP
        profit_remove_plan_acc(i.id);
      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error profit_distrib remove all for plan accounting! ' || SQLERRM, TRUE);
    END profit_remove_all;

  FUNCTION getProfitByDivision(p_div IN VARCHAR2)
    RETURN NUMBER
    AS
      p_summ NUMBER := 0;
    BEGIN
      FOR i IN (SELECT SUM(passive_end) summa
          FROM ballans
          WHERE code LIKE '900'
            AND division_id IN (SELECT s.id
                FROM (SELECT LEVEL root,
                             id,
                             fullname
                    FROM divisions d
                    WHERE d.deleted = 0
                      AND is_group = 0
                  CONNECT BY PRIOR d.id = d.parent_id
                  START WITH d.id = p_div) s))
      LOOP

        p_summ := i.summa;
      END LOOP;
      RETURN p_summ;
    END;

END PROFIT_ENTRY;

/

--
-- Описание для пакета PRICES
--
CREATE OR REPLACE PACKAGE "PRICES"
  AS

  FUNCTION get_lastSectionPrice(p_code IN nomenklatura.id % TYPE,
                                p_dat  IN DATE)
    RETURN VARCHAR2;
  PROCEDURE importprice(p_dat IN DATE);

END PRICES;
/

CREATE OR REPLACE PACKAGE BODY "PRICES"
  AS

  FUNCTION get_lastSectionPrice(p_code IN nomenklatura.id % TYPE,
                                p_dat  IN DATE)
    RETURN VARCHAR2
    AS
      res VARCHAR2(50);
    BEGIN
      SELECT id
        INTO res
        FROM reg_prices
        WHERE period = (SELECT MAX(period)
              FROM reg_prices
              WHERE nom_id = p_code
                AND period <= p_dat)
          AND nom_id = p_code
          AND ROWNUM = 1;
      RETURN res;
    END get_lastSectionPrice;

  PROCEDURE importprice(p_dat IN DATE)
    AS
      p_nom          nomenklatura.id % TYPE;
      p_group        nomenklatura.id % TYPE;
      p_group_parent nomenklatura.id % TYPE;
      p_price_id     reg_prices.id % TYPE;
      p_ed_izm       measure_unit.id % TYPE;
      record_found   EXCEPTION;
    BEGIN
      SELECT id
        INTO p_group_parent
        FROM nomenklatura n
        WHERE UPPER(n.fullname) = UPPER('Услуги')
          AND n.IS_GROUP = 1;
      FOR i IN (SELECT *
          FROM imported_price)
      LOOP

        BEGIN --Ищем группу, если нет - создаем
          SELECT id
            INTO p_group
            FROM nomenklatura n
            WHERE UPPER(n.fullname) = UPPER(i.groups)
              AND n.IS_GROUP = 1
              AND ROWNUM = 1;
        EXCEPTION
          WHEN OTHERS THEN SELECT UTILITY.UUID()
                INTO p_group
                FROM dual;
              INSERT INTO nomenklatura (
                id, fullname, is_group, parent_id, usluga
              )
              VALUES (p_group, i.groups, 1, p_group_parent, 0);
        END;

        BEGIN  --Ищем номенклатуру, если нет - создаем
          SELECT id
            INTO p_nom
            FROM nomenklatura n
            WHERE n.IS_GROUP = 0
              AND (UPPER(n.ARTIKUL) = UPPER(i.artikul)
              OR UPPER(n.fullname) = UPPER(i.nom_name))
              AND ROWNUM = 1;
        EXCEPTION
          WHEN OTHERS THEN SELECT UTILITY.UUID()
                INTO p_nom
                FROM dual;
              INSERT INTO nomenklatura (
                id, fullname, is_group, parent_id, usluga, artikul
              )
              VALUES (p_nom, i.nom_name, 0, p_group, 1, i.artikul);
        END;

        BEGIN --Ищем единицу измерения, если нет - создаем
          SELECT id
            INTO p_ed_izm
            FROM measure_unit m
            WHERE UPPER(m.fullname) = UPPER(i.ed_izm)
              AND ROWNUM = 1;
        EXCEPTION
          WHEN OTHERS THEN SELECT UTILITY.UUID()
                INTO p_ed_izm
                FROM dual;
              INSERT INTO measure_unit (
                id, fullname
              )
              VALUES (p_ed_izm, i.ed_izm);
        END;

        BEGIN --Ищем цену за текущую дату, если не находим - создаем
          SELECT id
            INTO p_price_id
            FROM reg_prices
            WHERE period = (SELECT MAX(period)
                  FROM reg_prices
                  WHERE nom_id = p_nom
                    AND period = p_dat)
              AND nom_id = p_nom
              AND ROWNUM = 1;
          IF p_price_id IS NULL
          THEN
            RAISE no_data_found;
          END IF;
        EXCEPTION
          WHEN OTHERS THEN INSERT INTO reg_prices (
                nom_id, period, ed_izm, price_usl, price_goods
              )
              VALUES (p_nom, p_dat, p_ed_izm, i.price_usl, i.price_goods);
        END;
      END LOOP;

    EXCEPTION
      WHEN record_found THEN RAISE_APPLICATION_ERROR(-20002, 'REG_PRICES record found in this date! ', TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error importing price! ', TRUE);
    END importprice;

END PRICES;

/

--
-- Описание для пакета PKO_ENTRY
--
CREATE OR REPLACE PACKAGE "PKO_ENTRY"
  AS

  PROCEDURE pko_move_plan_acc(p_id IN VARCHAR2);
  PROCEDURE pko_remove_plan_acc(p_id  IN VARCHAR2,
                                p_del IN NUMBER DEFAULT 0);
  PROCEDURE pko_move_all;
  PROCEDURE pko_remove_all;
  FUNCTION get_operationname(p_id IN VARCHAR2)
    RETURN VARCHAR2;

END pko_entry;
/

CREATE OR REPLACE PACKAGE BODY "PKO_ENTRY"
  AS

  PROCEDURE set_subconto_other(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_pko       pko % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
    BEGIN
      SELECT *
        INTO p_pko
        FROM PKO
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      p_ret_rec := p_move_rec;

      --Субконто дебета
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_deb := p_pko.kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_deb := p_pko.kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_deb := p_pko.kassa_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      p_ret_rec.curr_deb := p_pko.curr_id;
      p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, p_pko.summa, 1);

      p_ret_rec.curr_kred := p_pko.curr_id;
      p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, p_pko.summa, 0);

      p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
      p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

      p_ret_rec.version := systimestamp;

      INSERT INTO moves
      VALUES p_ret_rec;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error pko move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_other;

  PROCEDURE set_subconto_buyer(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_pko       pko % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
    BEGIN
      SELECT *
        INTO p_pko
        FROM PKO
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      p_ret_rec := p_move_rec;

      --Субконто дебета
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КАССА'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_deb := p_pko.kassa_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_deb := p_pko.kassa_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_deb := p_pko.kassa_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      --Субконто кредита
      SELECT COUNT(*)
        INTO p_sub_count
        FROM plan_acc_subconto
        WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
      IF p_sub_count > 0
      THEN
        p_counter := 0;
        FOR x IN (SELECT *
            FROM plan_acc_subconto
            WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
        LOOP
          p_counter := p_counter + 1;
          SELECT fullname
            INTO p_sub_name
            FROM plan_type_subconto
            WHERE id = x.plan_type_subc;
          IF UPPER(p_sub_name) = 'КОНТРАГЕНТЫ'
          THEN
            IF p_counter = 1
            THEN
              p_ret_rec.subconto1_kred := p_pko.kontrag_id;
            END IF;
            IF p_counter = 2
            THEN
              p_ret_rec.subconto2_kred := p_pko.kontrag_id;
            END IF;
            IF p_counter = 3
            THEN
              p_ret_rec.subconto3_kred := p_pko.kontrag_id;
            END IF;
          END IF;
        END LOOP;
      END IF;

      p_ret_rec.curr_deb := p_pko.curr_id;
      p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, p_pko.summa, 1);

      p_ret_rec.curr_kred := p_pko.curr_id;
      p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, p_pko.summa, 0);

      p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
      p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

      p_ret_rec.version := systimestamp;

      INSERT INTO moves
      VALUES p_ret_rec;

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error pko move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_buyer;

  PROCEDURE pko_move_plan_acc(p_id IN VARCHAR2)
    AS
      p_pko_rec               pko % ROWTYPE;
      p_move_rec              moves % ROWTYPE;
      p_version               VARCHAR2(1000);
      in_use                  EXCEPTION;
      p_id_other_operation    operation_pko.id % TYPE;
      p_id_buyer_operation    operation_pko.id % TYPE;
      p_id_supplier_operation operation_pko.id % TYPE;
      p_counter               NUMBER(10);
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked          EXCEPTION;
    BEGIN
      SELECT *
        INTO p_pko_rec
        FROM PKO
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_pko_rec.id, 'PKO') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;
      pko_remove_plan_acc(p_id, p_pko_rec.deleted);

      IF p_pko_rec.deleted = 1
      THEN
        RETURN;
      END IF;

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM PKO
        WHERE id = p_id;

      SELECT id
        INTO p_id_other_operation
        FROM operation_pko
        WHERE UPPER(name) = UPPER('OTHER_PAYMENT')
          AND ROWNUM = 1;
      SELECT id
        INTO p_id_buyer_operation
        FROM operation_pko
        WHERE UPPER(name) = UPPER('FROM_BUYER')
          AND ROWNUM = 1;
      SELECT id
        INTO p_id_supplier_operation
        FROM operation_pko
        WHERE UPPER(name) = UPPER('RETURN_SUPPLIER')
          AND ROWNUM = 1;
      p_move_rec.period := p_pko_rec.dat;
      p_counter := 0;
      FOR i IN (SELECT *
          FROM entry_settings
          WHERE typedef_id = (SELECT id
                FROM type_def
                WHERE UPPER(type_def.table_name) = UPPER('pko'))
          ORDER BY chain)
      LOOP
        p_counter := p_counter + 1;
        p_move_rec.registrator_type := i.typedef_id;
        p_move_rec.registrator_id := p_id;
        p_move_rec.plan_acc_deb_id := i.plan_acc_deb_id;
        p_move_rec.activities_id := p_pko_rec.activities_id;
        p_move_rec.division_id := p_pko_rec.division_id;

        p_move_rec.plan_acc_kred_id := i.plan_acc_kred_id;
        p_move_rec.description := i.description;

        --ПКО - Прочие приходы денежных средств
        IF p_counter = 1
        THEN
          IF p_pko_rec.operation_id = p_id_other_operation
          THEN
            set_subconto_other(p_move_rec);
          END IF;
        END IF;

        --ПКО - Оплата от покупателя
        IF p_counter = 2
        THEN
          IF p_pko_rec.operation_id = p_id_buyer_operation
          THEN
            set_subconto_buyer(p_move_rec);
          END IF;
        END IF;

        --ПКО - Возврат от поставщика
        IF p_counter = 3
        THEN
          IF p_pko_rec.operation_id = p_id_supplier_operation
          THEN
            set_subconto_buyer(p_move_rec);
          END IF;
        END IF;
      END LOOP;

      p_pko_rec.posted := 1;
      UPDATE PKO
        SET ROW = p_pko_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');

    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error PKO move for plan accounting! ' || SQLERRM, TRUE);
    END pko_move_plan_acc;

  PROCEDURE pko_remove_plan_acc(p_id  IN VARCHAR2,
                                p_del IN NUMBER DEFAULT 0)
    AS
      p_pko_rec      pko % ROWTYPE;
      p_move_count   NUMBER;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_pko_rec
        FROM PKO
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_pko_rec.id, 'PKO') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;
      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM PKO
        WHERE id = p_id;
      SELECT COUNT(*)
        INTO p_move_count
        FROM moves
        WHERE registrator_id = p_id;
      IF p_move_count > 0
      THEN
        EXECUTE IMMEDIATE ('select * from moves where registrator_id=''' || p_id || ''' for update nowait');
        DELETE FROM moves
          WHERE registrator_id = p_id;
      END IF;

      IF p_del <> 0
      THEN
        p_pko_rec.deleted := 1;
      END IF;
      p_pko_rec.posted := 0;
      UPDATE PKO
        SET ROW = p_pko_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');
    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error PKO move for plan accounting! ' || sqlerrm, TRUE);
    END pko_remove_plan_acc;

  PROCEDURE pko_move_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM PKO)
      LOOP
        pko_move_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error pko move  all for plan accounting! ' || SQLERRM, TRUE);
    END pko_move_all;

  PROCEDURE pko_remove_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM PKO)
      LOOP
        pko_remove_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error pko remove all for plan accounting! ' || SQLERRM, TRUE);
    END pko_remove_all;

  FUNCTION get_operationname(p_id IN VARCHAR2)
    RETURN VARCHAR2
    AS
      pp_id VARCHAR2(60);
    BEGIN
      SELECT r.name
        INTO pp_id
        FROM operation_pko r
        WHERE UPPER(r.id) = UPPER(p_id);
      RETURN pp_id;

    EXCEPTION
      WHEN no_data_found THEN RETURN 'none';
    END get_operationname;

END pko_entry;

/

--
-- Описание для пакета PAYCALC
--
CREATE OR REPLACE PACKAGE "PAYCALC"
  AS

  FUNCTION get_kontrag_by_order(p_order IN VARCHAR2)
    RETURN kontragtable;
  FUNCTION get_kontrag_by_division(p_order IN VARCHAR2)
    RETURN kontragtable;
  FUNCTION get_kontrag_by_ierarchia(p_order IN VARCHAR2)
    RETURN kontragtable;
  FUNCTION get_kont_by_division(p_order       IN VARCHAR2,
                                p_division_id IN VARCHAR2)
    RETURN kontragtable;
  FUNCTION get_kont_by_ierarchia(p_order IN VARCHAR2)
    RETURN kontragtable;
  FUNCTION get_kont_by_net(p_order IN VARCHAR2)
    RETURN kontragtable;
  FUNCTION get_kont_by_order(p_order IN VARCHAR2)
    RETURN kontragtable;
  PROCEDURE calc_money(p_order IN VARCHAR2);
  FUNCTION getSummOrder(p_order IN VARCHAR2)
    RETURN NUMBER;
  FUNCTION getKoeffByLevel(p_order IN VARCHAR2,
                           p_level    NUMBER)
    RETURN NUMBER;
  FUNCTION getKoeffByLevelKontr(p_order IN VARCHAR2,
                                p_level    NUMBER)
    RETURN NUMBER;
  PROCEDURE calc_money_by_kontr(p_order IN VARCHAR2);
  PROCEDURE profit_money_by_kontr(p_order IN VARCHAR2,
                                  p_summ  IN NUMBER);

END PAYCALC;
/

CREATE OR REPLACE PACKAGE BODY "PAYCALC"
  AS

  FUNCTION get_kontrag_by_order(p_order IN VARCHAR2)
    RETURN kontragtable
    AS
      l_data        kontragTable := kontragTable();
      p_counter     NUMBER       := 0;
      order_rec     orders % ROWTYPE;
      p_kontragname kontragents.fullname % TYPE;
      sett_rec      user_settings % ROWTYPE;
    BEGIN
      SELECT o.*
        INTO order_rec
        FROM orders o
        WHERE UPPER(o.id) = UPPER(p_order);
      FOR i IN (SELECT *
          FROM nachisl_settings
          WHERE base_id = (SELECT b.id
                FROM base_of_nachisl b
                WHERE b.name = 'ORDER'
                  AND ROWNUM = 1)
            AND pay_id IN (SELECT id
                FROM pay_settings
                WHERE in_profit = 0))
      LOOP
        FOR y IN (SELECT u.*
            FROM users u
            WHERE UPPER(u.id) = UPPER(i.user_id))
        LOOP
          SELECT s.*
            INTO sett_rec
            FROM user_settings s
            WHERE s.user_id = y.id
              AND ROWNUM = 1;
          p_counter := p_counter + 1;
          IF y.id = order_rec.user_id
          THEN
            SELECT fullname
              INTO p_kontragname
              FROM kontragents
              WHERE id = sett_rec.kontrag_id;
            l_data.EXTEND;
            l_data(p_counter) := kontragType(NVL(sett_rec.kontrag_id, 'none'), NVL(p_kontragname, 'none'), 1);
          END IF;
          IF sett_rec.zamerkontrag_id = order_rec.zamer_id
          THEN
            SELECT fullname
              INTO p_kontragname
              FROM kontragents
              WHERE id = sett_rec.zamerkontrag_id;
            l_data.EXTEND;
            l_data(p_counter) := kontragType(NVL(sett_rec.zamerkontrag_id, 'none'), NVL(p_kontragname, 'none'), 1);
          END IF;
        END LOOP;
      END LOOP;
      RETURN l_data;
    END get_kontrag_by_order;

  FUNCTION get_kont_by_order(p_order IN VARCHAR2)
    RETURN kontragtable
    AS
      l_data        kontragTable := kontragTable();
      p_counter     NUMBER       := 0;
      order_rec     orders % ROWTYPE;
      p_kontragname kontragents.fullname % TYPE;
      sett_rec      user_settings % ROWTYPE;
    BEGIN
      SELECT o.*
        INTO order_rec
        FROM orders o
        WHERE UPPER(o.id) = UPPER(p_order);
      FOR i IN (SELECT *
          FROM kontrag_settings
          WHERE base_id = (SELECT b.id
                FROM base_of_nachisl b
                WHERE b.name = 'ORDER'
                  AND ROWNUM = 1)
            AND pay_id IN (SELECT id
                FROM pay_settings
                WHERE in_profit = 0))
      LOOP
        IF i.kontrag_id = order_rec.agent_id
        THEN
          SELECT fullname
            INTO p_kontragname
            FROM kontragents
            WHERE id = i.kontrag_id;
          l_data.EXTEND;
          p_counter := p_counter + 1;
          l_data(p_counter) := kontragType(NVL(i.kontrag_id, 'none'), NVL(p_kontragname, 'none'), 1);
        END IF;
        IF i.kontrag_id = order_rec.zamer_id
        THEN
          SELECT fullname
            INTO p_kontragname
            FROM kontragents
            WHERE id = i.kontrag_id;
          l_data.EXTEND;
          p_counter := p_counter + 1;
          l_data(p_counter) := kontragType(NVL(i.kontrag_id, 'none'), NVL(p_kontragname, 'none'), 1);
        END IF;
        --for y in (select * from user_settings where user_id = order_rec.user_id and rownum = 1) loop
        SELECT *
          INTO sett_rec
          FROM user_settings
          WHERE user_id = order_rec.user_id
            AND ROWNUM = 1;
        IF sett_rec.kontrag_id IS NOT NULL
        THEN
          IF i.kontrag_id = sett_rec.kontrag_id
          THEN
            SELECT fullname
              INTO p_kontragname
              FROM kontragents
              WHERE id = i.kontrag_id;
            l_data.EXTEND;
            p_counter := p_counter + 1;
            l_data(p_counter) := kontragType(NVL(i.kontrag_id, 'none'), NVL(p_kontragname, 'none'), 1);
          END IF;
        END IF;
      --end loop;
      END LOOP;
      RETURN l_data;
    END get_kont_by_order;

  FUNCTION get_kontrag_by_division(p_order IN VARCHAR2)
    RETURN kontragtable
    AS
      l_data        kontragTable := kontragTable();
      p_counter     NUMBER       := 0;
      order_rec     orders % ROWTYPE;
      p_kontragname kontragents.fullname % TYPE;
      sett_rec      user_settings % ROWTYPE;
    BEGIN
      SELECT o.*
        INTO order_rec
        FROM orders o
        WHERE UPPER(o.id) = UPPER(p_order);
      FOR i IN (SELECT *
          FROM nachisl_settings
          WHERE base_id = (SELECT b.id
                FROM base_of_nachisl b
                WHERE b.name = 'DIV'
                  AND ROWNUM = 1)
            AND pay_id IN (SELECT id
                FROM pay_settings
                WHERE in_profit = 0))
      LOOP
        SELECT s.*
          INTO sett_rec
          FROM user_settings s
          WHERE s.user_id = i.user_id
            AND ROWNUM = 1;
        p_counter := p_counter + 1;
        IF i.division_id = order_rec.division_id
        THEN
          SELECT fullname
            INTO p_kontragname
            FROM kontragents
            WHERE id = sett_rec.kontrag_id;
          l_data.EXTEND;
          l_data(p_counter) := kontragType(NVL(sett_rec.kontrag_id, 'none'), NVL(p_kontragname, 'none'), 1);
        END IF;
      END LOOP;
      RETURN l_data;
    END get_kontrag_by_division;

  FUNCTION get_kont_by_division(p_order       IN VARCHAR2,
                                p_division_id IN VARCHAR2)
    RETURN kontragtable
    AS
      l_data        kontragTable := kontragTable();
      p_counter     NUMBER       := 0;
      order_rec     orders % ROWTYPE;
      p_kontragname kontragents.fullname % TYPE;
    BEGIN
      SELECT o.*
        INTO order_rec
        FROM orders o
        WHERE UPPER(o.id) = UPPER(p_order);
      FOR i IN (SELECT *
          FROM kontrag_settings
          WHERE base_id = (SELECT b.id
                FROM base_of_nachisl b
                WHERE b.name = 'DIV'
                  AND ROWNUM = 1)
            AND pay_id IN (SELECT id
                FROM pay_settings
                WHERE in_profit = 0)
            AND division_id = p_division_id)
      LOOP
        IF order_rec.division_id = i.division_id
        THEN
          SELECT fullname
            INTO p_kontragname
            FROM kontragents
            WHERE id = i.kontrag_id;
          p_counter := p_counter + 1;
          l_data.EXTEND;
          l_data(p_counter) := kontragType(NVL(i.kontrag_id, 'none'), NVL(p_kontragname, 'none'), 1);
        END IF;
      END LOOP;
      RETURN l_data;
    END get_kont_by_division;

  FUNCTION get_kontrag_by_ierarchia(p_order IN VARCHAR2)
    RETURN kontragtable
    AS
      l_data        kontragTable := kontragTable();
      p_counter     NUMBER       := 0;
      order_rec     orders % ROWTYPE;
      p_kontragname kontragents.fullname % TYPE;
      sett_rec      user_settings % ROWTYPE;
    BEGIN
      SELECT o.*
        INTO order_rec
        FROM orders o
        WHERE UPPER(o.id) = UPPER(p_order);
      FOR i IN (SELECT *
          FROM nachisl_settings
          WHERE base_id = (SELECT b.id
                FROM base_of_nachisl b
                WHERE b.name = 'IERARHIA'
                  AND ROWNUM = 1)
            AND pay_id IN (SELECT id
                FROM pay_settings
                WHERE in_profit = 0))
      LOOP
        SELECT s.*
          INTO sett_rec
          FROM user_settings s
          WHERE s.user_id = i.user_id
            AND ROWNUM = 1;
        FOR y IN (SELECT root,
                         s.id
            FROM (SELECT LEVEL root,
                         id
                FROM divisions d
                WHERE d.deleted = 0
              CONNECT BY PRIOR d.id = d.parent_id
              START WITH d.id = i.division_id) s)
        LOOP
          IF y.id = order_rec.division_id
          THEN
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_kontragname
              FROM kontragents
              WHERE id = sett_rec.kontrag_id;
            l_data.EXTEND;
            l_data(p_counter) := kontragType(NVL(sett_rec.kontrag_id, 'none'), NVL(p_kontragname, 'none'), y.root);
          END IF;
        END LOOP;
      END LOOP;
      RETURN l_data;
    END get_kontrag_by_ierarchia;

  FUNCTION get_kont_by_ierarchia(p_order IN VARCHAR2)
    RETURN kontragtable
    AS
      l_data        kontragTable := kontragTable();
      p_counter     NUMBER       := 0;
      order_rec     orders % ROWTYPE;
      p_kontragname kontragents.fullname % TYPE;
      sett_rec      user_settings % ROWTYPE;
    BEGIN
      SELECT o.*
        INTO order_rec
        FROM orders o
        WHERE UPPER(o.id) = UPPER(p_order);
      SELECT s.*
        INTO sett_rec
        FROM user_settings s
        WHERE s.user_id = order_rec.user_id
          AND ROWNUM = 1;
      FOR i IN (SELECT *
          FROM kontrag_settings
          WHERE base_id = (SELECT b.id
                FROM base_of_nachisl b
                WHERE b.name = 'IERARHIA'
                  AND ROWNUM = 1)
            AND pay_id IN (SELECT id
                FROM pay_settings
                WHERE in_profit = 0))
      LOOP
        FOR y IN (SELECT root,
                         s.id
            FROM (SELECT LEVEL root,
                         id
                FROM vw_net d
                WHERE d.deleted = 0
              CONNECT BY PRIOR d.id = d.parent_id
              START WITH d.id = i.division_id) s)
        LOOP
          IF y.id = sett_rec.kontrag_id
          THEN
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_kontragname
              FROM kontragents
              WHERE id = i.kontrag_id;
            l_data.EXTEND;
            l_data(p_counter) := kontragType(NVL(i.kontrag_id, 'none'), NVL(p_kontragname, 'none'), y.root);
          END IF;
        END LOOP;
      END LOOP;
      RETURN l_data;
    END get_kont_by_ierarchia;

  FUNCTION get_kont_by_net(p_order IN VARCHAR2)
    RETURN kontragtable
    AS
      l_data        kontragTable := kontragTable();
      p_counter     NUMBER       := 0;
      order_rec     orders % ROWTYPE;
      p_kontragname kontragents.fullname % TYPE;
      sett_rec      user_settings % ROWTYPE;
    BEGIN
      SELECT o.*
        INTO order_rec
        FROM orders o
        WHERE UPPER(o.id) = UPPER(p_order);
      SELECT s.*
        INTO sett_rec
        FROM user_settings s
        WHERE s.user_id = order_rec.user_id
          AND ROWNUM = 1;
      --    for i in (select * from kontrag_settings
      --      where kontrag_id = sett_rec.kontrag_id 
      --      and base_id = (select b.id from base_of_nachisl b where b.name = 'IERARHIA' and rownum = 1)
      --      and pay_id in (select id from pay_settings where in_profit = 0)) loop
      FOR y IN (SELECT root,
                       s.id
          FROM (SELECT LEVEL root,
                       id
              FROM vw_net d
              WHERE d.deleted = 0
            CONNECT BY PRIOR d.parent_id = d.id
            START WITH d.id = (CASE WHEN sett_rec.net_id IS NULL THEN sett_rec.kontrag_id ELSE sett_rec.net_id END)) s
          ORDER BY root)
      LOOP
        --if y.id = sett_rec.kontrag_id  then  
        p_counter := p_counter + 1;
        SELECT fullname
          INTO p_kontragname
          FROM kontragents
          WHERE id = y.id;
        l_data.EXTEND;
        l_data(p_counter) := kontragType(NVL(y.id, 'none'), NVL(p_kontragname, 'none'), y.root);
      --end if;
      END LOOP;
      -- end loop; 
      RETURN l_data;
    END get_kont_by_net;

  FUNCTION getSummOrder(p_order IN VARCHAR2)
    RETURN NUMBER
    AS
      res     NUMBER;
      addwork NUMBER;
    BEGIN
      SELECT SUM(summ)
        INTO res
        FROM orders_tp_uslugi
        WHERE order_id = p_order;
      SELECT SUM(price_add)
        INTO addwork
        FROM orders_tp_uslugi
        WHERE order_id = p_order;
      RETURN NVL(res, 0) + NVL(addwork, 0);
    END getSummOrder;

  FUNCTION getBaseName(p_id IN VARCHAR2)
    RETURN VARCHAR
    AS
      nachisl_rec nachisl_settings % ROWTYPE;
      base_rec    base_of_nachisl % ROWTYPE;
    BEGIN
      SELECT *
        INTO nachisl_rec
        FROM nachisl_settings
        WHERE id = p_id;
      SELECT *
        INTO base_rec
        FROM base_of_nachisl
        WHERE id = nachisl_rec.base_id;
      RETURN base_rec.name;
    END getBaseName;

  FUNCTION getBaseNameKontr(p_id IN VARCHAR2)
    RETURN VARCHAR
    AS
      nachisl_rec kontrag_settings % ROWTYPE;
      base_rec    base_of_nachisl % ROWTYPE;
    BEGIN
      SELECT *
        INTO nachisl_rec
        FROM kontrag_settings
        WHERE id = p_id;
      SELECT *
        INTO base_rec
        FROM base_of_nachisl
        WHERE id = nachisl_rec.base_id;
      RETURN base_rec.name;
    END getBaseNameKontr;

  FUNCTION summkoeff(p_n IN NUMBER)
    RETURN NUMBER
    AS
      sm NUMBER := 0;
    BEGIN
      FOR i IN 1 .. p_n
      LOOP
        sm := sm + (1 / POWER(2, i));
      END LOOP;
      RETURN sm;
    END summkoeff;

  FUNCTION getKoeffByLevel(p_order IN VARCHAR2,
                           p_level    NUMBER)
    RETURN NUMBER
    AS
      cnt       NUMBER := 0;
      p_counter NUMBER := 0;
      res       NUMBER := 0;
    BEGIN
      IF p_level = 1
      THEN
        RETURN res;
      END IF;
      SELECT COUNT(*)
        INTO cnt
        FROM TABLE (CAST(get_kontrag_by_ierarchia(p_order) AS kontragTable))
        WHERE root > 1;
      FOR i IN (SELECT n,
                       u_name,
                       root
          FROM TABLE (CAST(get_kontrag_by_ierarchia(p_order) AS kontragTable))
          WHERE root > 1
          ORDER BY root)
      LOOP
        p_counter := p_counter + 1;
        IF i.root = p_level
        THEN
          res := 1 / POWER(2, p_counter);
          IF p_counter = cnt
          THEN
            res := (1 - summkoeff(p_counter - 1));
          END IF;
        END IF;
      END LOOP;
      RETURN res;
    END getKoeffByLevel;

  FUNCTION getKoeffByLevelKontr(p_order IN VARCHAR2,
                                p_level    NUMBER)
    RETURN NUMBER
    AS
      cnt       NUMBER := 0;
      p_counter NUMBER := 0;
      res       NUMBER := 0;
    BEGIN
      IF p_level = 1
      THEN
        RETURN res;
      END IF;
      SELECT COUNT(*)
        INTO cnt
        FROM TABLE (CAST(get_kont_by_net(p_order) AS kontragTable))
        WHERE root > 1;
      FOR i IN (SELECT n,
                       u_name,
                       root
          FROM TABLE (CAST(get_kont_by_net(p_order) AS kontragTable))
          WHERE root > 1
          ORDER BY root)
      LOOP
        p_counter := p_counter + 1;
        IF i.root = p_level
        THEN
          res := 1 / POWER(2, p_counter);
          IF p_counter = cnt
          THEN
            res := (1 - summkoeff(p_counter - 1));
          END IF;
        END IF;
      END LOOP;
      RETURN res;
    END getKoeffByLevelKontr;

  PROCEDURE calc_money(p_order IN VARCHAR2)
    AS
      nachisl_rec orders_tp_nachisl % ROWTYPE;
      sum_order   NUMBER(10, 2) := 0;
    BEGIN
      sum_order := getSummOrder(p_order);
      IF sum_order = 0
      THEN
        RETURN;
      END IF;
      --delete from ORDERS_TP_NACHISL where order_id = p_order and manual = 0;

      FOR i IN (SELECT *
          FROM pay_settings
          WHERE in_profit = 0)
      LOOP
        FOR y IN (SELECT u.id,
                         NVL((SELECT s.kontrag_id
                             FROM user_settings s
                             WHERE s.user_id = u.id
                               AND ROWNUM = 1), (SELECT s.zamerkontrag_id
                             FROM user_settings s
                             WHERE s.user_id = u.id
                               AND ROWNUM = 1)) kon_id
            FROM users u
            WHERE u.id IN (SELECT n.user_id
                  FROM nachisl_settings n
                  WHERE n.pay_id = i.id))
        LOOP
          FOR x IN (SELECT *
              FROM nachisl_settings
              WHERE user_id = y.id
                AND pay_id = i.id)
          LOOP
            IF getBaseName(x.id) = 'ORDER'
            THEN
              FOR g IN (SELECT *
                  FROM TABLE (CAST(get_kontrag_by_order(p_order) AS kontragTable))
                  WHERE n = y.kon_id
                    AND ROWNUM = 1)
              LOOP
                nachisl_rec.order_id := p_order;
                nachisl_rec.dat_nach := sysdate;
                nachisl_rec.kontr_id := g.n;
                nachisl_rec.pay_id := i.id;
                nachisl_rec.calc_id := i.base_id;
                nachisl_rec.percent := i.stavka;
                nachisl_rec.manual := 0;
                IF x.summa IS NOT NULL
                THEN
                  nachisl_rec.summ := x.summa;
                ELSE
                  nachisl_rec.summ := (i.stavka / 100) * sum_order;
                END IF;
                INSERT INTO orders_tp_nachisl
                VALUES nachisl_rec;
              END LOOP;
            ELSE
              IF getBaseName(x.id) = 'DIV'
              THEN
                FOR g IN (SELECT *
                    FROM TABLE (CAST(get_kontrag_by_division(p_order) AS kontragTable))
                    WHERE n = y.kon_id
                      AND ROWNUM = 1)
                LOOP
                  nachisl_rec.order_id := p_order;
                  nachisl_rec.dat_nach := sysdate;
                  nachisl_rec.kontr_id := g.n;
                  nachisl_rec.pay_id := i.id;
                  nachisl_rec.calc_id := i.base_id;
                  nachisl_rec.percent := i.stavka;
                  nachisl_rec.manual := 0;
                  IF x.summa IS NOT NULL
                  THEN
                    nachisl_rec.summ := x.summa;
                  ELSE
                    nachisl_rec.summ := (i.stavka / 100) * sum_order;
                  END IF;
                  INSERT INTO orders_tp_nachisl
                  VALUES nachisl_rec;
                END LOOP;
              --else 
              --   for g in (select n, root,
              --     getKoeffByLevel(p_order,root) koef
              --     from table(cast(get_kontrag_by_ierarchia(p_order) as kontragTable))
              --           where n = y.kon_id and root > 1) loop
              --     nachisl_rec.order_id:= p_order;
              --     nachisl_rec.dat_nach:=sysdate;
              --     nachisl_rec.kontr_id:= g.n;
              --     nachisl_rec.pay_id:= i.id;
              --     nachisl_rec.calc_id:= i.base_id;
              --     nachisl_rec.percent:= i.stavka*g.koef;
              --     nachisl_rec.manual:= 0;
              --     if x.summa is not null then
              --       nachisl_rec.summ:= x.summa;
              --     else
              --       nachisl_rec.summ:= (i.stavka*g.koef/100)*sum_order;
              --     end if;
              --     insert into orders_tp_nachisl values nachisl_rec;
              --   end loop;  
              END IF;
            END IF;
          END LOOP;
        END LOOP;
      END LOOP;
    END calc_money;

  PROCEDURE calc_money_by_kontr(p_order IN VARCHAR2)
    AS
      nachisl_rec orders_tp_nachisl % ROWTYPE;
      order_rec   orders % ROWTYPE;
      sum_order   NUMBER(10, 2) := 0;
      p_dat       DATE;
    BEGIN
      sum_order := getSummOrder(p_order);
      IF sum_order = 0
      THEN
        RETURN;
      END IF;
      --delete from ORDERS_TP_NACHISL where order_id = p_order and manual = 0;
      SELECT *
        INTO order_rec
        FROM orders
        WHERE id = p_order
          AND ROWNUM = 1;
      IF order_rec.dat_complete_fact IS NULL
      THEN
        p_dat := order_rec.dat_complete;
      ELSE
        p_dat := order_rec.dat_complete_fact;
      END IF;

      FOR i IN (SELECT *
          FROM pay_settings
          WHERE in_profit = 0)
      LOOP
        FOR y IN (SELECT DISTINCT u.id
            FROM kontragents u
            WHERE u.id IN (SELECT n.kontrag_id
                  FROM kontrag_settings n
                  WHERE n.pay_id = i.id))
        LOOP
          FOR x IN (SELECT *
              FROM kontrag_settings
              WHERE kontrag_id = y.id
                AND pay_id = i.id)
          LOOP

            IF getBaseNameKontr(x.id) = 'DIV'
            THEN
              FOR g IN (SELECT DISTINCT *
                  FROM TABLE (CAST(get_kont_by_division(p_order, x.division_id) AS kontragTable))
                  WHERE n = y.id
                    AND ROWNUM = 1)
              LOOP
                nachisl_rec.order_id := p_order;
                nachisl_rec.dat_nach := p_dat;
                nachisl_rec.kontr_id := g.n;
                nachisl_rec.pay_id := i.id;
                nachisl_rec.calc_id := i.base_id;
                nachisl_rec.percent := i.stavka;
                nachisl_rec.manual := 0;
                IF x.summa IS NOT NULL
                THEN
                  nachisl_rec.summ := x.summa;
                ELSE
                  nachisl_rec.summ := (i.stavka / 100) * sum_order;
                END IF;
                INSERT INTO orders_tp_nachisl
                VALUES nachisl_rec;
              END LOOP;
            ELSE
              IF getBaseNameKontr(x.id) = 'IERARHIA'
              THEN
                FOR g IN (SELECT DISTINCT n,
                                          root,
                                          getKoeffByLevelKontr(p_order, root) koef
                    FROM TABLE (CAST(get_kont_by_net(p_order) AS kontragTable))
                    WHERE n = y.id
                      AND root > 1)
                LOOP
                  nachisl_rec.order_id := p_order;
                  nachisl_rec.dat_nach := p_dat;
                  nachisl_rec.kontr_id := g.n;
                  nachisl_rec.pay_id := i.id;
                  nachisl_rec.calc_id := i.base_id;
                  nachisl_rec.percent := i.stavka * g.koef;
                  nachisl_rec.manual := 0;
                  IF x.summa IS NOT NULL
                  THEN
                    nachisl_rec.summ := x.summa;
                  ELSE
                    nachisl_rec.summ := (i.stavka * g.koef / 100) * sum_order;
                  END IF;
                  INSERT INTO orders_tp_nachisl
                  VALUES nachisl_rec;
                END LOOP;
              ELSE
                IF getBaseNameKontr(x.id) = 'ORDER'
                THEN
                  FOR g IN (SELECT *
                      FROM TABLE (CAST(get_kont_by_order(p_order) AS kontragTable))
                      WHERE n = y.id
                        AND ROWNUM = 1)
                  LOOP
                    nachisl_rec.order_id := p_order;
                    nachisl_rec.dat_nach := p_dat;
                    nachisl_rec.kontr_id := g.n;
                    nachisl_rec.pay_id := i.id;
                    nachisl_rec.calc_id := i.base_id;
                    nachisl_rec.percent := i.stavka;
                    nachisl_rec.manual := 0;
                    IF x.summa IS NOT NULL
                    THEN
                      nachisl_rec.summ := x.summa;
                    ELSE
                      nachisl_rec.summ := (i.stavka / 100) * sum_order;
                    END IF;
                    INSERT INTO orders_tp_nachisl
                    VALUES nachisl_rec;
                  END LOOP;
                END IF;
              END IF;
            END IF;
          END LOOP;
        END LOOP;
      END LOOP;
    END calc_money_by_kontr;

  PROCEDURE profit_money_by_kontr(p_order IN VARCHAR2,
                                  p_summ  IN NUMBER)
    AS
      nachisl_rec   profit_distrib_tp % ROWTYPE;
      sum_to_profit NUMBER(10, 2) := 0;
      ex_custom     EXCEPTION;
      no_settings   EXCEPTION;
      p_no_sett     NUMBER(10, 0) := 1;
    BEGIN
      IF p_summ = 0
      THEN
        RETURN;
      END IF;
      sum_to_profit := p_summ;

      FOR k IN (SELECT n.kontrag_id
          FROM kontrag_settings n
          WHERE n.pay_id IN (SELECT id
                FROM pay_settings
                WHERE in_profit = 1))
      LOOP
        p_no_sett := 0;
        EXIT;
      END LOOP;
      IF p_no_sett = 1
      THEN
        RAISE no_settings;
      END IF;

      FOR i IN (SELECT *
          FROM pay_settings
          WHERE in_profit = 1
            AND base_id IN (SELECT id
                FROM BASE_OF_CALC
                WHERE name LIKE 'ФиксированнойСуммой'))
      LOOP
        FOR y IN (SELECT u.id
            FROM kontragents u
            WHERE u.id IN (SELECT n.kontrag_id
                  FROM kontrag_settings n
                  WHERE n.pay_id = i.id))
        LOOP
          FOR x IN (SELECT *
              FROM kontrag_settings
              WHERE kontrag_id = y.id
                AND pay_id = i.id)
          LOOP
            nachisl_rec.profit_id := p_order;
            nachisl_rec.dat_nach := sysdate;
            nachisl_rec.kontr_id := x.kontrag_id;
            nachisl_rec.pay_id := i.id;
            nachisl_rec.calc_id := i.base_id;
            nachisl_rec.percent := i.stavka;
            nachisl_rec.manual := 0;
            nachisl_rec.summ := x.summa;
            --if nachisl_rec.summ > sum_to_profit then
            --RAISE ex_custom;
            --end if;
            sum_to_profit := sum_to_profit - nachisl_rec.summ;

            INSERT INTO profit_distrib_tp
            VALUES nachisl_rec;
          END LOOP;
        END LOOP;
      END LOOP;

      --if sum_to_profit <=0 then
      --RAISE ex_custom;
      --end if;

      FOR i IN (SELECT *
          FROM pay_settings
          WHERE in_profit = 1
            AND base_id IN (SELECT id
                FROM BASE_OF_CALC
                WHERE name LIKE 'Процент'))
      LOOP
        FOR y IN (SELECT u.id
            FROM kontragents u
            WHERE u.id IN (SELECT n.kontrag_id
                  FROM kontrag_settings n
                  WHERE n.pay_id = i.id))
        LOOP
          FOR x IN (SELECT *
              FROM kontrag_settings
              WHERE kontrag_id = y.id
                AND pay_id = i.id)
          LOOP
            nachisl_rec.profit_id := p_order;
            nachisl_rec.dat_nach := sysdate;
            nachisl_rec.kontr_id := x.kontrag_id;
            nachisl_rec.pay_id := i.id;
            nachisl_rec.calc_id := i.base_id;
            nachisl_rec.percent := i.stavka;
            nachisl_rec.manual := 0;
            nachisl_rec.summ := (i.stavka / 100) * sum_to_profit;

            INSERT INTO profit_distrib_tp
            VALUES nachisl_rec;
          END LOOP;
        END LOOP;
      END LOOP;

    EXCEPTION
      WHEN ex_custom THEN RAISE_APPLICATION_ERROR(-20001, 'Сумма начисления больше чем распределяемая!');
      WHEN no_settings THEN RAISE_APPLICATION_ERROR(-20002, 'Нет контрагентов для начисления!');
      WHEN OTHERS THEN RAISE;
    END profit_money_by_kontr;

END PAYCALC;

/

--
-- Описание для пакета OTHER_ENTRY
--
CREATE OR REPLACE PACKAGE "OTHER_ENTRY"
  AS

  PROCEDURE other_move_plan_acc(p_id IN VARCHAR2);
  PROCEDURE other_remove_plan_acc(p_id  IN VARCHAR2,
                                  p_del IN NUMBER DEFAULT 0);
  PROCEDURE other_move_all;
  PROCEDURE other_remove_all;

END other_entry;
/

CREATE OR REPLACE PACKAGE BODY "OTHER_ENTRY"
  AS

  PROCEDURE set_subconto_tp_zatraty(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_other     other_zatraty % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
    BEGIN
      SELECT *
        INTO p_other
        FROM OTHER_ZATRATY
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM other_zatraty_tab_part_zatraty
          WHERE oth_id = p_other.id)
      LOOP
        p_ret_rec := p_move_rec;


        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'СТАТЬЯ ЗАТРАТ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := i.zatr_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := i.zatr_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := i.zatr_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_other.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_other.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_other.division_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_other.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_other.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_other.kassa_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_other.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_other.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_other.kassa_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_other.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_other.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_other.division_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'СТАТЬЯ ЗАТРАТ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := i.zatr_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := i.zatr_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := i.zatr_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_other.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.summa, 1);

        p_ret_rec.curr_kred := p_other.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.summa, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error other_zatraty move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_tp_zatraty;

  PROCEDURE set_subconto_tp_result(p_move_rec moves % ROWTYPE)
    AS
      p_ret_rec   moves % ROWTYPE;
      p_sub_count NUMBER(10);
      p_counter   NUMBER(10);
      p_sub_name  plan_type_subconto.fullname % TYPE;
      p_other     other_zatraty % ROWTYPE;
      p_plan_acc  plan_acc % ROWTYPE;
      p_upr_val   currency.id % TYPE;
    BEGIN
      SELECT *
        INTO p_other
        FROM OTHER_ZATRATY
        WHERE id = p_move_rec.registrator_id;
      SELECT id
        INTO p_upr_val
        FROM currency
        WHERE predefined = 1;

      FOR i IN (SELECT *
          FROM other_zatraty_tab_part_zatraty
          WHERE oth_id = p_other.id)
      LOOP
        p_ret_rec := p_move_rec;


        --Субконто дебета
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_deb_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_other.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_other.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_other.division_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'СТАТЬЯ ЗАТРАТ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := i.zatr_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := i.zatr_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := i.zatr_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_deb := p_other.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_deb := p_other.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_deb := p_other.kassa_id;
              END IF;
            END IF;
          END LOOP;
        END IF;

        --Субконто кредита
        SELECT COUNT(*)
          INTO p_sub_count
          FROM plan_acc_subconto
          WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id;
        IF p_sub_count > 0
        THEN
          p_counter := 0;
          FOR x IN (SELECT *
              FROM plan_acc_subconto
              WHERE plan_acc_id = p_ret_rec.plan_acc_kred_id)
          LOOP
            p_counter := p_counter + 1;
            SELECT fullname
              INTO p_sub_name
              FROM plan_type_subconto
              WHERE id = x.plan_type_subc;
            IF UPPER(p_sub_name) = 'СТАТЬЯ ЗАТРАТ'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := i.zatr_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := i.zatr_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := i.zatr_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'КАССА'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_other.kassa_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_other.kassa_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_other.kassa_id;
              END IF;
            END IF;
            IF UPPER(p_sub_name) = 'ЦФО'
            THEN
              IF p_counter = 1
              THEN
                p_ret_rec.subconto1_kred := p_other.division_id;
              END IF;
              IF p_counter = 2
              THEN
                p_ret_rec.subconto2_kred := p_other.division_id;
              END IF;
              IF p_counter = 3
              THEN
                p_ret_rec.subconto3_kred := p_other.division_id;
              END IF;
            END IF;

          END LOOP;
        END IF;

        p_ret_rec.curr_deb := p_other.curr_id;
        p_ret_rec.summ_val_deb := entry.sign_of_summ(p_ret_rec.plan_acc_deb_id, i.summa, 1);

        p_ret_rec.curr_kred := p_other.curr_id;
        p_ret_rec.summ_val_kredit := entry.sign_of_summ(p_ret_rec.plan_acc_kred_id, i.summa, 0);

        p_ret_rec.summ_upr_deb := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_deb, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_deb);
        p_ret_rec.summ_upr_kred := currency_pkg.calculate_from_curr_to_curr(p_ret_rec.curr_kred, p_upr_val, p_ret_rec.period, p_ret_rec.summ_val_kredit);

        p_ret_rec.version := systimestamp;

        INSERT INTO moves
        VALUES p_ret_rec;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error other_zatraty move for plan accounting! ' || SQLERRM, TRUE);
    END set_subconto_tp_result;

  PROCEDURE other_move_plan_acc(p_id IN VARCHAR2)
    AS
      p_other_rec    other_zatraty % ROWTYPE;
      p_move_rec     moves % ROWTYPE;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      p_counter      NUMBER(10);
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_other_rec
        FROM OTHER_ZATRATY
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_other_rec.id, 'OTHER_ZATRATY') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;

      other_remove_plan_acc(p_id, p_other_rec.deleted);
      IF p_other_rec.deleted = 1
      THEN
        RETURN;
      END IF;

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM OTHER_ZATRATY
        WHERE id = p_id;

      p_move_rec.period := p_other_rec.dat;
      p_counter := 0;
      FOR i IN (SELECT *
          FROM entry_settings
          WHERE typedef_id = (SELECT id
                FROM type_def
                WHERE UPPER(type_def.table_name) = UPPER('other_zatraty'))
          ORDER BY chain)
      LOOP
        p_counter := p_counter + 1;
        p_move_rec.registrator_type := i.typedef_id;
        p_move_rec.registrator_id := p_id;
        p_move_rec.plan_acc_deb_id := i.plan_acc_deb_id;
        p_move_rec.activities_id := p_other_rec.activities_id;
        p_move_rec.division_id := p_other_rec.division_id;

        p_move_rec.plan_acc_kred_id := i.plan_acc_kred_id;

        --Проводка ТЧ Затраты - Списание на административные затраты
        IF p_counter = 1
        THEN
          p_move_rec.description := 'Проводка ТЧ Затраты - Списание на административные затраты';
          set_subconto_tp_zatraty(p_move_rec);
        END IF;

        --Проводка ТЧ Затраты - Списание на затрат на финансовый результат
        IF p_counter = 2
        THEN
          p_move_rec.description := 'Проводка ТЧ Затраты - Списание на затрат на финансовый результат';
          set_subconto_tp_result(p_move_rec);
        END IF;
      END LOOP;

      p_other_rec.posted := 1;
      UPDATE OTHER_ZATRATY
        SET ROW = p_other_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');

    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error other_zatraty move for plan accounting! ' || SQLERRM, TRUE);
    END other_move_plan_acc;

  PROCEDURE other_remove_plan_acc(p_id  IN VARCHAR2,
                                  p_del IN NUMBER DEFAULT 0)
    AS
      p_other_rec    other_zatraty % ROWTYPE;
      p_move_count   NUMBER;
      p_version      VARCHAR2(1000);
      in_use         EXCEPTION;
      PRAGMA EXCEPTION_INIT (in_use, -54);
      period_blocked EXCEPTION;
    BEGIN
      SELECT *
        INTO p_other_rec
        FROM OTHER_ZATRATY
        WHERE id = p_id FOR UPDATE NOWAIT;
      IF utility.enable_edit(p_other_rec.id, 'OTHER_ZATRATY') = 0
      THEN
        --return;
        RAISE period_blocked;
      END IF;

      SELECT TO_CHAR(version, 'YYYY-MM-DD HH24:MI:SS.FF')
        INTO p_version
        FROM OTHER_ZATRATY
        WHERE id = p_id;
      SELECT COUNT(*)
        INTO p_move_count
        FROM moves
        WHERE registrator_id = p_id;
      IF p_move_count > 0
      THEN
        EXECUTE IMMEDIATE ('select * from moves where registrator_id=''' || p_id || ''' for update nowait');
        DELETE FROM moves
          WHERE registrator_id = p_id;
      END IF;

      IF p_del <> 0
      THEN
        p_other_rec.deleted := 1;
      END IF;
      p_other_rec.posted := 0;
      UPDATE OTHER_ZATRATY
        SET ROW = p_other_rec
        WHERE id = p_id
        AND version = TO_TIMESTAMP(p_version, 'YYYY-MM-DD HH24:MI:SS.FF');
    EXCEPTION
      WHEN period_blocked THEN RAISE_APPLICATION_ERROR(-20003, 'Период заблокирован! Редактирование невозможно!', TRUE);
      WHEN IN_USE THEN RAISE_APPLICATION_ERROR(-20002, 'Resource in use! ' || SQLERRM, TRUE);
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error order move for plan accounting! ' || sqlerrm, TRUE);
    END other_remove_plan_acc;

  PROCEDURE other_move_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM OTHER_ZATRATY)
      LOOP
        other_move_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error other_zatraty move  all for plan accounting! ' || SQLERRM, TRUE);
    END other_move_all;

  PROCEDURE other_remove_all
    AS
    BEGIN
      FOR i IN (SELECT *
          FROM OTHER_ZATRATY)
      LOOP
        other_remove_plan_acc(i.id);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error other_zatraty remove all for plan accounting! ' || SQLERRM, TRUE);
    END other_remove_all;

END other_entry;

/

--
-- Описание для пакета KONTRAG
--
CREATE OR REPLACE PACKAGE "KONTRAG"
  AS

  PROCEDURE create_kontrag(p_parent   kontragents.parent_id % TYPE,
                           p_fullname kontragents.fullname % TYPE,
                           p_namefull kontragents.namefull % TYPE,
                           p_okpo     kontragents.okpo % TYPE,
                           p_inn      kontragents.inn % TYPE);

END KONTRAG;
/

CREATE OR REPLACE PACKAGE BODY "KONTRAG"
  AS

  PROCEDURE create_kontrag(p_parent   kontragents.parent_id % TYPE,
                           p_fullname kontragents.fullname % TYPE,
                           p_namefull kontragents.namefull % TYPE,
                           p_okpo     kontragents.okpo % TYPE,
                           p_inn      kontragents.inn % TYPE)
    AS
      p_kont_rec kontragents % ROWTYPE;
    BEGIN
      p_kont_rec.parent_id := p_parent;
      p_kont_rec.fullname := p_fullname;
      p_kont_rec.namefull := p_namefull;
      p_kont_rec.okpo := p_okpo;
      p_kont_rec.inn := p_inn;
      p_kont_rec.is_group := 0;
      p_kont_rec.deleted := 0;
      p_kont_rec.ur_fiz := 0;
      p_kont_rec.predefined := 0;
      p_kont_rec.version := systimestamp;
      INSERT INTO kontragents
      VALUES p_kont_rec;

    EXCEPTION
      WHEN OTHERS THEN RAISE;
    END create_kontrag;

END KONTRAG;

/

--
-- Описание для пакета FTP
--
CREATE OR REPLACE PACKAGE "FTP"
  AS
  -- --------------------------------------------------------------------------
  -- Name         : http://www.oracle-base.com/dba/miscellaneous/ftp.pks
  -- Author       : DR Timothy S Hall
  -- Description  : Basic FTP API. For usage notes see:
  --                  http://www.oracle-base.com/articles/misc/ftp-from-plsql.php
  -- Requirements : UTL_TCP
  -- Ammedments   :
  --   When         Who       What
  --   ===========  ========  =================================================
  --   14-AUG-2003  Tim Hall  Initial Creation
  --   10-MAR-2004  Tim Hall  Add convert_crlf procedure.
  --                          Make get_passive function visible.
  --                          Added get_direct and put_direct procedures.
  --   03-OCT-2006  Tim Hall  Add list, rename, delete, mkdir, rmdir procedures.
  --   15-Jan-2008  Tim Hall  login: Include timeout parameter (suggested by Dmitry Bogomolov).
  --   12-Jun-2008  Tim Hall  get_reply: Moved to pakage specification.
  --   22-Apr-2009  Tim Hall  nlst: Added to return list of file names only (suggested by Julian and John Duncan)
  -- --------------------------------------------------------------------------

  TYPE t_string_table IS TABLE OF VARCHAR2(32767);

  FUNCTION login(p_host    IN VARCHAR2,
                 p_port    IN VARCHAR2,
                 p_user    IN VARCHAR2,
                 p_pass    IN VARCHAR2,
                 p_timeout IN NUMBER := NULL)
    RETURN UTL_TCP.connection;

  FUNCTION get_passive(p_conn IN OUT NOCOPY UTL_TCP.connection)
    RETURN UTL_TCP.connection;

  PROCEDURE logout(p_conn  IN OUT NOCOPY UTL_TCP.connection,
                   p_reply IN            BOOLEAN := TRUE);

  PROCEDURE send_command(p_conn    IN OUT NOCOPY UTL_TCP.connection,
                         p_command IN            VARCHAR2,
                         p_reply   IN            BOOLEAN := TRUE);

  PROCEDURE get_reply(p_conn IN OUT NOCOPY UTL_TCP.connection);

  FUNCTION get_local_ascii_data(p_dir  IN VARCHAR2,
                                p_file IN VARCHAR2)
    RETURN CLOB;

  FUNCTION get_local_binary_data(p_dir  IN VARCHAR2,
                                 p_file IN VARCHAR2)
    RETURN BLOB;

  FUNCTION get_remote_ascii_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                 p_file IN            VARCHAR2)
    RETURN CLOB;

  FUNCTION get_remote_binary_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                  p_file IN            VARCHAR2)
    RETURN BLOB;

  PROCEDURE put_local_ascii_data(p_data IN CLOB,
                                 p_dir  IN VARCHAR2,
                                 p_file IN VARCHAR2);

  PROCEDURE put_local_binary_data(p_data IN BLOB,
                                  p_dir  IN VARCHAR2,
                                  p_file IN VARCHAR2);

  PROCEDURE put_remote_ascii_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                  p_file IN            VARCHAR2,
                                  p_data IN            CLOB);

  PROCEDURE put_remote_binary_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                   p_file IN            VARCHAR2,
                                   p_data IN            BLOB);

  PROCEDURE get(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                p_from_file IN            VARCHAR2,
                p_to_dir    IN            VARCHAR2,
                p_to_file   IN            VARCHAR2);

  PROCEDURE put(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                p_from_dir  IN            VARCHAR2,
                p_from_file IN            VARCHAR2,
                p_to_file   IN            VARCHAR2);

  PROCEDURE get_direct(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                       p_from_file IN            VARCHAR2,
                       p_to_dir    IN            VARCHAR2,
                       p_to_file   IN            VARCHAR2);

  PROCEDURE put_direct(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                       p_from_dir  IN            VARCHAR2,
                       p_from_file IN            VARCHAR2,
                       p_to_file   IN            VARCHAR2);

  PROCEDURE help(p_conn IN OUT NOCOPY UTL_TCP.connection);

  PROCEDURE ascii(p_conn IN OUT NOCOPY UTL_TCP.connection);

  PROCEDURE binary(p_conn IN OUT NOCOPY UTL_TCP.connection);

  PROCEDURE list(p_conn IN OUT NOCOPY UTL_TCP.connection,
                 p_dir  IN            VARCHAR2,
                 p_list OUT           t_string_table);

  PROCEDURE nlst(p_conn IN OUT NOCOPY UTL_TCP.connection,
                 p_dir  IN            VARCHAR2,
                 p_list OUT           t_string_table);

  PROCEDURE rename (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                  p_from  IN             VARCHAR2,
                  p_to    IN             VARCHAR2);

PROCEDURE

DELETE (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                  p_file  IN             VARCHAR2);

PROCEDURE mkdir (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                 p_dir   IN             VARCHAR2);

PROCEDURE rmdir (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                 p_dir   IN             VARCHAR2);

PROCEDURE convert_crlf (p_status  IN  BOOLEAN);

END ftp;
/

CREATE OR REPLACE PACKAGE BODY "FTP"
  AS
  -- --------------------------------------------------------------------------
  -- Name         : http://www.oracle-base.com/dba/miscellaneous/ftp.pkb
  -- Author       : DR Timothy S Hall
  -- Description  : Basic FTP API. For usage notes see:
  --                  http://www.oracle-base.com/articles/misc/ftp-from-plsql.php
  -- Requirements : http://www.oracle-base.com/dba/miscellaneous/ftp.pks
  -- Ammedments   :
  --   When         Who       What
  --   ===========  ========  =================================================
  --   14-AUG-2003  Tim Hall  Initial Creation
  --   10-MAR-2004  Tim Hall  Add convert_crlf procedure.
  --                          Incorporate CRLF conversion functionality into
  --                          put_local_ascii_data and put_remote_ascii_data
  --                          functions.
  --                          Make get_passive function visible.
  --                          Added get_direct and put_direct procedures.
  --   23-DEC-2004  Tim Hall  The get_reply procedure was altered to deal with
  --                          banners starting with 4 white spaces. This fix is
  --                          a small variation on the resolution provided by
  --                          Gary Mason who spotted the bug.
  --   10-NOV-2005  Tim Hall  Addition of get_reply after doing a transfer to
  --                          pickup the 226 Transfer complete message. This
  --                          allows gets and puts with a single connection.
  --                          Issue spotted by Trevor Woolnough.
  --   03-OCT-2006  Tim Hall  Add list, rename, delete, mkdir, rmdir procedures.
  --   12-JAN-2007  Tim Hall  A final call to get_reply was added to the get_remote%
  --                          procedures to allow multiple transfers per connection.
  --   15-Jan-2008  Tim Hall  login: Include timeout parameter (suggested by Dmitry Bogomolov).
  --   21-Jan-2008  Tim Hall  put_%: "l_pos < l_clob_len" to "l_pos <= l_clob_len" to prevent
  --                          potential loss of one character for single-byte files or files
  --                          sized 1 byte bigger than a number divisible by the buffer size
  --                          (spotted by Michael Surikov).
  --   23-Jan-2008  Tim Hall  send_command: Possible solution for ORA-29260 errors included,
  --                          but commented out (suggested by Kevin Phillips).
  --   12-Feb-2008  Tim Hall  put_local_binary_data and put_direct: Open file with "wb" for
  --                          binary writes (spotted by Dwayne Hoban).
  --   03-Mar-2008  Tim Hall  list: get_reply call and close of passive connection added
  --                          (suggested by Julian, Bavaria).
  --   12-Jun-2008  Tim Hall  A final call to get_reply was added to the put_remote%
  --                          procedures, but commented out. If uncommented, it may cause the
  --                          operation to hang, but it has been reported (morgul) to allow
  --                          multiple transfers per connection.
  --                          get_reply: Moved to pakage specification.
  --   24-Jun-2008  Tim Hall  get_remote% and put_remote%: Exception handler added to close the passive
  --                          connection and reraise the error (suggested by Mark Reichman).
  --   22-Apr-2009  Tim Hall  get_remote_ascii_data: Remove unnecessary logout (suggested by John Duncan).
  --                          get_reply and list: Handle 400 messages as well as 500 messages (suggested by John Duncan).
  --                          logout: Added a call to UTL_TCP.close_connection, so not necessary to close
  --                          any connections manually (suggested by Victor Munoz).
  --                          get_local_*_data: Check for zero length files to prevent exception (suggested by Daniel)
  --                          nlst: Added to return list of file names only (suggested by Julian and John Duncan)
  --   05-Apr-2011  Tim Hall  put_remote_ascii_data: Added comment on definition of l_amount. Switch to 10000 if you get
  --                          ORA-06502 from this line. May give you unexpected result due to conversion. Better to use binary.
  -- --------------------------------------------------------------------------

  g_reply t_string_table := t_string_table();
  g_binary BOOLEAN := TRUE;
  g_debug BOOLEAN := TRUE;
  g_convert_crlf BOOLEAN := TRUE;

  PROCEDURE debug(p_text IN VARCHAR2);

  -- --------------------------------------------------------------------------
  FUNCTION login(p_host    IN VARCHAR2,
                 p_port    IN VARCHAR2,
                 p_user    IN VARCHAR2,
                 p_pass    IN VARCHAR2,
                 p_timeout IN NUMBER := NULL)
    RETURN UTL_TCP.connection
    IS
      -- --------------------------------------------------------------------------
      l_conn UTL_TCP.connection;
    BEGIN
      g_reply.DELETE;

      l_conn := UTL_TCP.open_connection(p_host, p_port, tx_timeout => p_timeout);
      get_reply(l_conn);
      send_command(l_conn, 'USER ' || p_user);
      send_command(l_conn, 'PASS ' || p_pass);
      RETURN l_conn;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  FUNCTION get_passive(p_conn IN OUT NOCOPY UTL_TCP.connection)
    RETURN UTL_TCP.connection
    IS
      -- --------------------------------------------------------------------------
      l_conn  UTL_TCP.connection;
      l_reply VARCHAR2(32767);
      l_host  VARCHAR(100);
      l_port1 NUMBER(10);
      l_port2 NUMBER(10);
    BEGIN
      send_command(p_conn, 'PASV');
      l_reply := g_reply(g_reply.LAST);

      l_reply := REPLACE(SUBSTR(l_reply, INSTR(l_reply, '(') + 1, (INSTR(l_reply, ')')) - (INSTR(l_reply, '(')) - 1), ',', '.');
      l_host := SUBSTR(l_reply, 1, INSTR(l_reply, '.', 1, 4) - 1);

      l_port1 := TO_NUMBER(SUBSTR(l_reply, INSTR(l_reply, '.', 1, 4) + 1, (INSTR(l_reply, '.', 1, 5) - 1) - (INSTR(l_reply, '.', 1, 4))));
      l_port2 := TO_NUMBER(SUBSTR(l_reply, INSTR(l_reply, '.', 1, 5) + 1));

      l_conn := utl_tcp.open_connection(l_host, 256 * l_port1 + l_port2);
      RETURN l_conn;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE logout(p_conn  IN OUT NOCOPY UTL_TCP.connection,
                   p_reply IN            BOOLEAN := TRUE)
    AS
    -- --------------------------------------------------------------------------
    BEGIN
      send_command(p_conn, 'QUIT', p_reply);
      UTL_TCP.close_connection(p_conn);
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE send_command(p_conn    IN OUT NOCOPY UTL_TCP.connection,
                         p_command IN            VARCHAR2,
                         p_reply   IN            BOOLEAN := TRUE)
    IS
      -- --------------------------------------------------------------------------
      l_result PLS_INTEGER;
    BEGIN
      l_result := UTL_TCP.write_line(p_conn, p_command);
      -- If you get ORA-29260 after the PASV call, replace the above line with the following line.
      -- l_result := UTL_TCP.write_text(p_conn, p_command || utl_tcp.crlf, length(p_command || utl_tcp.crlf));

      IF p_reply
      THEN
        get_reply(p_conn);
      END IF;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE get_reply(p_conn IN OUT NOCOPY UTL_TCP.connection)
    IS
      -- --------------------------------------------------------------------------
      l_reply_code VARCHAR2(3) := NULL;
    BEGIN
      LOOP
        g_reply.EXTEND;
        g_reply(g_reply.LAST) := UTL_TCP.get_line(p_conn, TRUE);
        DEBUG(g_reply(g_reply.LAST));
        IF l_reply_code IS NULL
        THEN
          l_reply_code := SUBSTR(g_reply(g_reply.LAST), 1, 3);
        END IF;
        IF SUBSTR(l_reply_code, 1, 1) IN ('4', '5')
        THEN
          RAISE_APPLICATION_ERROR(-20000, g_reply(g_reply.LAST));
        ELSIF (SUBSTR(g_reply(g_reply.LAST), 1, 3) = l_reply_code
          AND SUBSTR(g_reply(g_reply.LAST), 4, 1) = ' ')
        THEN
          EXIT;
        END IF;
      END LOOP;
    EXCEPTION
      WHEN UTL_TCP.END_OF_INPUT THEN NULL;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  FUNCTION get_local_ascii_data(p_dir  IN VARCHAR2,
                                p_file IN VARCHAR2)
    RETURN CLOB
    IS
      -- --------------------------------------------------------------------------
      l_bfile BFILE;
      l_data  CLOB;
    BEGIN
      DBMS_LOB.createtemporary(lob_loc => l_data,
      cache => TRUE,
      dur => DBMS_LOB.call);

      l_bfile := BFILENAME(p_dir, p_file);
      DBMS_LOB.fileopen(l_bfile, DBMS_LOB.file_readonly);

      IF DBMS_LOB.getlength(l_bfile) > 0
      THEN
        DBMS_LOB.loadfromfile(l_data, l_bfile, DBMS_LOB.getlength(l_bfile));
      END IF;

      DBMS_LOB.fileclose(l_bfile);

      RETURN l_data;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  FUNCTION get_local_binary_data(p_dir  IN VARCHAR2,
                                 p_file IN VARCHAR2)
    RETURN BLOB
    IS
      -- --------------------------------------------------------------------------
      l_bfile BFILE;
      l_data  BLOB;
    BEGIN
      DBMS_LOB.createtemporary(lob_loc => l_data,
      cache => TRUE,
      dur => DBMS_LOB.call);

      l_bfile := BFILENAME(p_dir, p_file);
      DBMS_LOB.fileopen(l_bfile, DBMS_LOB.file_readonly);
      IF DBMS_LOB.getlength(l_bfile) > 0
      THEN
        DBMS_LOB.loadfromfile(l_data, l_bfile, DBMS_LOB.getlength(l_bfile));
      END IF;
      DBMS_LOB.fileclose(l_bfile);

      RETURN l_data;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  FUNCTION get_remote_ascii_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                 p_file IN            VARCHAR2)
    RETURN CLOB
    IS
      -- --------------------------------------------------------------------------
      l_conn   UTL_TCP.connection;
      l_amount PLS_INTEGER;
      l_buffer VARCHAR2(32767);
      l_data   CLOB;
    BEGIN
      DBMS_LOB.createtemporary(lob_loc => l_data,
      cache => TRUE,
      dur => DBMS_LOB.call);

      l_conn := get_passive(p_conn);
      send_command(p_conn, 'RETR ' || p_file, TRUE);
      --logout(l_conn, FALSE);

      BEGIN
        LOOP
          l_amount := UTL_TCP.read_text(l_conn, l_buffer, 32767);
          DBMS_LOB.writeappend(l_data, l_amount, l_buffer);
        END LOOP;
      EXCEPTION
        WHEN UTL_TCP.END_OF_INPUT THEN NULL;
        WHEN OTHERS THEN NULL;
      END;
      UTL_TCP.close_connection(l_conn);
      get_reply(p_conn);

      RETURN l_data;

    EXCEPTION
      WHEN OTHERS THEN UTL_TCP.close_connection(l_conn);
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  FUNCTION get_remote_binary_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                  p_file IN            VARCHAR2)
    RETURN BLOB
    IS
      -- --------------------------------------------------------------------------
      l_conn   UTL_TCP.connection;
      l_amount PLS_INTEGER;
      l_buffer RAW(32767);
      l_data   BLOB;
    BEGIN
      DBMS_LOB.createtemporary(lob_loc => l_data,
      cache => TRUE,
      dur => DBMS_LOB.call);

      l_conn := get_passive(p_conn);
      send_command(p_conn, 'RETR ' || p_file, TRUE);

      BEGIN
        LOOP
          l_amount := UTL_TCP.read_raw(l_conn, l_buffer, 32767);
          DBMS_LOB.writeappend(l_data, l_amount, l_buffer);
        END LOOP;
      EXCEPTION
        WHEN UTL_TCP.END_OF_INPUT THEN NULL;
        WHEN OTHERS THEN NULL;
      END;
      UTL_TCP.close_connection(l_conn);
      get_reply(p_conn);

      RETURN l_data;

    EXCEPTION
      WHEN OTHERS THEN UTL_TCP.close_connection(l_conn);
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE put_local_ascii_data(p_data IN CLOB,
                                 p_dir  IN VARCHAR2,
                                 p_file IN VARCHAR2)
    IS
      -- --------------------------------------------------------------------------
      l_out_file UTL_FILE.file_type;
      l_buffer   VARCHAR2(32767);
      l_amount   BINARY_INTEGER := 32767;
      l_pos      INTEGER        := 1;
      l_clob_len INTEGER;
    BEGIN
      l_clob_len := DBMS_LOB.getlength(p_data);

      l_out_file := UTL_FILE.fopen(p_dir, p_file, 'w', 32767);

      WHILE l_pos <= l_clob_len
        LOOP
          DBMS_LOB.read(p_data, l_amount, l_pos, l_buffer);
          IF g_convert_crlf
          THEN
            l_buffer := REPLACE(l_buffer, CHR(13), NULL);
          END IF;

          UTL_FILE.put(l_out_file, l_buffer);
          UTL_FILE.fflush(l_out_file);
          l_pos := l_pos + l_amount;
        END LOOP;

      UTL_FILE.fclose(l_out_file);
    EXCEPTION
      WHEN OTHERS THEN IF UTL_FILE.is_open(l_out_file)
          THEN
            UTL_FILE.fclose(l_out_file);
          END IF;
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE put_local_binary_data(p_data IN BLOB,
                                  p_dir  IN VARCHAR2,
                                  p_file IN VARCHAR2)
    IS
      -- --------------------------------------------------------------------------
      l_out_file UTL_FILE.file_type;
      l_buffer   RAW(32767);
      l_amount   BINARY_INTEGER := 32767;
      l_pos      INTEGER        := 1;
      l_blob_len INTEGER;
    BEGIN
      l_blob_len := DBMS_LOB.getlength(p_data);

      l_out_file := UTL_FILE.fopen(p_dir, p_file, 'wb', 32767);

      WHILE l_pos <= l_blob_len
        LOOP
          DBMS_LOB.read(p_data, l_amount, l_pos, l_buffer);
          UTL_FILE.put_raw(l_out_file, l_buffer, TRUE);
          UTL_FILE.fflush(l_out_file);
          l_pos := l_pos + l_amount;
        END LOOP;

      UTL_FILE.fclose(l_out_file);
    EXCEPTION
      WHEN OTHERS THEN IF UTL_FILE.is_open(l_out_file)
          THEN
            UTL_FILE.fclose(l_out_file);
          END IF;
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE put_remote_ascii_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                  p_file IN            VARCHAR2,
                                  p_data IN            CLOB)
    IS
      -- --------------------------------------------------------------------------
      l_conn     UTL_TCP.connection;
      l_result   PLS_INTEGER;
      l_buffer   VARCHAR2(32767);
      l_amount   BINARY_INTEGER := 32767; -- Switch to 10000 (or use binary) if you get ORA-06502 from this line.
      l_pos      INTEGER        := 1;
      l_clob_len INTEGER;
    BEGIN
      l_conn := get_passive(p_conn);
      send_command(p_conn, 'STOR ' || p_file, TRUE);

      l_clob_len := DBMS_LOB.getlength(p_data);

      WHILE l_pos <= l_clob_len
        LOOP
          DBMS_LOB.READ(p_data, l_amount, l_pos, l_buffer);
          IF g_convert_crlf
          THEN
            l_buffer := REPLACE(l_buffer, CHR(13), NULL);
          END IF;
          l_result := UTL_TCP.write_text(l_conn, l_buffer, LENGTH(l_buffer));
          UTL_TCP.flush(l_conn);
          l_pos := l_pos + l_amount;
        END LOOP;

      UTL_TCP.close_connection(l_conn);
    -- The following line allows some people to make multiple calls from one connection.
    -- It causes the operation to hang for me, hence it is commented out by default.
    -- get_reply(p_conn);

    EXCEPTION
      WHEN OTHERS THEN UTL_TCP.close_connection(l_conn);
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE put_remote_binary_data(p_conn IN OUT NOCOPY UTL_TCP.connection,
                                   p_file IN            VARCHAR2,
                                   p_data IN            BLOB)
    IS
      -- --------------------------------------------------------------------------
      l_conn     UTL_TCP.connection;
      l_result   PLS_INTEGER;
      l_buffer   RAW(32767);
      l_amount   BINARY_INTEGER := 32767;
      l_pos      INTEGER        := 1;
      l_blob_len INTEGER;
    BEGIN
      l_conn := get_passive(p_conn);
      send_command(p_conn, 'STOR ' || p_file, TRUE);

      l_blob_len := DBMS_LOB.getlength(p_data);

      WHILE l_pos <= l_blob_len
        LOOP
          DBMS_LOB.READ(p_data, l_amount, l_pos, l_buffer);
          l_result := UTL_TCP.write_raw(l_conn, l_buffer, l_amount);
          UTL_TCP.flush(l_conn);
          l_pos := l_pos + l_amount;
        END LOOP;

      UTL_TCP.close_connection(l_conn);
    -- The following line allows some people to make multiple calls from one connection.
    -- It causes the operation to hang for me, hence it is commented out by default.
    -- get_reply(p_conn);

    EXCEPTION
      WHEN OTHERS THEN UTL_TCP.close_connection(l_conn);
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE get(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                p_from_file IN            VARCHAR2,
                p_to_dir    IN            VARCHAR2,
                p_to_file   IN            VARCHAR2)
    AS
    -- --------------------------------------------------------------------------
    BEGIN
      IF g_binary
      THEN
        put_local_binary_data(p_data => get_remote_binary_data(p_conn, p_from_file),
        p_dir => p_to_dir,
        p_file => p_to_file);
      ELSE
        put_local_ascii_data(p_data => get_remote_ascii_data(p_conn, p_from_file),
        p_dir => p_to_dir,
        p_file => p_to_file);
      END IF;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE put(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                p_from_dir  IN            VARCHAR2,
                p_from_file IN            VARCHAR2,
                p_to_file   IN            VARCHAR2)
    AS
    -- --------------------------------------------------------------------------
    BEGIN
      IF g_binary
      THEN
        put_remote_binary_data(p_conn => p_conn,
        p_file => p_to_file,
        p_data => get_local_binary_data(p_from_dir, p_from_file));
      ELSE
        put_remote_ascii_data(p_conn => p_conn,
        p_file => p_to_file,
        p_data => get_local_ascii_data(p_from_dir, p_from_file));
      END IF;
      get_reply(p_conn);
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE get_direct(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                       p_from_file IN            VARCHAR2,
                       p_to_dir    IN            VARCHAR2,
                       p_to_file   IN            VARCHAR2)
    IS
      -- --------------------------------------------------------------------------
      l_conn       UTL_TCP.connection;
      l_out_file   UTL_FILE.file_type;
      l_amount     PLS_INTEGER;
      l_buffer     VARCHAR2(32767);
      l_raw_buffer RAW(32767);
    BEGIN
      l_conn := get_passive(p_conn);
      send_command(p_conn, 'RETR ' || p_from_file, TRUE);
      IF g_binary
      THEN
        l_out_file := UTL_FILE.fopen(p_to_dir, p_to_file, 'wb', 32767);
      ELSE
        l_out_file := UTL_FILE.fopen(p_to_dir, p_to_file, 'w', 32767);
      END IF;

      BEGIN
        LOOP
          IF g_binary
          THEN
            l_amount := UTL_TCP.read_raw(l_conn, l_raw_buffer, 32767);
            UTL_FILE.put_raw(l_out_file, l_raw_buffer, TRUE);
          ELSE
            l_amount := UTL_TCP.read_text(l_conn, l_buffer, 32767);
            IF g_convert_crlf
            THEN
              l_buffer := REPLACE(l_buffer, CHR(13), NULL);
            END IF;
            UTL_FILE.put(l_out_file, l_buffer);
          END IF;
          UTL_FILE.fflush(l_out_file);
        END LOOP;
      EXCEPTION
        WHEN UTL_TCP.END_OF_INPUT THEN NULL;
        WHEN OTHERS THEN NULL;
      END;
      UTL_FILE.fclose(l_out_file);
      UTL_TCP.close_connection(l_conn);
    EXCEPTION
      WHEN OTHERS THEN IF UTL_FILE.is_open(l_out_file)
          THEN
            UTL_FILE.fclose(l_out_file);
          END IF;
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE put_direct(p_conn      IN OUT NOCOPY UTL_TCP.connection,
                       p_from_dir  IN            VARCHAR2,
                       p_from_file IN            VARCHAR2,
                       p_to_file   IN            VARCHAR2)
    IS
      -- --------------------------------------------------------------------------
      l_conn       UTL_TCP.connection;
      l_bfile      BFILE;
      l_result     PLS_INTEGER;
      l_amount     PLS_INTEGER := 32767;
      l_raw_buffer RAW(32767);
      l_len        NUMBER;
      l_pos        NUMBER      := 1;
      ex_ascii     EXCEPTION;
    BEGIN
      IF NOT g_binary
      THEN
        RAISE ex_ascii;
      END IF;

      l_conn := get_passive(p_conn);
      send_command(p_conn, 'STOR ' || p_to_file, TRUE);

      l_bfile := BFILENAME(p_from_dir, p_from_file);

      DBMS_LOB.fileopen(l_bfile, DBMS_LOB.file_readonly);
      l_len := DBMS_LOB.getlength(l_bfile);

      WHILE l_pos <= l_len
        LOOP
          DBMS_LOB.READ(l_bfile, l_amount, l_pos, l_raw_buffer);
          DEBUG(l_amount);
          l_result := UTL_TCP.write_raw(l_conn, l_raw_buffer, l_amount);
          l_pos := l_pos + l_amount;
        END LOOP;

      DBMS_LOB.fileclose(l_bfile);
      UTL_TCP.close_connection(l_conn);
    EXCEPTION
      WHEN ex_ascii THEN RAISE_APPLICATION_ERROR(-20000, 'PUT_DIRECT not available in ASCII mode.');
      WHEN OTHERS THEN IF DBMS_LOB.fileisopen(l_bfile) = 1
          THEN
            DBMS_LOB.fileclose(l_bfile);
          END IF;
          RAISE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE help(p_conn IN OUT NOCOPY UTL_TCP.connection)
    AS
    -- --------------------------------------------------------------------------
    BEGIN
      send_command(p_conn, 'HELP', TRUE);
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE ascii(p_conn IN OUT NOCOPY UTL_TCP.connection)
    AS
    -- --------------------------------------------------------------------------
    BEGIN
      send_command(p_conn, 'TYPE A', TRUE);
      g_binary := FALSE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE binary(p_conn IN OUT NOCOPY UTL_TCP.connection)
    AS
    -- --------------------------------------------------------------------------
    BEGIN
      send_command(p_conn, 'TYPE I', TRUE);
      g_binary := TRUE;
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE list(p_conn IN OUT NOCOPY UTL_TCP.connection,
                 p_dir  IN            VARCHAR2,
                 p_list OUT           t_string_table)
    AS
      -- --------------------------------------------------------------------------
      l_conn       UTL_TCP.connection;
      l_list       t_string_table := t_string_table();
      l_reply_code VARCHAR2(3)    := NULL;
    BEGIN
      l_conn := get_passive(p_conn);
      send_command(p_conn, 'LIST ' || p_dir, TRUE);

      BEGIN
        LOOP
          l_list.EXTEND;
          l_list(l_list.LAST) := UTL_TCP.get_line(l_conn, TRUE);
          DEBUG(l_list(l_list.LAST));
          IF l_reply_code IS NULL
          THEN
            l_reply_code := SUBSTR(l_list(l_list.LAST), 1, 3);
          END IF;
          IF SUBSTR(l_reply_code, 1, 1) IN ('4', '5')
          THEN
            RAISE_APPLICATION_ERROR(-20000, l_list(l_list.LAST));
          ELSIF (SUBSTR(g_reply(g_reply.LAST), 1, 3) = l_reply_code
            AND SUBSTR(g_reply(g_reply.LAST), 4, 1) = ' ')
          THEN
            EXIT;
          END IF;
        END LOOP;
      EXCEPTION
        WHEN UTL_TCP.END_OF_INPUT THEN NULL;
      END;

      l_list.DELETE(l_list.LAST);
      p_list := l_list;

      utl_tcp.close_connection(l_conn);
      get_reply(p_conn);
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE nlst(p_conn IN OUT NOCOPY UTL_TCP.connection,
                 p_dir  IN            VARCHAR2,
                 p_list OUT           t_string_table)
    AS
      -- --------------------------------------------------------------------------
      l_conn       UTL_TCP.connection;
      l_list       t_string_table := t_string_table();
      l_reply_code VARCHAR2(3)    := NULL;
    BEGIN
      l_conn := get_passive(p_conn);
      send_command(p_conn, 'NLST ' || p_dir, TRUE);

      BEGIN
        LOOP
          l_list.EXTEND;
          l_list(l_list.LAST) := UTL_TCP.get_line(l_conn, TRUE);
          DEBUG(l_list(l_list.LAST));
          IF l_reply_code IS NULL
          THEN
            l_reply_code := SUBSTR(l_list(l_list.LAST), 1, 3);
          END IF;
          IF SUBSTR(l_reply_code, 1, 1) IN ('4', '5')
          THEN
            RAISE_APPLICATION_ERROR(-20000, l_list(l_list.LAST));
          ELSIF (SUBSTR(g_reply(g_reply.LAST), 1, 3) = l_reply_code
            AND SUBSTR(g_reply(g_reply.LAST), 4, 1) = ' ')
          THEN
            EXIT;
          END IF;
        END LOOP;
      EXCEPTION
        WHEN UTL_TCP.END_OF_INPUT THEN NULL;
      END;

      l_list.DELETE(l_list.LAST);
      p_list := l_list;

      utl_tcp.close_connection(l_conn);
      get_reply(p_conn);
    END;
  -- --------------------------------------------------------------------------



  -- --------------------------------------------------------------------------
  PROCEDURE rename (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                  p_from  IN             VARCHAR2,
                  p_to    IN             VARCHAR2) AS
-- --------------------------------------------------------------------------
  l_conn  UTL_TCP.connection;

BEGIN
  l_conn := get_passive(p_conn);
  send_command(p_conn, 'RNFR ' || p_from, TRUE);
  send_command(p_conn, 'RNTO ' || p_to, TRUE);
  logout(l_conn, FALSE);
END RENAME;
-- --------------------------------------------------------------------------



-- --------------------------------------------------------------------------
PROCEDURE
DELETE (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                  p_file  IN             VARCHAR2) AS
-- --------------------------------------------------------------------------
  l_conn  UTL_TCP.connection;
BEGIN
  l_conn := get_passive(p_conn);
  send_command(p_conn, 'DELE ' || p_file, TRUE);
  logout(l_conn, FALSE);
END DELETE;
-- --------------------------------------------------------------------------



-- --------------------------------------------------------------------------
PROCEDURE mkdir (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                 p_dir   IN             VARCHAR2) AS
-- --------------------------------------------------------------------------
  l_conn  UTL_TCP.connection;
BEGIN
  l_conn := get_passive(p_conn);
  send_command(p_conn, 'MKD ' || p_dir, TRUE);
  logout(l_conn, FALSE);
END mkdir;
-- --------------------------------------------------------------------------



-- --------------------------------------------------------------------------
PROCEDURE rmdir (p_conn  IN OUT NOCOPY  UTL_TCP.connection,
                 p_dir   IN             VARCHAR2) AS
-- --------------------------------------------------------------------------
  l_conn  UTL_TCP.connection;
BEGIN
  l_conn := get_passive(p_conn);
  send_command(p_conn, 'RMD ' || p_dir, TRUE);
  logout(l_conn, FALSE);
END rmdir;
-- --------------------------------------------------------------------------



-- --------------------------------------------------------------------------
PROCEDURE convert_crlf (p_status  IN  BOOLEAN) AS
-- --------------------------------------------------------------------------
BEGIN
  g_convert_crlf := p_status;
END;
-- --------------------------------------------------------------------------



-- --------------------------------------------------------------------------
PROCEDURE debug (p_text  IN  VARCHAR2) IS
-- --------------------------------------------------------------------------
BEGIN
  IF g_debug
  THEN
    DBMS_OUTPUT.put_line(SUBSTR(p_text, 1, 255));
  END IF;
END;
-- --------------------------------------------------------------------------

END ftp;
/

--
-- Описание для пакета CURRENCY_PKG
--
CREATE OR REPLACE PACKAGE "CURRENCY_PKG"
  AS

  FUNCTION get_xmlfromurl(p_url     VARCHAR2,
                          p_charset VARCHAR2 DEFAULT 'UTF8')
    RETURN XMLTYPE;
  PROCEDURE getratebydate(p_code IN currency.id % TYPE,
                          p_dat  IN DATE);
  PROCEDURE getratebyShedule;
  FUNCTION get_lastSectionRates(p_code IN currency.id % TYPE,
                                p_dat  IN DATE)
    RETURN VARCHAR2;
  FUNCTION calculate_from_curr_to_curr(p_curr_from IN currency.id % TYPE,
                                       p_curr_to   IN currency.id % TYPE,
                                       p_dat       IN DATE,
                                       p_summ         NUMBER)
    RETURN NUMBER;

END currency_pkg;
/

CREATE OR REPLACE PACKAGE BODY "CURRENCY_PKG"
  AS

  FUNCTION get_xmlFromUrl(p_url     VARCHAR2,
                          p_charset VARCHAR2 DEFAULT 'UTF8')
    RETURN XMLTYPE
    AS
      req  utl_http.req;
      resp utl_http.resp;
      val  VARCHAR2(32547);
      a    CLOB;
    BEGIN
      dbms_lob.createtemporary(a, TRUE);
      dbms_lob.open(a, dbms_lob.lob_readwrite);
      req := utl_http.begin_request(p_url);
      utl_http.set_body_charset(req, p_charset);
      resp := utl_http.get_response(req);
      LOOP
        a := a || val;
        utl_http.read_text(resp, val, 5000);
      END LOOP;
      utl_http.end_response(resp);
      RETURN xmltype(a);
    EXCEPTION
      WHEN utl_http.end_of_body THEN utl_http.end_response(resp);
          RETURN xmltype(a);
      WHEN OTHERS THEN utl_http.end_response(resp);
          RAISE;
    END;

  PROCEDURE getratebydate(p_code IN currency.id % TYPE,
                          p_dat  IN DATE)
    AS
      p_curr_rec currency % ROWTYPE;
      p_rates    reg_rates % ROWTYPE;
      p_date_str VARCHAR2(10);
      nominal    NUMBER(10, 0);
      val        NUMBER(10, 6);
      p_count    NUMBER;
    BEGIN
      SELECT COUNT(*)
        INTO p_count
        FROM reg_rates
        WHERE curr_id = p_code
          AND TO_CHAR(period, 'dd-mm-yyyy') = TO_CHAR(p_dat, 'dd-mm-yyyy');
      IF p_count <> 0
      THEN
        RETURN;
      END IF;
      SELECT *
        INTO p_curr_rec
        FROM currency
        WHERE id = p_code;

      SELECT TO_NUMBER(EXTRACTVALUE(VALUE(dtl), 'item/size'), '9999'),
             TO_NUMBER(EXTRACTVALUE(VALUE(dtl), 'item/rate'), '9999.999999')
        INTO nominal,
             val
        FROM (SELECT currency_pkg.get_xmlfromurl('http://bank-ua.com/export/currrate.xml', 'CL8MSWIN1251') xml
                 FROM dual) s,
             TABLE (XMLSEQUENCE(s.xml.extract('chapter/item'))) dtl
        WHERE EXTRACTVALUE(VALUE(dtl), 'item/code') = p_curr_rec.code;
      --select to_char(p_dat,'dd')|| to_char(p_dat,'mm')|| to_char(p_dat,'yyyy') into p_date_str from dual;

      --select to_number(t.xml.extract('//ValCurs/Valute[@id='||p_curr_rec.id_xml||']/Nominal/text()'),'9999'),
      --to_number(t.xml.extract('//ValCurs/Valute[@id='||p_curr_rec.id_xml||']/Value/text()'),'9999.999999') into nominal, val
      --from (select currency_pkg.get_xmlfromurl('http://pfsoft.com.ua/service/currency/?date='||p_date_str||'','CL8MSWIN1251') xml from dual) t;

      INSERT INTO reg_rates (
        curr_id, period, kurs, kratnost
      )
      VALUES (p_code, p_dat, val, nominal);

    EXCEPTION
      WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20001, 'Error getting rates! ' || SQLERRM, TRUE);
    END;

  FUNCTION get_lastsectionrates(p_code IN currency.id % TYPE,
                                p_dat  IN DATE)
    RETURN VARCHAR2
    AS
      res VARCHAR2(50);
    BEGIN
      SELECT id
        INTO res
        FROM reg_rates
        WHERE period = (SELECT MAX(period)
              FROM reg_rates
              WHERE curr_id = p_code
                AND period <= p_dat)
          AND curr_id = p_code
          AND ROWNUM = 1;

      RETURN res;
    END;

  PROCEDURE getratebyshedule
    AS
      p_date_str VARCHAR2(50);
      p_date     DATE;
    BEGIN
      p_date_str := TO_CHAR(sysdate, 'dd-mm-yyyy');
      p_date := TO_DATE(p_date_str, 'DD-MM-YYYY');
      FOR i IN (SELECT *
          FROM ex_rates_settings)
      LOOP
        getratebydate(i.curr_id, p_date);
      END LOOP;
    END;

  FUNCTION calculate_from_curr_to_curr(p_curr_from IN currency.id % TYPE,
                                       p_curr_to   IN currency.id % TYPE,
                                       p_dat       IN DATE,
                                       p_summ         NUMBER)
    RETURN NUMBER
    AS
      res         NUMBER(10, 2);
      p_rate_from NUMBER;
      p_rate_to   NUMBER;
    BEGIN
      SELECT kurs / kratnost
        INTO p_rate_from
        FROM reg_rates
        WHERE id = get_lastsectionrates(p_curr_from, p_dat);
      SELECT kurs / kratnost
        INTO p_rate_to
        FROM reg_rates
        WHERE id = get_lastsectionrates(p_curr_to, p_dat);
      res := p_summ * p_rate_from / p_rate_to;
      RETURN res;
    END;

END currency_pkg;

/

--
-- Описание для функции RANDOMUUID
--
CREATE OR REPLACE FUNCTION "RANDOMUUID"
  RETURN VARCHAR2
  AS
  LANGUAGE JAVA
  NAME 'RandomUUID.create() return java.lang.String';
/

--
-- Описание для функции PLAN_TYPE_SUBCONTO_CONV
--
CREATE OR REPLACE FUNCTION "PLAN_TYPE_SUBCONTO_CONV"(bl_expr IN VARCHAR2)
  RETURN VARCHAR2
  AS
    p_ref VARCHAR2(50);
  BEGIN
    IF UPPER(bl_expr) = 'ЦФО'
    THEN
      SELECT id
        INTO p_ref
        FROM plan_type_subconto
        WHERE type_of_obj = (SELECT id
              FROM type_def
              WHERE table_name = 'DIVISIONS');
      RETURN p_ref;
    END IF;
    IF UPPER(bl_expr) = 'НОМЕНКЛАТУРА'
    THEN
      SELECT id
        INTO p_ref
        FROM plan_type_subconto
        WHERE type_of_obj = (SELECT id
              FROM type_def
              WHERE table_name = 'NOMENKLATURA');
      RETURN p_ref;
    END IF;
    IF UPPER(bl_expr) = 'КОНТРАГЕНТЫ'
    THEN
      SELECT id
        INTO p_ref
        FROM plan_type_subconto
        WHERE type_of_obj = (SELECT id
              FROM type_def
              WHERE table_name = 'KONTRAGENTS');
      RETURN p_ref;
    END IF;
    IF UPPER(bl_expr) = 'КАССА'
    THEN
      SELECT id
        INTO p_ref
        FROM plan_type_subconto
        WHERE type_of_obj = (SELECT id
              FROM type_def
              WHERE table_name = 'KASSA');
      RETURN p_ref;
    END IF;
    IF UPPER(bl_expr) = 'СТАТЬЯ ЗАТРАТ'
    THEN
      SELECT id
        INTO p_ref
        FROM plan_type_subconto
        WHERE type_of_obj = (SELECT id
              FROM type_def
              WHERE table_name = 'ZATRATY');
      RETURN p_ref;
    END IF;
    RETURN NULL;
  END plan_type_subconto_conv;
/

--
-- Описание для функции GET_USERS_FOR_ZAMER
--
CREATE OR REPLACE FUNCTION "GET_USERS_FOR_ZAMER"(p_u_name IN VARCHAR2)
  RETURN userTable
  IS
    l_data    userTable := userTable();
    p_idrole  NUMBER;
    p_iduser  VARCHAR2(50);
    p_counter NUMBER    := 0;
  BEGIN
    SELECT id,
           is_admin
      INTO p_iduser,
           p_idrole
      FROM users
      WHERE UPPER(login) LIKE UPPER(p_u_name);

    IF p_idrole = 1
    THEN
      FOR i IN (SELECT id,
                       UPPER(login) login
          FROM users)
      LOOP
        p_counter := p_counter + 1;
        l_data.EXTEND;
        l_data(p_counter) := userType(i.id, i.login);
      END LOOP;
      RETURN l_data;
    END IF;

    --select nvl(count(*),0) into p_counter from divisions where main_user = p_iduser;
    SELECT COUNT(*)
      INTO p_counter
      FROM GROUPMEMBERS
      WHERE UPPER(G_MEMBER) LIKE UPPER(p_u_name)
        AND G_NAME IN ('director', 'manager', 'cc_manager');
    IF p_counter > 0
    THEN
      p_idrole := 2; --Директор, менеджер
    ELSE
      p_idrole := 3; --Диспетчер замеров
    END IF;

    IF p_idrole = 2
    THEN
      p_counter := 0;
      FOR i IN (SELECT id,
                       s.use_r
          FROM (SELECT (SELECT id
                           FROM users
                           WHERE id = s.user_id) AS id,
                       (SELECT UPPER(login)
                           FROM users
                           WHERE id = s.user_id) AS use_r
              FROM divisions d
                INNER JOIN division_sotr s
                  ON s.div_id = d.id
            --where d.deleted = 0
            CONNECT BY PRIOR d.id = d.parent_id
            START WITH d.id = (SELECT id
                FROM divisions
                WHERE main_user = p_iduser
                  AND ROWNUM = 1)
              UNION
            SELECT id,
                   UPPER(login)
              FROM users
              WHERE id = p_iduser) s)
      LOOP
        p_counter := p_counter + 1;
        l_data.EXTEND;
        l_data(p_counter) := userType(i.id, i.use_r);
      END LOOP;
      RETURN l_data;
    END IF;

    p_counter := 0;
    FOR i IN (SELECT id,
                     s.use_r
        FROM (SELECT (SELECT id
                         FROM users
                         WHERE id = s.user_id) AS id,
                     (SELECT UPPER(login)
                         FROM users
                         WHERE id = s.user_id) AS use_r
            FROM divisions d
              INNER JOIN division_sotr s
                ON s.div_id = d.id
          --where d.deleted = 0
          CONNECT BY PRIOR d.id = d.parent_id
          START WITH d.id IN (SELECT div_id
              FROM division_sotr
              WHERE user_id = p_iduser)
            UNION
          SELECT id,
                 UPPER(login)
            FROM users
            WHERE id = p_iduser) s)
    LOOP
      p_counter := p_counter + 1;
      l_data.EXTEND;
      l_data(p_counter) := userType(i.id, i.use_r);
    END LOOP;
    RETURN l_data;
  END;
/

--
-- Описание для функции GET_USERS
--
CREATE OR REPLACE FUNCTION "GET_USERS"(p_u_name IN VARCHAR2)
  RETURN userTable
  IS
    l_data    userTable := userTable();
    p_idrole  NUMBER;
    p_iduser  VARCHAR2(50);
    p_counter NUMBER    := 0;
  BEGIN
    SELECT id,
           is_admin
      INTO p_iduser,
           p_idrole
      FROM users
      WHERE UPPER(login) LIKE UPPER(p_u_name);

    IF p_idrole = 1
    THEN
      FOR i IN (SELECT id,
                       UPPER(login) login
          FROM users)
      LOOP
        p_counter := p_counter + 1;
        l_data.EXTEND;
        l_data(p_counter) := userType(i.id, i.login);
      END LOOP;
      RETURN l_data;
    END IF;

    --select nvl(count(*),0) into p_counter from divisions where main_user = p_iduser;
    SELECT COUNT(*)
      INTO p_counter
      FROM GROUPMEMBERS
      WHERE UPPER(G_MEMBER) LIKE UPPER(p_u_name)
        AND G_NAME IN ('director', 'manager', 'cc_manager');
    IF p_counter > 0
    THEN
      p_idrole := 2; --Директор, менеджер
    ELSE
      p_idrole := 3; --Диспетчер замеров
    END IF;

    IF p_idrole = 2
    THEN
      p_counter := 0;
      FOR i IN (SELECT id,
                       s.use_r
          FROM (SELECT (SELECT id
                           FROM users
                           WHERE id = s.user_id) AS id,
                       (SELECT UPPER(login)
                           FROM users
                           WHERE id = s.user_id) AS use_r
              FROM divisions d
                INNER JOIN division_sotr s
                  ON s.div_id = d.id
            --where d.deleted = 0
            CONNECT BY PRIOR d.id = d.parent_id
            START WITH d.id = (SELECT id
                FROM divisions
                WHERE main_user = p_iduser
                  AND ROWNUM = 1)
              UNION
            SELECT id,
                   UPPER(login)
              FROM users
              WHERE id = p_iduser) s)
      LOOP
        p_counter := p_counter + 1;
        l_data.EXTEND;
        l_data(p_counter) := userType(i.id, i.use_r);
      END LOOP;
      RETURN l_data;
    END IF;

    p_counter := 0;
    FOR i IN (SELECT id,
                     s.use_r
        FROM (SELECT (SELECT id
                         FROM users
                         WHERE id = s.user_id) AS id,
                     (SELECT UPPER(login)
                         FROM users
                         WHERE id = s.user_id) AS use_r
            FROM divisions d
              INNER JOIN division_sotr s
                ON s.div_id = d.id
          --where d.deleted = 0
          CONNECT BY PRIOR d.id = d.parent_id
          START WITH d.id IN (SELECT div_id
              FROM division_sotr
              WHERE user_id = p_iduser)
            UNION
          SELECT id,
                 UPPER(login)
            FROM users
            WHERE id = p_iduser) s)
    LOOP
      p_counter := p_counter + 1;
      l_data.EXTEND;
      l_data(p_counter) := userType(i.id, i.use_r);
    END LOOP;
    RETURN l_data;
  END;
/

--
-- Описание для функции GET_DIVISIONS
--
CREATE OR REPLACE FUNCTION "GET_DIVISIONS"(p_u_name IN VARCHAR2)
  RETURN divisionTable
  IS
    l_data    divisionTable := divisionTable();
    p_idrole  NUMBER;
    p_iduser  VARCHAR2(50);
    p_counter NUMBER        := 0;
  BEGIN
    SELECT id,
           is_admin
      INTO p_iduser,
           p_idrole
      FROM users
      WHERE UPPER(login) LIKE UPPER(p_u_name);

    IF p_idrole = 1
    THEN
      FOR i IN (SELECT id,
                       UPPER(fullname) fullname
          FROM divisions
          WHERE parent_id IS NOT NULL)
      LOOP
        p_counter := p_counter + 1;
        l_data.EXTEND;
        l_data(p_counter) := divisionType(i.id, i.fullname);
      END LOOP;
      RETURN l_data;
    END IF;

    p_counter := 0;
    FOR i IN (SELECT s.id,
                     s.fullname
        FROM (SELECT id,
                     UPPER(fullname) fullname
            FROM divisions d
          --where d.deleted = 0
          CONNECT BY PRIOR d.id = d.parent_id
          START WITH d.id = (SELECT id
              FROM divisions
              WHERE main_user = p_iduser
                AND ROWNUM = 1)
            UNION
          SELECT d.id,
                 UPPER(d.fullname)
            FROM divisions d
              INNER JOIN division_sotr s
                ON d.id = s.div_id
            WHERE s.user_id = p_iduser) s)
    LOOP
      p_counter := p_counter + 1;
      l_data.EXTEND;
      l_data(p_counter) := divisionType(i.id, i.fullname);
    END LOOP;
    RETURN l_data;
  END;
/

--
-- Описание для функции BOOL_TO_NUM
--
CREATE OR REPLACE FUNCTION "BOOL_TO_NUM"(bl_expr IN VARCHAR2)
  RETURN NUMBER
  AS
  BEGIN
    /* if bl_expr is null Then
       return null;
     end if;*/
    IF UPPER(bl_expr) = 'TRUE'
    THEN
      RETURN 1;
    END IF;
    RETURN 0;
  END bool_to_num;
/

--
-- Описание для функции ACC_TYPE_CONV
--
CREATE OR REPLACE FUNCTION "ACC_TYPE_CONV"(bl_expr IN VARCHAR2)
  RETURN VARCHAR2
  AS
  BEGIN
    IF UPPER(bl_expr) = 'ACTIVE'
    THEN
      RETURN 'АКТИВНЫЙ';
    END IF;
    IF UPPER(bl_expr) = 'PASSIVE'
    THEN
      RETURN 'ПАССИВНЫЙ';
    END IF;
    RETURN 'АКТИВНЫЙ/ПАССИВНЫЙ';
  END acc_type_conv;
/

--
-- Описание для функции ALL_DEBTS_KONTRAG_VISIBLE
--
CREATE OR REPLACE FUNCTION ALL_DEBTS_KONTRAG_VISIBLE(P_U_NAME IN VARCHAR2,
                                                     P_ID_KON IN VARCHAR2)
  RETURN NUMBER
  AS
    p_counter  NUMBER := 0;
    p_counter1 NUMBER := 0;
    kon_rec    kontragents % ROWTYPE;
  BEGIN
    SELECT COUNT(*)
      INTO p_counter
      FROM GROUPMEMBERS
      WHERE UPPER(G_MEMBER) LIKE UPPER(p_u_name)
        AND G_NAME IN ('director', 'manager', 'cc_manager');
    SELECT *
      INTO kon_rec
      FROM kontragents
      WHERE id = p_id_kon;
    SELECT COUNT(*)
      INTO p_counter1
      FROM VW_SUPPLIER_MOVES
      WHERE UPPER(DIVISION_ID) IN (SELECT UPPER(N)
            FROM TABLE (CAST(get_divisions(P_U_NAME) AS divisionTable)))
        AND kontrag_id = p_id_kon;

    IF p_counter > 0
    THEN
      IF p_counter1 > 0
      THEN --Директор, менеджер
        RETURN 1;
      ELSIF kon_rec.is_buyer = 1
      THEN
        RETURN 1;
      END IF;
    ELSE
      RETURN 1; --Администратор
    END IF;

    RETURN 0;
  END ALL_DEBTS_KONTRAG_VISIBLE;
/

--
-- Описание для представления VW_MOVES
--
CREATE OR REPLACE VIEW VW_MOVES (
  ID,
  REGISTRATOR_ID,
  TABLE_NAME,
  DEB,
  SUM_DEB,
  KRED,
  SUM_KRED,
  CURRENCY,
  SUBCONTO1_DEB,
  SUBCONTO2_DEB,
  SUBCONTO1_KRED,
  SUBCONTO2_KRED,
  ACTIVITIES_ID,
  DIVISION_ID,
  PERIOD,
  CURR_ID,
  DESCRIPTION
) AS
    SELECT MOVES.ID,
           MOVES.REGISTRATOR_ID,
           TYPE_DEF.TABLE_NAME,
           PLAN_ACC.CODE AS Deb,
           SUM(MOVES.SUMM_VAL_DEB) AS Sum_Deb,
           PLAN_ACC1.CODE AS Kred,
           SUM(MOVES.SUMM_VAL_KREDIT) AS Sum_Kred,
           CURRENCY.FULLNAME AS Currency,
           MOVES.SUBCONTO1_DEB,
           MOVES.SUBCONTO2_DEB,
           MOVES.SUBCONTO1_KRED,
           MOVES.SUBCONTO2_KRED,
           MOVES.ACTIVITIES_ID,
           MOVES.DIVISION_ID,
           MOVES.PERIOD,
           CURRENCY.ID AS Curr_Id,
           MOVES.DESCRIPTION
      FROM MOVES
        INNER JOIN PLAN_ACC
          ON PLAN_ACC.ID = MOVES.PLAN_ACC_DEB_ID
          INNER JOIN PLAN_ACC PLAN_ACC1
            ON PLAN_ACC1.ID = MOVES.PLAN_ACC_KRED_ID
            INNER JOIN CURRENCY
              ON CURRENCY.ID = MOVES.CURR_DEB
              INNER JOIN TYPE_DEF
                ON MOVES.REGISTRATOR_TYPE = TYPE_DEF.ID
      GROUP BY MOVES.ID,
               MOVES.REGISTRATOR_ID,
               TYPE_DEF.TABLE_NAME,
               PLAN_ACC.CODE,
               PLAN_ACC1.CODE,
               CURRENCY.FULLNAME,
               MOVES.SUBCONTO1_DEB,
               MOVES.SUBCONTO2_DEB,
               MOVES.SUBCONTO1_KRED,
               MOVES.SUBCONTO2_KRED,
               MOVES.ACTIVITIES_ID,
               MOVES.DIVISION_ID,
               MOVES.PERIOD,
               CURRENCY.ID,
               MOVES.DESCRIPTION
      ORDER BY Deb;

--
-- Описание для представления VW_NOTIFICATION_CALENDAR
--
CREATE OR REPLACE VIEW VW_NOTIFICATION_CALENDAR (
  ID,
  SCHED_NAME,
  JOB_NAME,
  JOB_GROUP,
  JOB_DESCRIPTION,
  JOB_CLASS_NAME,
  TRIGGER_NAME,
  NEXT_FIRE_TIME,
  PREV_FIRE_TIME,
  TRG_DESCRIPTION,
  TRIGGER_TYPE,
  CRON_EXPRESSION,
  DAT,
  DESCRIPTION,
  USER_ID,
  CONTACT,
  SERVER,
  CLIENT,
  USER_LOGIN,
  OBJECT_ID,
  START_DATE,
  END_DATE
) AS
    SELECT NOTIFICATION.ID,
           QRTZ_JOB_DETAILS.SCHED_NAME,
           QRTZ_JOB_DETAILS.JOB_NAME,
           QRTZ_JOB_DETAILS.JOB_GROUP,
           QRTZ_JOB_DETAILS.DESCRIPTION AS JOB_DESCRIPTION,
           QRTZ_JOB_DETAILS.JOB_CLASS_NAME,
           QRTZ_TRIGGERS.TRIGGER_NAME,
           (TO_DATE('01/01/1970 00:00:00', 'DD/MM/YYYY HH24:MI:SS') + (QRTZ_TRIGGERS.NEXT_FIRE_TIME / 1000 / 60 / 60 / 24)) AS NEXT_FIRE_TIME,
           (TO_DATE('01/01/1970 00:00:00', 'DD/MM/YYYY HH24:MI:SS') + (QRTZ_TRIGGERS.PREV_FIRE_TIME / 1000 / 60 / 60 / 24)) AS PREV_FIRE_TIME,
           QRTZ_TRIGGERS.DESCRIPTION AS TRG_DESCRIPTION,
           QRTZ_TRIGGERS.TRIGGER_TYPE,
           QRTZ_CRON_TRIGGERS.CRON_EXPRESSION,
           NOTIFICATION.DAT,
           NOTIFICATION.DESCRIPTION,
           NOTIFICATION.USER_ID,
           NOTIFICATION.CONTACT,
           NOTIFICATION.SERVER,
           NOTIFICATION.CLIENT,
           NOTIFICATION.USER_LOGIN,
           NOTIFICATION.OBJECT_ID,
           NOTIFICATION.START_DATE,
           NOTIFICATION.END_DATE
      FROM QRTZ_JOB_DETAILS
        INNER JOIN QRTZ_TRIGGERS
          ON QRTZ_JOB_DETAILS.SCHED_NAME = QRTZ_TRIGGERS.SCHED_NAME
          AND QRTZ_JOB_DETAILS.JOB_NAME = QRTZ_TRIGGERS.JOB_NAME
          AND QRTZ_JOB_DETAILS.JOB_GROUP = QRTZ_TRIGGERS.JOB_GROUP
          INNER JOIN QRTZ_CRON_TRIGGERS
            ON QRTZ_TRIGGERS.SCHED_NAME = QRTZ_CRON_TRIGGERS.SCHED_NAME
            AND QRTZ_TRIGGERS.TRIGGER_NAME = QRTZ_CRON_TRIGGERS.TRIGGER_NAME
            AND QRTZ_TRIGGERS.TRIGGER_GROUP = QRTZ_CRON_TRIGGERS.TRIGGER_GROUP
            RIGHT JOIN NOTIFICATION
              ON QRTZ_TRIGGERS.TRIGGER_NAME = NOTIFICATION.TRG_NAME;

--
-- Описание для представления LAST_PRICES
--
CREATE OR REPLACE VIEW LAST_PRICES (
  ID,
  NOM_ID,
  PERIOD,
  ED_IZM,
  PRICE_USL,
  PRICE_GOODS
) AS
    SELECT "ID",
           "NOM_ID",
           "PERIOD",
           "ED_IZM",
           "PRICE_USL",
           "PRICE_GOODS"
      FROM reg_prices
      WHERE period = (SELECT MAX(period)
            FROM reg_prices
            WHERE period <= (sysdate));

--
-- Описание для представления ORDERS_CALC
--
CREATE OR REPLACE VIEW ORDERS_CALC (
  ID,
  KONTRAG_ID,
  KONTRAGNAME,
  DIVISION_ID,
  OPLATY,
  USLUGIALL,
  DEBT
) AS
    SELECT ID,
           KONTRAG_ID,
           FULLNAME AS KontragName,
           DIVISION_ID,
           Oplaty,
           (Uslugi + UslugiAdd) UslugiAll,
           (Uslugi + UslugiAdd - Oplaty) Debt
      FROM (SELECT ORDERS.ID,
                   ORDERS.KONTRAG_ID,
                   ORDERS.DIVISION_ID,
                   NVL(SUM(DISTINCT ORDERS_TP_OPLATY.SUM), 0) AS Oplaty,
                   NVL(SUM(DISTINCT ORDERS_TP_USLUGI.SUMM), 0) AS Uslugi,
                   NVL(SUM(DISTINCT ORDERS_TP_USLUGI.PRICE_ADD), 0) AS UslugiAdd,
                   KONTRAGENTS.FULLNAME
          FROM ORDERS
            LEFT JOIN ORDERS_TP_OPLATY
              ON ORDERS.ID = ORDERS_TP_OPLATY.ORDER_ID
              LEFT JOIN ORDERS_TP_USLUGI
                ON ORDERS.ID = ORDERS_TP_USLUGI.ORDER_ID
                INNER JOIN KONTRAGENTS
                  ON KONTRAGENTS.ID = ORDERS.KONTRAG_ID
          WHERE ORDERS.POSTED = 1
          GROUP BY ORDERS.ID,
                   ORDERS.KONTRAG_ID,
                   ORDERS.DIVISION_ID,
                   KONTRAGENTS.FULLNAME);

--
-- Описание для представления VW_NET
--
CREATE OR REPLACE VIEW VW_NET (
  ID,
  PARENT_ID,
  FULLNAME,
  DELETED,
  INN,
  OKPO,
  KPP,
  NAMEFULL,
  UR_FIZ,
  IS_SUPPLIER,
  IS_BUYER,
  IS_MEASURER,
  USER_ID,
  PHOTO
) AS
    SELECT KONTRAG_SETTINGS.KONTRAG_ID AS ID,
           KONTRAG_SETTINGS.DIVISION_ID AS Parent_id,
           KONTRAGENTS.FULLNAME AS fullname,
           KONTRAGENTS.DELETED,
           KONTRAGENTS.INN,
           KONTRAGENTS.OKPO,
           KONTRAGENTS.KPP,
           KONTRAGENTS.NAMEFULL,
           KONTRAGENTS.UR_FIZ,
           KONTRAGENTS.IS_SUPPLIER,
           KONTRAGENTS.IS_BUYER,
           KONTRAGENTS.IS_MEASURER,
           KONTRAGENTS.USER_ID,
           KONTRAGENTS.PHOTO
      FROM KONTRAG_SETTINGS
        INNER JOIN KONTRAGENTS
          ON KONTRAGENTS.ID = KONTRAG_SETTINGS.KONTRAG_ID
      WHERE base_id IN (SELECT id
            FROM BASE_OF_NACHISL
            WHERE name = 'IERARHIA')
        AND pay_id IN (SELECT id
            FROM PAY_SETTINGS
            WHERE PAY_SETTINGS.IN_PROFIT = 0);

--
-- Описание для представления VW_TBL_DELETED
--
CREATE OR REPLACE VIEW VW_TBL_DELETED (
  TABLE_ID,
  MAIN_ID,
  TABLE_NAME,
  OBJNAME,
  CONSTRAINT_TYPE,
  REF_STR
) AS
    SELECT "TABLE_ID",
           "MAIN_ID",
           "TABLE_NAME",
           "COLUMN_NAME" AS ObjName,
           "CONSTRAINT_TYPE",
           "REF_STR"
      FROM TABLE (CAST(REPORT_PKG.get_deleted_tables() AS tbl_deleted));

--
-- Описание для представления VW_TBL_DEL_REF
--
CREATE OR REPLACE VIEW VW_TBL_DEL_REF (
  TABLE_ID,
  MAIN_ID,
  TABLE_NAME,
  COLUMN_NAME,
  CONSTRAINT_TYPE,
  REF_STR
) AS
    SELECT "TABLE_ID",
           "MAIN_ID",
           "TABLE_NAME",
           "COLUMN_NAME",
           "CONSTRAINT_TYPE",
           "REF_STR"
      FROM TABLE (CAST(REPORT_PKG.get_deletedref_tables() AS tbl_deleted_ref)) ref_tbl;

--
-- Описание для представления VW_RATING
--
CREATE OR REPLACE VIEW VW_RATING (
  PLACE,
  DIVISION_ID,
  CNT,
  TOTAL,
  BALL_SUM,
  BALL_CNT,
  BALL_TOTAL
) AS
    SELECT ROWNUM place,
           division_id,
           cnt,
           total,
           totalsum ball_sum,
           totalcnt ball_cnt,
           totalball ball_total
      FROM (SELECT division_id,
                   cnt,
                   total,
                   total * NVL((SELECT RATING_SETTINGS.SUM_BAL
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 0) / NVL((SELECT RATING_SETTINGS.SUM_DIVIDER
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 1) TotalSum,
                   cnt * NVL((SELECT RATING_SETTINGS.CNT_BAL
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 0) / NVL((SELECT RATING_SETTINGS.CNT_DIVIDER
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 1) TotalCnt,
                   (total * NVL((SELECT RATING_SETTINGS.SUM_BAL
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 0) / NVL((SELECT RATING_SETTINGS.SUM_DIVIDER
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 1))
                   + (cnt * NVL((SELECT RATING_SETTINGS.CNT_BAL
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 0) / NVL((SELECT RATING_SETTINGS.CNT_DIVIDER
                       FROM RATING_SETTINGS
                       WHERE ROWNUM = 1), 1)) TotalBall
          FROM (SELECT COUNT(DISTINCT ORDERS.ID) cnt,
                       (SELECT kontrag_id
                           FROM user_settings
                           WHERE user_id = ORDERS.USER_ID
                             AND ROWNUM = 1) AS DIVISION_ID,
                       SUM((NVL(ORDERS_TP_USLUGI.SUMM, 0) + NVL(ORDERS_TP_USLUGI.PRICE_ADD, 0))) Total
              FROM ORDERS
                INNER JOIN ORDERS_TP_USLUGI
                  ON ORDERS.ID = ORDERS_TP_USLUGI.ORDER_ID
              WHERE ORDERS.STATUS_ID NOT IN (SELECT os.id
                    FROM ORDER_STATUS os
                    WHERE os.name IN ('Отказ', 'Аннулирован', 'Контроль'))
                AND (ORDERS.DAT BETWEEN ORDERS_ENTRY.get_startdatmoves() AND ORDERS_ENTRY.GET_ENDDATMOVES())
              GROUP BY ORDERS.USER_ID)
          ORDER BY TOTALBALL DESC);

--
-- Описание для представления VW_SALES_ORDERS
--
CREATE OR REPLACE VIEW VW_SALES_ORDERS (
  REGISTRATOR_ID,
  TABLE_NAME,
  CODE,
  SUMMA,
  SUBCONTO1_DEB,
  FULLNAME,
  PERIOD
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.DEB AS Code,
           SUM(VW_MOVES.SUM_DEB) AS Summa,
           VW_MOVES.SUBCONTO1_DEB AS Subconto1_Deb,
           KONTRAGENTS.FULLNAME,
           VW_MOVES.PERIOD
      FROM VW_MOVES
        INNER JOIN KONTRAGENTS
          ON VW_MOVES.SUBCONTO1_DEB = KONTRAGENTS.ID
      WHERE VW_MOVES.DEB = '20711'
      GROUP BY VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.DEB,
               VW_MOVES.SUBCONTO1_DEB,
               KONTRAGENTS.FULLNAME,
               VW_MOVES.PERIOD;

--
-- Описание для представления VW_MOVE_START_OST
--
CREATE OR REPLACE VIEW VW_MOVE_START_OST (
  REGISTRATOR_ID,
  DEB,
  SUM_DEB,
  SUBCONTO1_DEB,
  SUBCONTO2_DEB,
  KRED,
  SUM_KRED,
  SUBCONTO1_KRED,
  SUBCONTO2_KRED
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.SUBCONTO1_DEB,
           VW_MOVES.SUBCONTO2_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           VW_MOVES.SUBCONTO1_KRED,
           VW_MOVES.SUBCONTO2_KRED
      FROM VW_MOVES
      WHERE UPPER(VW_MOVES.TABLE_NAME) = UPPER('start_ost');

--
-- Описание для представления VW_MOVE_RKO
--
CREATE OR REPLACE VIEW VW_MOVE_RKO (
  REGISTRATOR_ID,
  DEB,
  SUM_DEB,
  KRED,
  SUM_KRED,
  SUBCONTO_DEB1,
  SUBCONTO_KRED1
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           CASE WHEN DEB = '511' THEN (SELECT fullname
                     FROM divisions
                     WHERE id = VW_MOVES.SUBCONTO1_DEB) WHEN DEB = '5091' THEN (SELECT fullname
                     FROM kontragents
                     WHERE id = SUBCONTO1_DEB) WHEN DEB = KRED THEN (SELECT fullname
                     FROM kassa
                     WHERE id = SUBCONTO1_DEB) END SUBCONTO_DEB1,
           CASE WHEN KRED = '2081' THEN (SELECT fullname
                     FROM kassa
                     WHERE id = SUBCONTO1_KRED) WHEN KRED = '511' THEN (SELECT fullname
                     FROM divisions
                     WHERE id = SUBCONTO1_KRED) END SUBCONTO_KRED1
      FROM VW_MOVES
      WHERE ((VW_MOVES.KRED LIKE '2081')
        OR (VW_MOVES.KRED LIKE '511'))
        AND UPPER(VW_MOVES.TABLE_NAME) = UPPER('RKO');

--
-- Описание для представления VW_MOVE_PROFIT
--
CREATE OR REPLACE VIEW VW_MOVE_PROFIT (
  REGISTRATOR_ID,
  DEB,
  SUM_DEB,
  KRED,
  SUM_KRED,
  SUBCONTO_DEB1,
  SUBCONTO_KRED1
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           DIVISIONS.FULLNAME AS Subconto_Deb1,
           KONTRAGENTS.FULLNAME AS Subconto_kred1
      FROM VW_MOVES
        LEFT JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          LEFT JOIN KONTRAGENTS
            ON VW_MOVES.SUBCONTO1_KRED = KONTRAGENTS.ID
      WHERE VW_MOVES.DEB = '900'
        AND VW_MOVES.KRED = '5091'
        AND UPPER(VW_MOVES.TABLE_NAME) = UPPER('PROFIT_DISTRIB')
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           DIVISIONS.FULLNAME,
           d.FULLNAME
      FROM VW_MOVES
        LEFT JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          LEFT JOIN DIVISIONS d
            ON VW_MOVES.SUBCONTO1_KRED = d.ID
      WHERE VW_MOVES.DEB = '900'
        AND VW_MOVES.KRED = '000'
        AND UPPER(VW_MOVES.TABLE_NAME) = UPPER('PROFIT_DISTRIB')
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           DIVISIONS.FULLNAME,
           d.FULLNAME
      FROM VW_MOVES
        LEFT JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          LEFT JOIN DIVISIONS d
            ON VW_MOVES.SUBCONTO1_KRED = d.ID
      WHERE VW_MOVES.DEB = '000'
        AND VW_MOVES.KRED = '900'
        AND UPPER(VW_MOVES.TABLE_NAME) = UPPER('PROFIT_DISTRIB');

--
-- Описание для представления VW_MOVE_PKO
--
CREATE OR REPLACE VIEW VW_MOVE_PKO (
  REGISTRATOR_ID,
  DEB,
  SUM_DEB,
  KRED,
  SUM_KRED,
  SUBCONTO_DEB1,
  SUBCONTO_KRED1
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           KASSA.FULLNAME AS Subconto_Deb1,
           KONTRAGENTS.FULLNAME AS Subconto_kred1
      FROM VW_MOVES
        LEFT JOIN KASSA
          ON VW_MOVES.SUBCONTO1_DEB = KASSA.ID
          LEFT JOIN KONTRAGENTS
            ON VW_MOVES.SUBCONTO1_KRED = KONTRAGENTS.ID
      WHERE VW_MOVES.DEB = '2081'
        AND UPPER(VW_MOVES.TABLE_NAME) = UPPER('PKO');

--
-- Описание для представления OBOROT_600
--
CREATE OR REPLACE VIEW OBOROT_600 (
  REGISTRATOR_ID,
  DEB,
  SUM_DEB,
  KRED,
  SUM_KRED,
  OSTATOK
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           SUM(DISTINCT VW_MOVES.SUM_DEB) AS SUM_DEB,
           VW_MOVES1.KRED,
           SUM(DISTINCT VW_MOVES1.SUM_KRED) AS SUM_KRED,
           SUM(DISTINCT VW_MOVES1.SUM_KRED) + SUM(DISTINCT VW_MOVES.SUM_DEB) AS OSTATOK
      FROM VW_MOVES
        INNER JOIN VW_MOVES VW_MOVES1
          ON VW_MOVES.REGISTRATOR_ID = VW_MOVES1.REGISTRATOR_ID
      WHERE VW_MOVES.DEB = '600'
        AND VW_MOVES1.KRED = '600'
      GROUP BY VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.DEB,
               VW_MOVES1.KRED;

--
-- Описание для представления MOVE_INSIDE
--
CREATE OR REPLACE VIEW MOVE_INSIDE (
  ID,
  DIV_ID,
  DIV_NAME,
  DIV_ID_DEST,
  CODE,
  SUMM,
  REGISTRATOR_ID,
  TABLE_NAME,
  PERIOD,
  DIVISION_ID
) AS
    SELECT VW_MOVES.ID,
           DIVISIONS.ID AS Div_id,
           DIVISIONS.FULLNAME AS Div_Name,
           VW_MOVES.SUBCONTO1_KRED AS DIV_ID_DEST,
           VW_MOVES.DEB AS Code,
           SUM(DISTINCT VW_MOVES.SUM_DEB) AS Summ,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.PERIOD,
           VW_MOVES.DIVISION_ID
      FROM DIVISIONS
        INNER JOIN VW_MOVES
          ON DIVISIONS.ID = VW_MOVES.SUBCONTO1_DEB
      WHERE VW_MOVES.DEB LIKE '511'
      GROUP BY VW_MOVES.ID,
               DIVISIONS.ID,
               DIVISIONS.FULLNAME,
               VW_MOVES.SUBCONTO1_KRED,
               VW_MOVES.DEB,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.PERIOD,
               VW_MOVES.DIVISION_ID
      UNION ALL
    SELECT VW_MOVES.ID,
           DIVISIONS.ID AS Kontrag_id,
           DIVISIONS.FULLNAME,
           VW_MOVES.SUBCONTO1_DEB,
           VW_MOVES.KRED,
           SUM(DISTINCT VW_MOVES.SUM_KRED) AS Summ,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.PERIOD,
           VW_MOVES.DIVISION_ID
      FROM DIVISIONS
        INNER JOIN VW_MOVES
          ON DIVISIONS.ID = VW_MOVES.SUBCONTO1_KRED
      WHERE VW_MOVES.KRED LIKE '511'
      GROUP BY VW_MOVES.ID,
               DIVISIONS.ID,
               DIVISIONS.FULLNAME,
               VW_MOVES.SUBCONTO1_DEB,
               VW_MOVES.KRED,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.PERIOD,
               VW_MOVES.DIVISION_ID;

--
-- Описание для представления OBOROT_MOVIES_KRED
--
CREATE OR REPLACE VIEW OBOROT_MOVIES_KRED (
  ID,
  PLAN_ACC_ID,
  KRED,
  SUM_KRED,
  SUBCONTO1_KRED,
  SUBCONTO2_KRED,
  CURRENCY,
  REGISTRATOR_ID,
  ACTIVITIES_ID,
  PERIOD,
  DIVISION_ID
) AS
    SELECT MAX(VW_MOVES.ID) AS ID,
           PLAN_ACC.ID AS Plan_Acc_Id,
           PLAN_ACC.CODE AS Kred,
           NVL(SUM(VW_MOVES.SUM_KRED), 0) AS Sum_Kred,
           VW_MOVES.SUBCONTO1_KRED,
           VW_MOVES.SUBCONTO2_KRED,
           VW_MOVES.CURRENCY,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.ACTIVITIES_ID,
           VW_MOVES.PERIOD,
           VW_MOVES.DIVISION_ID
      FROM PLAN_ACC
        INNER JOIN VW_MOVES
          ON PLAN_ACC.CODE = VW_MOVES.KRED
      WHERE TRUNC(VW_MOVES.PERIOD) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
        AND TRUNC(VW_MOVES.PERIOD) <= TRUNC(ORDERS_ENTRY.GET_ENDDATMOVES())
      GROUP BY PLAN_ACC.ID,
               PLAN_ACC.CODE,
               VW_MOVES.SUBCONTO1_KRED,
               VW_MOVES.SUBCONTO2_KRED,
               VW_MOVES.CURRENCY,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.ACTIVITIES_ID,
               VW_MOVES.PERIOD,
               VW_MOVES.DIVISION_ID
      ORDER BY Kred;

--
-- Описание для представления OBOROT_MOVIES_DEB
--
CREATE OR REPLACE VIEW OBOROT_MOVIES_DEB (
  ID,
  PLAN_ACC_ID,
  DEB,
  SUM_DEB,
  SUBCONTO1_DEB,
  SUBCONTO2_DEB,
  CURRENCY,
  REGISTRATOR_ID,
  ACTIVITIES_ID,
  PERIOD,
  DIVISION_ID
) AS
    SELECT MAX(VW_MOVES.ID) AS ID,
           PLAN_ACC.ID AS Plan_Acc_Id,
           PLAN_ACC.CODE AS Deb,
           NVL(SUM(VW_MOVES.SUM_DEB), 0) AS Sum_Deb,
           VW_MOVES.SUBCONTO1_DEB,
           VW_MOVES.SUBCONTO2_DEB,
           VW_MOVES.CURRENCY,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.ACTIVITIES_ID,
           VW_MOVES.PERIOD,
           VW_MOVES.DIVISION_ID
      FROM PLAN_ACC
        INNER JOIN VW_MOVES
          ON PLAN_ACC.CODE = VW_MOVES.DEB
      WHERE TRUNC(VW_MOVES.PERIOD) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
        AND TRUNC(VW_MOVES.PERIOD) <= TRUNC(ORDERS_ENTRY.GET_ENDDATMOVES())
      GROUP BY PLAN_ACC.ID,
               PLAN_ACC.CODE,
               VW_MOVES.SUBCONTO1_DEB,
               VW_MOVES.SUBCONTO2_DEB,
               VW_MOVES.CURRENCY,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.ACTIVITIES_ID,
               VW_MOVES.PERIOD,
               VW_MOVES.DIVISION_ID
      ORDER BY Deb;

--
-- Описание для представления MOVE_KONTRAG
--
CREATE OR REPLACE VIEW MOVE_KONTRAG (
  KONTRAG_ID,
  KONTRAG,
  CODE,
  SUMM,
  REGISTRATOR_ID,
  TABLE_NAME,
  PERIOD,
  ID,
  DIVISION_ID
) AS
    SELECT KONTRAGENTS.ID AS Kontrag_id,
           KONTRAGENTS.FULLNAME AS Kontrag,
           VW_MOVES.DEB AS Code,
           SUM(DISTINCT VW_MOVES.SUM_DEB) AS Summ,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.PERIOD,
           VW_MOVES.ID,
           VW_MOVES.DIVISION_ID
      FROM KONTRAGENTS
        INNER JOIN VW_MOVES
          ON KONTRAGENTS.ID = VW_MOVES.SUBCONTO1_DEB
      GROUP BY KONTRAGENTS.ID,
               KONTRAGENTS.FULLNAME,
               VW_MOVES.DEB,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.PERIOD,
               VW_MOVES.ID,
               VW_MOVES.DIVISION_ID
      UNION ALL
    SELECT KONTRAGENTS.ID AS Kontrag_id,
           KONTRAGENTS.FULLNAME,
           VW_MOVES.KRED,
           SUM(DISTINCT VW_MOVES.SUM_KRED) AS Summ,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.PERIOD,
           VW_MOVES.ID,
           VW_MOVES.DIVISION_ID
      FROM KONTRAGENTS
        INNER JOIN VW_MOVES
          ON KONTRAGENTS.ID = VW_MOVES.SUBCONTO1_KRED
      GROUP BY KONTRAGENTS.ID,
               KONTRAGENTS.FULLNAME,
               VW_MOVES.KRED,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.PERIOD,
               VW_MOVES.ID,
               VW_MOVES.DIVISION_ID
      HAVING TRUNC(period) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
        AND TRUNC(period) <= TRUNC(ORDERS_ENTRY.get_enddatmoves());

--
-- Описание для представления MOVE_KASSA
--
CREATE OR REPLACE VIEW MOVE_KASSA (
  ID,
  KASSA_ID,
  KASSA,
  CODE,
  SUMM,
  REGISTRATOR_ID,
  TABLE_NAME,
  PERIOD,
  DIVISION_ID
) AS
    SELECT VW_MOVES.ID,
           KASSA.ID AS Kassa_id,
           KASSA.FULLNAME AS Kassa,
           VW_MOVES.DEB AS Code,
           SUM(DISTINCT VW_MOVES.SUM_DEB) AS Summ,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.PERIOD,
           VW_MOVES.DIVISION_ID
      FROM KASSA
        INNER JOIN VW_MOVES
          ON KASSA.ID = VW_MOVES.SUBCONTO1_DEB
      GROUP BY VW_MOVES.ID,
               KASSA.ID,
               KASSA.FULLNAME,
               VW_MOVES.DEB,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.PERIOD,
               VW_MOVES.DIVISION_ID
      UNION ALL
    SELECT VW_MOVES.ID,
           KASSA.ID AS Kontrag_id,
           KASSA.FULLNAME,
           VW_MOVES.KRED,
           SUM(DISTINCT VW_MOVES.SUM_KRED) AS Summ,
           VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.PERIOD,
           VW_MOVES.DIVISION_ID
      FROM KASSA
        INNER JOIN VW_MOVES
          ON KASSA.ID = VW_MOVES.SUBCONTO1_KRED
      GROUP BY VW_MOVES.ID,
               KASSA.ID,
               KASSA.FULLNAME,
               VW_MOVES.KRED,
               VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.PERIOD,
               VW_MOVES.DIVISION_ID
      HAVING TRUNC(period) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
        AND TRUNC(period) <= TRUNC(ORDERS_ENTRY.get_enddatmoves());

--
-- Описание для представления VW_SEBEST_ORDERS
--
CREATE OR REPLACE VIEW VW_SEBEST_ORDERS (
  REGISTRATOR_ID,
  TABLE_NAME,
  CODE,
  SUMMA,
  SUMM_PLAN,
  SUBCONTO1_DEB,
  FULLNAME,
  PERIOD
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.DEB AS Code,
           SUM(VW_MOVES.SUM_DEB) AS Summa,
           ORDERS.SUMM_PLAN,
           VW_MOVES.SUBCONTO1_DEB AS Subconto1_Deb,
           DIVISIONS.FULLNAME,
           VW_MOVES.PERIOD
      FROM VW_MOVES
        INNER JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          INNER JOIN ORDERS
            ON VW_MOVES.REGISTRATOR_ID = ORDERS.ID
      WHERE VW_MOVES.DEB = '701'
      GROUP BY VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.DEB,
               ORDERS.SUMM_PLAN,
               VW_MOVES.SUBCONTO1_DEB,
               DIVISIONS.FULLNAME,
               VW_MOVES.PERIOD;

--
-- Описание для представления VW_ZATRATY
--
CREATE OR REPLACE VIEW VW_ZATRATY (
  REGISTRATOR_ID,
  TABLE_NAME,
  CODE,
  SUMMA,
  ZATRATY_ID,
  ZATRATY_NAME,
  DIVISION_ID,
  PERIOD
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.TABLE_NAME,
           VW_MOVES.DEB AS Code,
           SUM(VW_MOVES.SUM_DEB) AS Summa,
           VW_MOVES.SUBCONTO1_DEB AS Zatraty_id,
           ZATRATY.FULLNAME AS Zatraty_name,
           VW_MOVES.DIVISION_ID,
           VW_MOVES.PERIOD
      FROM VW_MOVES
        INNER JOIN ZATRATY
          ON VW_MOVES.SUBCONTO1_DEB = ZATRATY.ID
      WHERE VW_MOVES.DEB = '80212'
        AND TRUNC(VW_MOVES.PERIOD) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
        AND TRUNC(VW_MOVES.PERIOD) <= TRUNC(ORDERS_ENTRY.get_enddatmoves())
      GROUP BY VW_MOVES.REGISTRATOR_ID,
               VW_MOVES.TABLE_NAME,
               VW_MOVES.DEB,
               VW_MOVES.SUBCONTO1_DEB,
               ZATRATY.FULLNAME,
               VW_MOVES.DIVISION_ID,
               VW_MOVES.PERIOD;

--
-- Описание для представления VW_MOVE_OTHER
--
CREATE OR REPLACE VIEW VW_MOVE_OTHER (
  REGISTRATOR_ID,
  DEB,
  SUM_DEB,
  KRED,
  SUM_KRED,
  SUBCONTO1_DEB,
  SUBCONTO1_KRED
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           ZATRATY.FULLNAME AS Subconto1_Deb,
           KASSA.FULLNAME AS Subconto1_Kred
      FROM VW_MOVES
        INNER JOIN ZATRATY
          ON VW_MOVES.SUBCONTO1_DEB = ZATRATY.ID
          INNER JOIN KASSA
            ON VW_MOVES.SUBCONTO1_KRED = KASSA.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           DIVISIONS.FULLNAME,
           ZATRATY.FULLNAME AS FULLNAME1
      FROM VW_MOVES
        INNER JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          INNER JOIN ZATRATY
            ON VW_MOVES.SUBCONTO1_KRED = ZATRATY.ID;

--
-- Описание для представления VW_MOVE_ORDERS
--
CREATE OR REPLACE VIEW VW_MOVE_ORDERS (
  REGISTRATOR_ID,
  DEB,
  SUM_DEB,
  KRED,
  SUM_KRED,
  SUBCONTO1_DEB,
  SUBCONTO1_KRED,
  SUBCONTO2_KRED
) AS
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           KONTRAGENTS.FULLNAME AS Subconto1_Deb,
           DIVISIONS.FULLNAME AS Subconto1_Kred,
           NOMENKLATURA.FULLNAME AS Subconto2_Kred
      FROM VW_MOVES
        INNER JOIN KONTRAGENTS
          ON VW_MOVES.SUBCONTO1_DEB = KONTRAGENTS.ID
          INNER JOIN DIVISIONS
            ON VW_MOVES.SUBCONTO1_KRED = DIVISIONS.ID
            LEFT JOIN NOMENKLATURA
              ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           KONTRAGENTS.FULLNAME AS Subconto1_Deb,
           KASSA.FULLNAME,
           NOMENKLATURA.FULLNAME AS FULLNAME1
      FROM VW_MOVES
        INNER JOIN KONTRAGENTS
          ON VW_MOVES.SUBCONTO1_DEB = KONTRAGENTS.ID
          INNER JOIN KASSA
            ON VW_MOVES.SUBCONTO1_KRED = KASSA.ID
            LEFT JOIN NOMENKLATURA
              ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           KASSA.FULLNAME,
           KONTRAGENTS.FULLNAME AS Subconto1_Deb,
           NOMENKLATURA.FULLNAME AS FULLNAME1
      FROM VW_MOVES
        INNER JOIN KASSA
          ON VW_MOVES.SUBCONTO1_DEB = KASSA.ID
          INNER JOIN KONTRAGENTS
            ON VW_MOVES.SUBCONTO1_KRED = KONTRAGENTS.ID
            LEFT JOIN NOMENKLATURA
              ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           ZATRATY.FULLNAME AS Subconto1_Deb,
           KASSA.FULLNAME AS Subconto1_Kred,
           NOMENKLATURA.FULLNAME AS Subconto2_Kred
      FROM VW_MOVES
        INNER JOIN ZATRATY
          ON VW_MOVES.SUBCONTO1_DEB = ZATRATY.ID
          INNER JOIN KASSA
            ON VW_MOVES.SUBCONTO1_KRED = KASSA.ID
            LEFT JOIN NOMENKLATURA
              ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           DIVISIONS.FULLNAME,
           ZATRATY.FULLNAME AS FULLNAME1,
           NOMENKLATURA.FULLNAME AS FULLNAME2
      FROM VW_MOVES
        INNER JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          INNER JOIN ZATRATY
            ON VW_MOVES.SUBCONTO1_KRED = ZATRATY.ID
            LEFT JOIN NOMENKLATURA
              ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           DIVISIONS.FULLNAME,
           KONTRAGENTS.FULLNAME AS FULLNAME1,
           NOMENKLATURA.FULLNAME AS FULLNAME2
      FROM VW_MOVES
        INNER JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          LEFT JOIN NOMENKLATURA
            ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID
            INNER JOIN KONTRAGENTS
              ON VW_MOVES.SUBCONTO1_KRED = KONTRAGENTS.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           DIVISIONS.FULLNAME,
           DIVISIONS1.FULLNAME AS FULLNAME1,
           NOMENKLATURA.FULLNAME AS FULLNAME2
      FROM VW_MOVES
        INNER JOIN DIVISIONS
          ON VW_MOVES.SUBCONTO1_DEB = DIVISIONS.ID
          INNER JOIN DIVISIONS DIVISIONS1
            ON VW_MOVES.SUBCONTO1_KRED = DIVISIONS1.ID
            LEFT JOIN NOMENKLATURA
              ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID
      UNION
    SELECT VW_MOVES.REGISTRATOR_ID,
           VW_MOVES.DEB,
           VW_MOVES.SUM_DEB,
           VW_MOVES.KRED,
           VW_MOVES.SUM_KRED,
           ZATRATY.FULLNAME AS Subconto1_Deb,
           KONTRAGENTS.FULLNAME AS Subconto1_Kred,
           NOMENKLATURA.FULLNAME AS Subconto2_Kred
      FROM VW_MOVES
        INNER JOIN ZATRATY
          ON VW_MOVES.SUBCONTO1_DEB = ZATRATY.ID
          INNER JOIN KONTRAGENTS
            ON VW_MOVES.SUBCONTO1_KRED = KONTRAGENTS.ID
            LEFT JOIN NOMENKLATURA
              ON VW_MOVES.SUBCONTO2_KRED = NOMENKLATURA.ID;

--
-- Описание для представления BALLANS_BY_KONTRAG
--
CREATE OR REPLACE VIEW BALLANS_BY_KONTRAG (
  ID,
  KONTRAG,
  CODE,
  BALLANS
) AS
    SELECT KONTRAG_ID ID,
           KONTRAG,
           CODE,
           SUM(CASE WHEN code LIKE '5091' THEN -summ ELSE summ END) BALLANS
      FROM MOVE_KONTRAG
      GROUP BY KONTRAG_ID,
               KONTRAG,
               CODE;

--
-- Описание для представления BALLANS_BY_KASSA
--
CREATE OR REPLACE VIEW BALLANS_BY_KASSA (
  ID,
  KASSA_ID,
  KASSA,
  CODE,
  BALLANS
) AS
    SELECT MAX(MOVE_KASSA.ID) ID,
           MOVE_KASSA.KASSA_ID,
           MOVE_KASSA.KASSA,
           MOVE_KASSA.CODE,
           SUM(MOVE_KASSA.SUMM) BALLANS
      FROM MOVE_KASSA
      GROUP BY MOVE_KASSA.KASSA_ID,
               MOVE_KASSA.KASSA,
               MOVE_KASSA.CODE;

--
-- Описание для представления OBOROT_MOVIES
--
CREATE OR REPLACE VIEW OBOROT_MOVIES (
  ID,
  ACC_TYPE,
  PARENT_ID,
  FULLNAME,
  DIVISION_ID,
  CODE,
  START_OST,
  SUM_DEB,
  SUM_KRED,
  END_OST
) AS
    WITH acc_deb AS (SELECT OBOROT_MOVIES_DEB.PLAN_ACC_ID,
                            OBOROT_MOVIES_DEB.DIVISION_ID,
                            SUM(OBOROT_MOVIES_DEB.SUM_DEB) Sum_Deb
          FROM OBOROT_MOVIES_DEB
          GROUP BY OBOROT_MOVIES_DEB.PLAN_ACC_ID,
                   OBOROT_MOVIES_DEB.DIVISION_ID),
      acc_kred AS (SELECT OBOROT_MOVIES_KRED.PLAN_ACC_ID,
                          OBOROT_MOVIES_KRED.DIVISION_ID,
                          SUM(OBOROT_MOVIES_KRED.SUM_KRED) Sum_Kred
          FROM OBOROT_MOVIES_KRED
          GROUP BY OBOROT_MOVIES_KRED.PLAN_ACC_ID,
                   OBOROT_MOVIES_KRED.DIVISION_ID),
      div AS (SELECT id
          FROM divisions
          WHERE is_group = 0)
    SELECT p.ID,
           p.ACC_TYPE,
           p.PARENT_ID,
           p.FULLNAME,
           div.id division_id,
           p.CODE,
           entry.get_ostatok_by_date(p.CODE, ORDERS_ENTRY.get_startdatmoves(), div.id) start_ost,
           NVL((SELECT Sum_Deb
               FROM acc_deb
               WHERE acc_deb.PLAN_ACC_ID = p.ID
                 AND acc_deb.DIVISION_ID = div.id), 0) sum_deb,
           NVL((SELECT Sum_Kred
               FROM acc_kred
               WHERE acc_kred.PLAN_ACC_ID = p.ID
                 AND acc_kred.DIVISION_ID = div.id), 0) sum_kred,
           entry.get_ostatok_by_date(p.CODE, ORDERS_ENTRY.get_enddatmoves(), div.id) end_ost
      FROM PLAN_ACC p,
           div
      ORDER BY p.CODE;

--
-- Описание для представления VW_SALES
--
CREATE OR REPLACE VIEW VW_SALES (
  ORDER_ID,
  KONTRAG_ID,
  PERIOD,
  DIVISION_ID,
  SALES_SUMMA,
  FACT_SEBEST_SUMMA,
  PLAN_SEBEST_SUMMA,
  STATUS_ID,
  DAT_COMPLETE
) AS
    WITH sales AS (SELECT registrator_id,
                          period,
                          summa,
                          VW_SALES_ORDERS.SUBCONTO1_DEB kontrag_id
          FROM VW_SALES_ORDERS
          WHERE TRUNC(period) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
            AND TRUNC(period) <= TRUNC(ORDERS_ENTRY.get_enddatmoves())),
      sebest AS (SELECT registrator_id,
                        period,
                        summa,
                        VW_SEBEST_ORDERS.SUBCONTO1_DEB division_id
          FROM VW_SEBEST_ORDERS
          WHERE TRUNC(period) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
            AND TRUNC(period) <= TRUNC(ORDERS_ENTRY.get_enddatmoves()))
    SELECT o.id order_id,
           o.kontrag_id,
           o.dat period,
           o.division_id,
           (SELECT sales.summa
               FROM sales
               WHERE sales.registrator_id = o.id) sales_summa,
           (SELECT sebest.summa
               FROM sebest
               WHERE sebest.registrator_id = o.id) fact_sebest_summa,
           o.summ_plan plan_sebest_summa,
           o.status_id,
           o.dat_complete
      FROM orders o
      WHERE o.deleted = 0
        AND TRUNC(o.dat) >= TRUNC(ORDERS_ENTRY.get_startdatmoves())
        AND TRUNC(o.dat) <= TRUNC(ORDERS_ENTRY.get_enddatmoves());

--
-- Описание для представления VW_SUPPLIER_MOVES
--
CREATE OR REPLACE VIEW VW_SUPPLIER_MOVES (
  ID,
  KONTRAG_ID,
  KONTRAG,
  DIVISION_ID,
  TABLE_NAME,
  CODE,
  SUMM,
  SUMM_PRIHOD,
  SUMM_RASHOD,
  REGISTRATOR_ID,
  PERIOD,
  REG_STRING,
  PAYED,
  MARK
) AS
    SELECT MAX(ID) ID,
           KONTRAG_ID,
           KONTRAG,
           DIVISION_ID,
           TABLE_NAME,
           CODE,
           SUM(SUMM) SUMM,
           SUM(summ_prihod) SUMM_PRIHOD,
           SUM(summ_rashod) SUMM_RASHOD,
           REGISTRATOR_ID,
           PERIOD,
           REG_STRING,
           PAYED,
           (SELECT 0
               FROM dual) Mark
      FROM (SELECT MOVE_KONTRAG.ID,
                   MOVE_KONTRAG.KONTRAG_ID,
                   MOVE_KONTRAG.KONTRAG,
                   MOVE_KONTRAG.DIVISION_ID DIVISION_ID,
                   MOVE_KONTRAG.TABLE_NAME TABLE_NAME,
                   MOVE_KONTRAG.CODE,
                   MOVE_KONTRAG.SUMM,
                   CASE WHEN MOVE_KONTRAG.SUMM >= 0 THEN MOVE_KONTRAG.SUMM ELSE 0 END AS summ_rashod,
                   CASE WHEN MOVE_KONTRAG.SUMM < 0 THEN (-1) * MOVE_KONTRAG.SUMM ELSE 0 END AS summ_prihod,
                   MOVE_KONTRAG.REGISTRATOR_ID,
                   MOVE_KONTRAG.PERIOD,
                   CASE WHEN UPPER(MOVE_KONTRAG.TABLE_NAME) LIKE UPPER('orders') THEN (SELECT utility.order_payed_percent(MOVE_KONTRAG.REGISTRATOR_ID)
                             FROM dual) END AS payed,
                   CASE WHEN UPPER(MOVE_KONTRAG.TABLE_NAME) LIKE UPPER('orders') THEN 'Заказ №'
                         || (SELECT orders.NUM
                             FROM orders
                             WHERE orders.ID = MOVE_KONTRAG.REGISTRATOR_ID) || ' от '
                         || TO_CHAR((SELECT orders.DAT
                             FROM orders
                             WHERE orders.ID = MOVE_KONTRAG.REGISTRATOR_ID), 'DD-MM-YYYY') WHEN UPPER(MOVE_KONTRAG.TABLE_NAME) LIKE UPPER('pko') THEN 'ПКО №'
                         || (SELECT pko.NUM
                             FROM pko
                             WHERE pko.ID = MOVE_KONTRAG.REGISTRATOR_ID) || ' от '
                         || TO_CHAR((SELECT pko.DAT
                             FROM pko
                             WHERE pko.ID = MOVE_KONTRAG.REGISTRATOR_ID), 'DD-MM-YYYY') WHEN UPPER(MOVE_KONTRAG.TABLE_NAME) LIKE UPPER('rko') THEN 'РКО №'
                         || (SELECT rko.NUM
                             FROM rko
                             WHERE rko.ID = MOVE_KONTRAG.REGISTRATOR_ID) || ' от '
                         || TO_CHAR((SELECT rko.DAT
                             FROM rko
                             WHERE rko.ID = MOVE_KONTRAG.REGISTRATOR_ID), 'DD-MM-YYYY') WHEN UPPER(MOVE_KONTRAG.TABLE_NAME) LIKE UPPER('other_zatraty') THEN 'Админ. затраты №'
                         || (SELECT other_zatraty.NUM
                             FROM other_zatraty
                             WHERE other_zatraty.ID = MOVE_KONTRAG.REGISTRATOR_ID) || ' от '
                         || TO_CHAR((SELECT other_zatraty.DAT
                             FROM other_zatraty
                             WHERE other_zatraty.ID = MOVE_KONTRAG.REGISTRATOR_ID), 'DD-MM-YYYY') WHEN UPPER(MOVE_KONTRAG.TABLE_NAME) LIKE UPPER('start_ost') THEN 'Нач. остатки №' || (SELECT num
                             FROM start_ost
                             WHERE id = MOVE_KONTRAG.REGISTRATOR_ID) || ' от ' || TO_CHAR((SELECT dat
                             FROM start_ost
                             WHERE id = MOVE_KONTRAG.REGISTRATOR_ID), 'DD-MM-YYYY') WHEN UPPER(MOVE_KONTRAG.TABLE_NAME) LIKE UPPER('PROFIT_DISTRIB') THEN 'Распред. прибыли №' || (SELECT num
                             FROM profit_distrib
                             WHERE id = MOVE_KONTRAG.REGISTRATOR_ID) || ' от ' || TO_CHAR((SELECT dat
                             FROM profit_distrib
                             WHERE id = MOVE_KONTRAG.REGISTRATOR_ID), 'DD-MM-YYYY') END AS REG_STRING
          FROM MOVE_KONTRAG
            INNER JOIN KONTRAGENTS
              ON MOVE_KONTRAG.KONTRAG_ID = KONTRAGENTS.ID
          WHERE MOVE_KONTRAG.CODE = '5091'
            AND KONTRAGENTS.IS_MEASURER = 0)
      WHERE registrator_id NOT IN (SELECT id
            FROM rko
            WHERE order_id IS NOT NULL
              AND posted = 1)
        AND registrator_id NOT IN (SELECT id
            FROM pko
            WHERE order_id IS NOT NULL
              AND posted = 1)
      --and upper(DIVISION_ID) in (select upper(N) from table(cast(get_divisions(:u_name) as divisionTable)))  
      GROUP BY KONTRAG_ID,
               KONTRAG,
               DIVISION_ID,
               TABLE_NAME,
               CODE,
               REGISTRATOR_ID,
               PERIOD,
               REG_STRING,
               PAYED
      ORDER BY PERIOD DESC;

--
-- Описание для представления VW_BALLANS
--
CREATE OR REPLACE VIEW VW_BALLANS (
  ID,
  PARENT_ID,
  ACC_TYPE,
  ACTIVE_PASSIVE,
  CODE,
  FULLNAME,
  START_OST,
  SUM_DEB,
  SUM_KRED,
  END_OST,
  DIVISION_ID
) AS
    SELECT oborot_movies.ID,
           oborot_movies.PARENT_ID,
           oborot_movies.ACC_TYPE,
           ENUM_ACCOUNT_TYPE.FULLNAME AS Active_Passive,
           oborot_movies.CODE,
           oborot_movies.FULLNAME,
           oborot_movies.START_OST,
           oborot_movies.SUM_DEB,
           oborot_movies.SUM_KRED,
           oborot_movies.END_OST,
           oborot_movies.DIVISION_ID
      FROM oborot_movies
        INNER JOIN ENUM_ACCOUNT_TYPE
          ON oborot_movies.ACC_TYPE = ENUM_ACCOUNT_TYPE.ID
      WHERE (oborot_movies.SUM_DEB <> 0)
        OR (oborot_movies.SUM_KRED <> 0)
        OR (oborot_movies.START_OST <> 0)
        OR (oborot_movies.END_OST <> 0);

--
-- Описание для представления VW_BALLANS_AP
--
CREATE OR REPLACE VIEW VW_BALLANS_AP (
  ID,
  CODE,
  FULLNAME,
  ACTIVE_START,
  ACTIVE_DEB,
  ACTIVE_KRED,
  ACTIVE_OBOROT,
  ACTIVE_END,
  PASSIVE_START,
  PASSIVE_DEB,
  PASSIVE_KRED,
  PASSIVE_OBOROT,
  PASSIVE_END,
  DIVISION_ID
) AS
    WITH act AS (SELECT code,
                        start_ost,
                        sum_deb,
                        sum_kred,
                        end_ost,
                        division_id,
                        end_ost - start_ost oborot
          FROM vw_ballans
          WHERE UPPER(ACTIVE_PASSIVE) = UPPER('Активный')
            OR UPPER(ACTIVE_PASSIVE) = UPPER('Активный/Пассивный')),
      pass AS (SELECT code,
                      start_ost,
                      sum_deb,
                      sum_kred,
                      end_ost,
                      division_id,
                      end_ost - start_ost oborot
          FROM vw_ballans
          WHERE UPPER(ACTIVE_PASSIVE) = UPPER('Пассивный'))
    SELECT b.id,
           b.code,
           b.fullname,
           NVL((SELECT start_ost
               FROM act
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Active_Start,
           NVL((SELECT sum_deb
               FROM act
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Active_Deb,
           NVL((SELECT sum_kred
               FROM act
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Active_Kred,
           NVL((SELECT oborot
               FROM act
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Active_Oborot,
           NVL((SELECT end_ost
               FROM act
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Active_end,
           NVL((SELECT start_ost
               FROM pass
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Passive_Start,
           NVL((SELECT sum_deb
               FROM pass
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Passive_Deb,
           NVL((SELECT sum_kred
               FROM pass
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Passive_Kred,
           NVL((SELECT oborot
               FROM pass
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Passive_Oborot,
           NVL((SELECT end_ost
               FROM pass
               WHERE code = b.code
                 AND division_id = b.division_id), 0) Passive_End,
           b.division_id
      FROM vw_ballans b;

--
-- Описание для триггера ASTER_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER ASTER_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON ASTER_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера BASE_OF_CALC_TRG
--
CREATE OR REPLACE TRIGGER BASE_OF_CALC_TRG
  BEFORE INSERT OR UPDATE
  ON BASE_OF_CALC
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера BASE_OF_NACHISL_TRG
--
CREATE OR REPLACE TRIGGER BASE_OF_NACHISL_TRG
  BEFORE INSERT OR UPDATE
  ON BASE_OF_NACHISL
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера CALL_LISTS_TRG
--
CREATE OR REPLACE TRIGGER CALL_LISTS_TRG
  BEFORE INSERT OR UPDATE
  ON CALL_LISTS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера CALL_LOG_TRG
--
CREATE OR REPLACE TRIGGER CALL_LOG_TRG
  BEFORE INSERT OR UPDATE
  ON CALL_LOG
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера CALL_MEMO_TRG
--
CREATE OR REPLACE TRIGGER CALL_MEMO_TRG
  BEFORE INSERT OR UPDATE
  ON CALL_MEMO
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера CALL_RESULTS_TRG
--
CREATE OR REPLACE TRIGGER CALL_RESULTS_TRG
  BEFORE INSERT OR UPDATE
  ON CALL_RESULTS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера CALL_STATUS_TRG
--
CREATE OR REPLACE TRIGGER CALL_STATUS_TRG
  BEFORE INSERT OR UPDATE
  ON CALL_STATUS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера CDR_TRG
--
CREATE OR REPLACE TRIGGER CDR_TRG
  BEFORE INSERT OR UPDATE
  ON CDR
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера COMPAIGNS_DETAILS_TRG
--
CREATE OR REPLACE TRIGGER COMPAIGNS_DETAILS_TRG
  BEFORE INSERT OR UPDATE
  ON COMPAIGNS_DETAILS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера COMPAIGNS_TRG
--
CREATE OR REPLACE TRIGGER COMPAIGNS_TRG
  BEFORE INSERT OR UPDATE
  ON COMPAIGNS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера CONTACT_DETAILS_TGR
--
CREATE OR REPLACE TRIGGER CONTACT_DETAILS_TGR
  BEFORE INSERT OR UPDATE
  ON CONTACT_DETAILS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера CURRENCY_TGR
--
CREATE OR REPLACE TRIGGER CURRENCY_TGR
  BEFORE INSERT OR UPDATE
  ON CURRENCY
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера CURRENCY_TRG_AI
--
CREATE OR REPLACE TRIGGER CURRENCY_TRG_AI
  AFTER INSERT
  ON CURRENCY
  FOR EACH ROW
BEGIN
  INSERT INTO reg_rates (
    curr_id
  )
  VALUES (:new."ID");
END;

/

--
-- Описание для триггера DIR_FILE_UPLOAD_TRG
--
CREATE OR REPLACE TRIGGER DIR_FILE_UPLOAD_TRG
  BEFORE INSERT OR UPDATE
  ON DIR_FILE_UPLOAD
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера DIVISION_SOTR_TRG
--
CREATE OR REPLACE TRIGGER DIVISION_SOTR_TRG
  BEFORE INSERT OR UPDATE
  ON DIVISION_SOTR
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера DIVISIONS_TRG
--
CREATE OR REPLACE TRIGGER DIVISIONS_TRG
  BEFORE INSERT OR UPDATE
  ON DIVISIONS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера ENTRY_SETTINGS_TGR
--
CREATE OR REPLACE TRIGGER ENTRY_SETTINGS_TGR
  BEFORE INSERT OR UPDATE
  ON ENTRY_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера ENUM_ACCOUNT_TYPE_TRG
--
CREATE OR REPLACE TRIGGER ENUM_ACCOUNT_TYPE_TRG
  BEFORE INSERT OR UPDATE
  ON ENUM_ACCOUNT_TYPE
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера EX_RATES_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER EX_RATES_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON EX_RATES_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера FIRMS_TRG
--
CREATE OR REPLACE TRIGGER FIRMS_TRG
  BEFORE INSERT OR UPDATE
  ON FIRMS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера GROUPMEMBERS_TRG
--
CREATE OR REPLACE TRIGGER GROUPMEMBERS_TRG
  BEFORE INSERT OR UPDATE
  ON GROUPMEMBERS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера GROUPS_TRG
--
CREATE OR REPLACE TRIGGER GROUPS_TRG
  BEFORE INSERT OR UPDATE
  ON GROUPS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера IMPORTED_PRICE_TRG
--
CREATE OR REPLACE TRIGGER IMPORTED_PRICE_TRG
  BEFORE INSERT OR UPDATE
  ON IMPORTED_PRICE
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера INSIDE_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER INSIDE_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON INSIDE_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера JOB_END_TRG
--
CREATE OR REPLACE TRIGGER JOB_END_TRG
  BEFORE UPDATE OR DELETE
  ON QRTZ_TRIGGERS
BEGIN
  IF DELETING
    OR UPDATING
  THEN
    UPDATE NOTIFICATION
      SET SERVER = '1', CLIENT = '0'
      WHERE TRG_NAME = (SELECT TRIGGER_NAME
          FROM (SELECT TRIGGER_NAME
              FROM QRTZ_TRIGGERS
              ORDER BY NEXT_FIRE_TIME)
          WHERE ROWNUM = 1);
  END IF;
END;

/

--
-- Описание для триггера KASSA_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER KASSA_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON KASSA_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера KASSA_TRG
--
CREATE OR REPLACE TRIGGER KASSA_TRG
  BEFORE INSERT OR UPDATE
  ON KASSA
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера KONTRAGENTS_TRG
--
CREATE OR REPLACE TRIGGER KONTRAGENTS_TRG
  BEFORE INSERT OR UPDATE
  ON KONTRAGENTS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера KONTRAG_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER KONTRAG_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON KONTRAG_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера MEASURE_UNIT_TGR
--
CREATE OR REPLACE TRIGGER MEASURE_UNIT_TGR
  BEFORE INSERT OR UPDATE
  ON MEASURE_UNIT
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера MOVES_TGR
--
CREATE OR REPLACE TRIGGER MOVES_TGR
  BEFORE INSERT OR UPDATE
  ON MOVES
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера NACHISL_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER NACHISL_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON NACHISL_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера NOMENKLATURA_TRG
--
CREATE OR REPLACE TRIGGER NOMENKLATURA_TRG
  BEFORE INSERT OR UPDATE
  ON NOMENKLATURA
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера NOTIFICATION_TRG
--
CREATE OR REPLACE TRIGGER NOTIFICATION_TRG
  BEFORE INSERT OR UPDATE
  ON NOTIFICATION
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера NUMERATOR_TGR
--
CREATE OR REPLACE TRIGGER NUMERATOR_TGR
  BEFORE INSERT OR UPDATE
  ON NUMERATOR
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера OPERATION_PKO_TGR
--
CREATE OR REPLACE TRIGGER OPERATION_PKO_TGR
  BEFORE INSERT OR UPDATE
  ON OPERATION_PKO
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера OPERATION_RKO_TGR
--
CREATE OR REPLACE TRIGGER OPERATION_RKO_TGR
  BEFORE INSERT OR UPDATE
  ON OPERATION_RKO
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера ORDER_STATUS_TGR
--
CREATE OR REPLACE TRIGGER ORDER_STATUS_TGR
  BEFORE INSERT OR UPDATE
  ON ORDER_STATUS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера ORDERS_TP_NACHISL_TRG
--
CREATE OR REPLACE TRIGGER ORDERS_TP_NACHISL_TRG
  BEFORE INSERT OR UPDATE
  ON ORDERS_TP_NACHISL
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера ORDERS_TP_OPLATY_TRG
--
CREATE OR REPLACE TRIGGER ORDERS_TP_OPLATY_TRG
  BEFORE INSERT OR UPDATE
  ON ORDERS_TP_OPLATY
  FOR EACH ROW
BEGIN
  IF inserting
  THEN


    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера ORDERS_TP_RASHODY_TRG
--
CREATE OR REPLACE TRIGGER ORDERS_TP_RASHODY_TRG
  BEFORE INSERT OR UPDATE
  ON ORDERS_TP_RASHODY
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера ORDERS_TP_USLUGI_TRG
--
CREATE OR REPLACE TRIGGER ORDERS_TP_USLUGI_TRG
  BEFORE INSERT OR UPDATE
  ON ORDERS_TP_USLUGI
  FOR EACH ROW
BEGIN
  IF inserting
  THEN


    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера ORDERS_TRG
--
CREATE OR REPLACE TRIGGER ORDERS_TRG
  BEFORE INSERT OR UPDATE
  ON ORDERS
  FOR EACH ROW
DECLARE
  l_rec type_def % ROWTYPE;
  l_num numerator.prefix % TYPE;
  d_num divisions.prefix % TYPE;
  p_num VARCHAR2(20);
BEGIN
  IF inserting
  THEN
    SELECT *
      INTO l_rec
      FROM type_def
      WHERE UPPER(table_name) = 'ORDERS';
    IF l_rec.id IS NOT NULL
    THEN
      SELECT prefix
        INTO l_num
        FROM numerator
        WHERE typedef_id = l_rec.id;
    END IF;

    SELECT prefix
      INTO d_num
      FROM divisions
      WHERE id = :NEW."DIVISION_ID";

    IF d_num IS NOT NULL
    THEN
      p_num := d_num;
    ELSIF l_num IS NOT NULL
    THEN
      p_num := l_num;
    END IF;

    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
    IF :new."NUM" IS NULL
    THEN
      IF p_num IS NULL
      THEN
        SELECT orders_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      ELSE
        SELECT p_num || orders_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      END IF;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера OTHER_ZATRATY_TRG
--
CREATE OR REPLACE TRIGGER OTHER_ZATRATY_TRG
  BEFORE INSERT OR UPDATE
  ON OTHER_ZATRATY
  FOR EACH ROW
DECLARE
  l_rec type_def % ROWTYPE;
  l_num numerator.prefix % TYPE;
  d_num divisions.prefix % TYPE;
  p_num VARCHAR2(20);
BEGIN
  IF inserting
  THEN
    SELECT *
      INTO l_rec
      FROM type_def
      WHERE UPPER(table_name) = 'OTHER_ZATRATY';
    IF l_rec.id IS NOT NULL
    THEN
      SELECT prefix
        INTO l_num
        FROM numerator
        WHERE typedef_id = l_rec.id;
    END IF;

    SELECT prefix
      INTO d_num
      FROM divisions
      WHERE id = :NEW."DIVISION_ID";

    IF d_num IS NOT NULL
    THEN
      p_num := d_num;
    ELSIF l_num IS NOT NULL
    THEN
      p_num := l_num;
    END IF;

    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
    IF :new."NUM" IS NULL
    THEN
      IF l_num IS NULL
      THEN
        SELECT other_zatr_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      ELSE
        SELECT p_num || other_zatr_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      END IF;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера OTHER_ZATR_TP_ZATRATY_TRG
--
CREATE OR REPLACE TRIGGER OTHER_ZATR_TP_ZATRATY_TRG
  BEFORE INSERT OR UPDATE
  ON OTHER_ZATRATY_TAB_PART_ZATRATY
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера PAY_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER PAY_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON PAY_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера PKO_TRG
--
CREATE OR REPLACE TRIGGER PKO_TRG
  BEFORE INSERT OR UPDATE
  ON PKO
  FOR EACH ROW
DECLARE
  l_rec type_def % ROWTYPE;
  l_num numerator.prefix % TYPE;
  d_num divisions.prefix % TYPE;
  p_num VARCHAR2(20);
BEGIN
  IF inserting
  THEN
    SELECT *
      INTO l_rec
      FROM type_def
      WHERE UPPER(table_name) = 'PKO';
    IF l_rec.id IS NOT NULL
    THEN
      SELECT prefix
        INTO l_num
        FROM numerator
        WHERE typedef_id = l_rec.id;
    END IF;

    SELECT prefix
      INTO d_num
      FROM divisions
      WHERE id = :NEW."DIVISION_ID";

    IF d_num IS NOT NULL
    THEN
      p_num := d_num;
    ELSIF l_num IS NOT NULL
    THEN
      p_num := l_num;
    END IF;

    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
    IF :new."NUM" IS NULL
    THEN
      IF l_num IS NULL
      THEN
        SELECT pko_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      ELSE
        SELECT p_num || pko_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      END IF;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера PLAN_ACC_SUBCONTO_TRG
--
CREATE OR REPLACE TRIGGER PLAN_ACC_SUBCONTO_TRG
  BEFORE INSERT OR UPDATE
  ON PLAN_ACC_SUBCONTO
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера PLAN_ACC_TRG
--
CREATE OR REPLACE TRIGGER PLAN_ACC_TRG
  BEFORE INSERT OR UPDATE
  ON PLAN_ACC
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера PLAN_TYPE_SUBCONTO_TRG
--
CREATE OR REPLACE TRIGGER PLAN_TYPE_SUBCONTO_TRG
  BEFORE INSERT OR UPDATE
  ON PLAN_TYPE_SUBCONTO
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера PROFIT_DISTRIB_TP_TRG
--
CREATE OR REPLACE TRIGGER PROFIT_DISTRIB_TP_TRG
  BEFORE INSERT OR UPDATE
  ON PROFIT_DISTRIB_TP
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера PROFIT_DISTRIB_TRG
--
CREATE OR REPLACE TRIGGER PROFIT_DISTRIB_TRG
  BEFORE INSERT OR UPDATE
  ON PROFIT_DISTRIB
  FOR EACH ROW
DECLARE
  l_rec type_def % ROWTYPE;
  l_num numerator.prefix % TYPE;
BEGIN
  IF inserting
  THEN
    SELECT *
      INTO l_rec
      FROM type_def
      WHERE UPPER(table_name) = 'PROFIT_DISTRIB';
    IF l_rec.id IS NOT NULL
    THEN
      SELECT prefix
        INTO l_num
        FROM numerator
        WHERE typedef_id = l_rec.id;
    END IF;

    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
    IF :new."NUM" IS NULL
    THEN
      IF l_num IS NULL
      THEN
        SELECT PROFIT_DISTRIB_NUM_SEQ.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      ELSE
        SELECT l_num || PROFIT_DISTRIB_NUM_SEQ.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      END IF;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера PROG_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER PROG_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON PROG_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера QUARTZ_PROPERTY_TRG
--
CREATE OR REPLACE TRIGGER QUARTZ_PROPERTY_TRG
  BEFORE INSERT OR UPDATE
  ON QUARTZ_PROPERTY
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера RATING_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER RATING_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON RATING_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера REG_PRICES_TRG
--
CREATE OR REPLACE TRIGGER REG_PRICES_TRG
  BEFORE INSERT OR UPDATE
  ON REG_PRICES
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера REG_RATES_TRG
--
CREATE OR REPLACE TRIGGER REG_RATES_TRG
  BEFORE INSERT OR UPDATE
  ON REG_RATES
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера RKO_TRG
--
CREATE OR REPLACE TRIGGER RKO_TRG
  BEFORE INSERT OR UPDATE
  ON RKO
  FOR EACH ROW
DECLARE
  l_rec type_def % ROWTYPE;
  l_num numerator.prefix % TYPE;
  d_num divisions.prefix % TYPE;
  p_num VARCHAR2(20);
BEGIN
  IF inserting
  THEN
    SELECT *
      INTO l_rec
      FROM type_def
      WHERE UPPER(table_name) = 'RKO';
    IF l_rec.id IS NOT NULL
    THEN
      SELECT prefix
        INTO l_num
        FROM numerator
        WHERE typedef_id = l_rec.id;
    END IF;

    SELECT prefix
      INTO d_num
      FROM divisions
      WHERE id = :NEW."DIVISION_ID";

    IF d_num IS NOT NULL
    THEN
      p_num := d_num;
    ELSIF l_num IS NOT NULL
    THEN
      p_num := l_num;
    END IF;

    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
    IF :new."NUM" IS NULL
    THEN
      IF l_num IS NULL
      THEN
        SELECT rko_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      ELSE
        SELECT p_num || rko_num_seq.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      END IF;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера START_OST_TP_TRG
--
CREATE OR REPLACE TRIGGER START_OST_TP_TRG
  BEFORE INSERT OR UPDATE
  ON START_OST_TP
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера START_OST_TRG
--
CREATE OR REPLACE TRIGGER START_OST_TRG
  BEFORE INSERT OR UPDATE
  ON START_OST
  FOR EACH ROW
DECLARE
  l_rec type_def % ROWTYPE;
  l_num numerator.prefix % TYPE;
BEGIN
  IF inserting
  THEN
    SELECT *
      INTO l_rec
      FROM type_def
      WHERE UPPER(table_name) = 'START_OST';
    IF l_rec.id IS NOT NULL
    THEN
      SELECT prefix
        INTO l_num
        FROM numerator
        WHERE typedef_id = l_rec.id;
    END IF;

    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
    IF :new."NUM" IS NULL
    THEN
      IF l_num IS NULL
      THEN
        SELECT START_OST_NUM_SEQ.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      ELSE
        SELECT l_num || START_OST_NUM_SEQ.NEXTVAL
          INTO :new."NUM"
          FROM dual;
      END IF;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера TYPE_DEF_TRG
--
CREATE OR REPLACE TRIGGER TYPE_DEF_TRG
  BEFORE INSERT OR UPDATE
  ON TYPE_DEF
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера TYPE_OF_ACTIVITIES_TGR
--
CREATE OR REPLACE TRIGGER TYPE_OF_ACTIVITIES_TGR
  BEFORE INSERT OR UPDATE
  ON TYPE_OF_ACTIVITIES
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера USER_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER USER_SETTINGS_TRG
  BEFORE INSERT
  ON USER_SETTINGS
  FOR EACH ROW
DECLARE
  a NUMBER;
BEGIN
  IF inserting
  THEN
    SELECT COUNT(*)
      INTO a
      FROM USER_SETTINGS
      WHERE user_id = :NEW."USER_ID";
    IF a >= 1
    THEN
      RAISE_APPLICATION_ERROR(-20100, 'Can not insert more than one row');
    END IF;
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера USERS_GROUPS_TRG
--
CREATE OR REPLACE TRIGGER USERS_GROUPS_TRG
  BEFORE INSERT OR UPDATE
  ON USERS_GROUPS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера USERS_TRG
--
CREATE OR REPLACE TRIGGER USERS_TRG
  BEFORE INSERT OR UPDATE
  ON USERS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :new."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
    IF :new."PASS_WD" IS NULL
    THEN
      SELECT utility.md5('1')
        INTO :new."PASS_WD"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
    IF :old."DATE_BEFORE" <> :new."DATE_BEFORE"
    THEN
      SELECT 0
        INTO :new."DATE_BEFIRE_ACCEPT"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера VOUCHER_TRG
--
CREATE OR REPLACE TRIGGER VOUCHER_TRG
  BEFORE INSERT OR UPDATE
  ON VOUCHER
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера WLS_SETTINGS_TRG
--
CREATE OR REPLACE TRIGGER WLS_SETTINGS_TRG
  BEFORE INSERT OR UPDATE
  ON WLS_SETTINGS
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :new."ID"
        FROM dual;
    END IF;
  END IF;
END;

/

--
-- Описание для триггера XML_T_TRG
--
CREATE OR REPLACE TRIGGER XML_T_TRG
  BEFORE INSERT OR UPDATE
  ON XML_T
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

--
-- Описание для триггера ZATRATY_TRG
--
CREATE OR REPLACE TRIGGER ZATRATY_TRG
  BEFORE INSERT OR UPDATE
  ON ZATRATY
  FOR EACH ROW
BEGIN
  IF inserting
  THEN
    IF :NEW."ID" IS NULL
    THEN
      SELECT utility.uuid()
        INTO :NEW."ID"
        FROM dual;
    END IF;
  END IF;
  IF updating
  THEN
    SELECT systimestamp
      INTO :new."VERSION"
      FROM dual;
  END IF;
END;

/

COMMIT;

-- 
-- Установка схемы по умолчанию
--
DECLARE
  p VARCHAR2(255);
BEGIN 
  SELECT USER INTO p FROM DUAL;
  EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = ' || p;
END;
/